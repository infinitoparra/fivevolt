<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WX.Net</name>
    </assembly>
    <members>
        <member name="T:WX.Event">
            <summary>The class of  wxWidgets events.</summary>
        </member>
        <member name="T:WX.Object">
            <summary>This is the base class of all <c>wxWidgets</c> objects. This class manages pointers to C++ objects.
             </summary>
             <remarks>
             When wrapping C++ to be used in modern OO programming languages like C# or JAVA, the main
             difficulties arise from the different object model. On C++ instances are structs. In most
             other languages (keeping ancient things like Simula 1967 aside) instances are references
             to structs. C++ knows a lot of modifiers for data types without correlation in C#.
             One of the most problematic thing is wrapping <c>const</c> <c>wxObject &amp;</c> results from selectors.
             Requirements:
             \li Since most  WX.Net wrappers provide the full of  wxWidgets objects, the  WX.Net
                 generates many instances to generate independent objects. This is for instances the case
                 with strings (class wx.wxString). In these cases  WX.Net will take ownership of the
                 new object and destroy it on disposing the  WX.Net wrapper.
             \li Another option that is used in some rare cases is to wrap the pointer of a const referenced
                 object into a wrapper that does not provide any opportunity to modify the represented value.
                 Problem: One needs wrappers without any modifiers. Prerequisite:  wxWidgets continues to
                 have full ownership of the referenced memory but  WX.Net is preferred to reuse a wrapper
                 instance. So, this class as a static container of all generated members of this kind.
                 This container can be searched by method wx.Object.FindObject(). Problem: Garbage collection will never
                 destroy the wrapper instances. So, this functon can be turned off using enumeration
                 <c>StorageMode.VolatileObject</c>. In these case the C++ object usually receives a callback to
                 be used on destruction to delete all references of the .NET wrapper to the deleted C++ object.
                 Please keep also in mind, that using wx.Object.FindObject() usually means that one wants to find
                 a previous wrapper on an instance retrieved from C++. So, this instance is likely to be destroyed
                 by the C++ implementation and not by the .NET wrapper. Consequently, you have to deactivate wx.Object.memOwn.
             \li A rare specialization of the previous case: Since the  wxWidgets object does not provide the opportunity
                 to call back on destruction, the object will be deleted on destroying the  wxWidgets container that probably
                 hold the object. Consider wx.HtmlBookRecord and wx.HtmlBookRecords as examples.
             \li The standard defensive way is to use both: New instances owned by  WX.Net plus static container
                 of instances.
             \li Refer to wx.Object.DllSync. Use this object to synchronze calls to the <c>wx-c</c> DLL at least
                 if these calls create new C++ objects or delete them.
             \li Usually, you will use FindObject() to identify preexisting wrappers for pointers to
                 C++ instances of <c>wxObject</c>. This method may also serve as a factory for wrappers if you
                 know the  WX.Net class of this new wrapper. If you don't know the class that shall be used
                 for the creation of wrappers, you have the option to use the interface to the  wxWidgets
                 RTTI. Refer to the remarks on wx.Object.ClassInfo.
             
             Classes wrapping a class implementing a non-virtual desctructor have to implement
             their own Dispose() method. Most of the other needs for managing C++ pointers are
             satisfied by this class.
             
             AddObject() and RemoveObject() implement a data base containing all wrappers to C++ pointers.
             So, methods receiving a pointer to a already wrapped object can retrieve this preexisting wrapper
             and reuse it by FindObject().
             
             More elaborate classes do not wrap the original  wxWidgets object but a C++ wrapper informing
             WX.Net on deallocating the  wxWidgets object. Usually, such wrappers receive a delegate of type
             Virtual_Dispose() that calls VirtualDispose().  Please  note  whenever  passing  delegates  to  C++
              objects: Load class member variables with these delegates in order to prevent undesired disposal
             of the delegates. This class offers member variable virtual_Dispose() to store the delegate
             of type Virtual_Dispose().  Please  note, that some  wxWidgets classes like <c>wxString</c> or
             <c>wxArrayString</c> have non-virtual destructors that, nevertheless, must run on destruction. So,
             adding callbacks on destruction is not applicable to all  wxWidget classes.
             File <c>local_events.h</c> in the <c>wx-c</c> directory of the sources contains some support for callbacks
             on desctruction and some other frequent cases on wrapping.
             
             Contributors should also not forget to initialize all callbacks to NULL on construction and to
             call only callbacks which are not NULL. This is important to achieve reliant code - it is important
             that instances with callbacks also run before these callbacks have been registered.
            </remarks>
        </member>
        <member name="F:WX.Object.objects">
            <summary>Hashtable to associate C++ objects with C# references</summary>
        </member>
        <member name="F:WX.Object.memOwn">
            <summary>memOwn is true when we create a new instance with the wrapper ctor
            		 or if a call to a wrapper function returns new c++ instance.
            		 Otherwise the created c++ object won't be deleted by the Dispose member.
                     
                     This member will now usually be set explicitely or depending on the StorageMode.</summary>
        </member>
        <member name="M:WX.Object.#ctor(System.IntPtr,WX.Object.StorageMode)">
            <summary>Default construction for objects of defined storage mode but with default memory ownership.
            wx.Object.StorageMode.VolatileObject will be allocated with memory ownership.
            Registered Objects will usually be allocated without memory ownership.</summary>
        </member>
        <member name="M:WX.Object.GetTranslation(System.Type)">
            <summary>This will return a translation of the type name.</summary>
            <remarks>Translations of types may be useful if the type represent a notion in the real world that has a name.
            For instance, wx.Font represents fonts. "Font" is a human readable name. If you want to print information on an
            object <c>o</c> - what kind of object is this - you might use wx.Object.GetTranslation(o.GetType()).
            
            Types may either provide a human readable name as defined by a wx.Globalization.TypeNameTranslationsAttribute attribute.
            Or they are translated by a \e gettext catalogue. This method will first search for a translation of the full qualified
            name. Then, this will search for a translation of the short type name.
            
            This will return a translation into the current wx.Locale.Language.</remarks>
        </member>
        <member name="M:WX.Object.GetTranslation(System.Enum)">
            <summary>This will translate the provided enumeration value.</summary>
            <remarks>
            You have two options to translate enumeration values.
            The enumeration might provide attributes of type wx.Globalization.EnumValueTranslations. If present, these
            will be used for translation first.
            However, if this fails, this will query the known \c gettext catalogs for a string \c "namespace.enumeration_type.enumeration_value".
            If this query fails, this will simply return \c "enumeration_value". Use tool \c getenums.exe to load
            enumeration values of an assembly into a gettext POT file.
            
            All translations will be done into the current \c wx.Locale.Language.
            </remarks>
        </member>
        <member name="M:WX.Object.GetTranslation(System.String)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:WX.Object.GetTranslation(WX.wxString)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:WX.Object._(System.String)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:WX.Object._(System.Type)">
            <summary>This will return a translation of the type name.</summary>
            <remarks>Translations of types may be useful if the type represent a notion in the real world that has a name.
            For instance, wx.Font represents fonts. "Font" is a human readable name. If you want to print information on an
            object <c>o</c> - what kind of object is this - you might use wx.Object.GetTranslation(o.GetType()).
            
            Types may either provide a human readable name as defined by a wx.Globalization.TypeNameTranslationsAttribute attribute.
            Or they are translated by a gettext catalogue. This method will first search for a translation of the full qualified
            name. Then, this will search for a translation of the short type name.
            
            This will return a translation into the current wx.Locale.Language.
            </remarks>
        </member>
        <member name="M:WX.Object._(System.Enum)">
            <summary>Returns the translation of the enumeration value.
             Suppose, we have an enumeration <c>Assembly.Enumeration</c> containing a value <c>Assembly.Enumeration.Value</c>.
             Then, this will look for a translation of "Assembly.Enumeration.Value" first and then, if this fails, for a
             translation of "Value".
            
             Translations may also be provided by wx.Globalization.EnumValueTranslations.</summary>
        </member>
        <member name="M:WX.Object._(System.String,System.Object[])">
            <summary>This will translate <c>format</c> into the currently selected locale and then paste sting versions of the arguments into the result.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:WX.Object.__(System.String)">
            <summary>This is a dummy method that programmers may use to mark a text as to be translated by GETTEXT but not here.</summary><remarks>
                     * Example:
                     * \code
                     string theUntranslatedText=wx.Object.__("The untranslated text.");
                     System.Diagnostics.Trace.WriteLine(theUntranslatedText);     // this can be understood by developers.
                     System.Console.WriteLine(wx.Object._(theUntranslatedString); // this can be understood by the user of the program.
                     \endcode
                     * </remarks>
        </member>
        <member name="M:WX.Object.GetTypeName(System.IntPtr)">
            <summary>This will return the name of the C++ class of the wrapped pointer.
            Information will be derived from the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Object.GetTypeName">
            <summary>This will return the name of the C++ class of the wrapped pointer.
            Information will be derived from the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Object.GetClassInfo">
            <summary>This will return a wrapper of the  wxWidgets RTTI representation.</summary>
        </member>
        <member name="M:WX.Object.AddObject(WX.Object)">
            <summary>Registers an Object, so that it can be referenced using a C++ object
            		 pointer.</summary>
        </member>
        <member name="M:WX.Object.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:WX.Object.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.</summary>
            <param name="memOwn">defines whether this method creates wrappers owning the C++ object or not.</param>
        </member>
        <member name="M:WX.Object.FindObject(System.IntPtr,System.Type)">
            <summary>Locates the registered object that references the given C++ object pointer.
                      
                    If the pointer is not found, a reference to the object is created 
                    using type.
                    
                    Wrappers created by this method will not own the memory allocated by <c>ptr</c>.</summary>
        </member>
        <member name="M:WX.Object.FindObject(System.IntPtr,System.Type,System.Boolean)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             The result is assignable to <c>type</c>.
             
             If the pointer is not found, a reference to the object is created 
             using type.
            
             Argument <c>memOwn</c> defines, whether a fresh created wrapper owns
             the memory allcoated by <c>ptr</c>.
            
             </summary>
        </member>
        <member name="M:WX.Object.FindObject(System.IntPtr,System.Type,System.Type)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             If the pointer is not found, a reference to the object is created 
             using type.
            
             If this creates a new wrapper, this wrapper will NOT own the native instance.
             </summary>
             <param name="ptr">C++ pointer that shall be wrapped.</param>
             <param name="returnType">The resulting wrapper will be assignable to this type.</param>
             <param name="defaultType">Newly created wrappers will be of this type. Instances of this type shall be assignable to the return type.</param>
        </member>
        <member name="M:WX.Object.FindObject(System.IntPtr,System.Type,System.Type,System.Boolean)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             If the pointer is not found, a reference to the object is created 
             using type.
            
             Argument <c>memOwn</c> defines, whether a fresh created wrapper owns
             the memory allcoated by <c>ptr</c>.
             </summary>
             <param name="ptr">C++ pointer that shall be wrapped.</param>
             <param name="memOwn">Indicates with true that newly created instances shall own the native memory.</param>
             <param name="returnType">The resulting wrapper will be assignable to this type.</param>
             <param name="defaultType">Newly created wrappers will be of this type. Instances of this type shall be assignable to the return type.</param>
        </member>
        <member name="M:WX.Object.FindObject(System.IntPtr)">
            <summary>Locates the registered object that references the given C++ object
            pointer.</summary>
        </member>
        <member name="M:WX.Object.RemoveObject(System.IntPtr)">
            <summary>Removes a registered object.
            		 returns true if the object is found in the
            		 Hashtable and is removed (for Dispose)</summary>
        </member>
        <member name="M:WX.Object.VirtualDispose">
            <summary>called when an C++ (wx)Object dtor gets invoked
             This method may be passed to native objects that can use a 
             Virtual_Dispose method that will be called on deleting the native
             object.
            </summary>
        </member>
        <member name="M:WX.Object.VirtualDisposeAll">
            <summary>Dispose all safed instances of wrappers.
            This will be done for instance on closing the application.</summary>
        </member>
        <member name="M:WX.Object.CallDTor">
            <summary>This will be called by Dispose() to delete the C++ object.
            Overload this if you have to use another DTor.</summary>
        </member>
        <member name="M:WX.Object.DeregisterWrapper">
            <summary>Use this to implement services that decouple the .NET wrapper from the native  wxWidgets objects.
            Example: Remove callback function pointers.
            Please note that this may be called more than once.</summary>
        </member>
        <member name="P:WX.Object.SavedInstancesCount">
            <summary>Use this to get the number of valid/undisposed instances of  wxWidgets objects.</summary>
        </member>
        <member name="P:WX.Object.InstancesCount">
            <summary>Use this to read the number of valid instances.
            This will return the number of generated and undisposed instances of this class
            regardless whether these objects have been saved in the static container for
            instances or not.</summary>
        </member>
        <member name="P:WX.Object.DllSync">
            <summary>Use this object to synchronize calls to the <c>wx-c</c> DLL.
             Apparently, allocation and deallocation of C++ objects using <c>new</c> and <c>delete</c>
             must be synchronized at least on  Windows. It is generally a good idea, to synchronize
             most of calls to the DLL. Please keep in mind, that the garbage collector runs in
             parallel to the program. So, you typically have at least two threads running that
             use the <c>wx-c</c> DLL.
            </summary>
        </member>
        <member name="P:WX.Object.IsNULL">
            <summary>
            True if this does not refer to a valid C++ object.
            This situation typically occurs when a wrapped C++ object gets deallocated but
            the wrapper has net yet been finalized.
            </summary>
        </member>
        <member name="T:WX.Object.ClassInfo">
            <summary>This wrapps the  wxWidgets <c>wxClassInfo</c>.
            This class implements a DB of registered class informations.
            This DB may be used to identify pointers to <c>wxObject</c> by
            FindClassInfoOf(). Prerequisite: The wrapper class (e.g. HtmlCell) implements a public and static
            method <c>GetWxClassInfo()</c> creating a wrapper ClassInfo of that intance of
            <c>wxClassInfo</c> describing the type of the wrapped C++ class.
            </summary>
        </member>
        <member name="M:WX.Object.ClassInfo.FindOrCreate(System.IntPtr,System.Type)">
            <summary>This will return the wrapper for the  wxWidgets <c>wxClassInfo</c> <c>cptr</c>. or create one if necessary.</summary>
        </member>
        <member name="M:WX.Object.ClassInfo.FindWxObject(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxObject</c>.
            Please note, that not all  wxWidgets classes inerit from <c>wxObject</c>.
            </summary>
        </member>
        <member name="M:WX.Object.ClassInfo.FindWxGridCellEditor(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxGridCellEditor</c>.
            </summary>
        </member>
        <member name="M:WX.Object.ClassInfo.FindWxGridCellRenderer(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxGridCellRenderer</c>.
            </summary>
        </member>
        <member name="M:WX.Object.ClassInfo.Find(System.IntPtr,System.IntPtr)">
            <summary>Internal helper that finds a class info for <c>nativeInstance</c> provided that <c>classInfo</c> is a pointer to the <c>wxWidgets</c> class info.
            </summary>
        </member>
        <member name="P:WX.Object.ClassInfo.BaseClass1">
            <summary>First base class or <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Object.ClassInfo.BaseClass2">
            <summary>Second base class or <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Object.ClassInfo.Size">
            <summary>The size of the native object.</summary>
        </member>
        <member name="P:WX.Object.ClassInfo.wxNetType">
            <summary>This is the  WX.Net wrapper class.</summary>
        </member>
        <member name="T:WX.Object.StorageMode">
            <summary>Use constants of this kind to tell the CTor whether to hold the newly created object into the static container of instances or not.</summary>
        </member>
        <member name="F:WX.Object.StorageMode.RegisteredObject">
            <summary>
            The object will be registered in the global dictionary of WX.Net wrappers. Thus, instances have to be disposed
            explicitely, sincce these wrappers will always have a GC support (by the reference in the globale dictionary).
            However, you must use this mode if WX.Net might try to create more than one wrapper of the instance because e.g.
            this instance may result from many different calls to native functions. Please note: Ensure that there is at most one wrapepr for a native C++ instance.
            </summary>
        </member>
        <member name="F:WX.Object.StorageMode.VolatileObject">
            <summary>
            Objects of this kind will not be registered in the global database. Use this mode to create wrappers of instances
            that will be created especially for this wrapper. Avoid this mode if WX.Net might try to create annother wrapper for the
            same instance. Please note: Ensure that there is at most one wrapepr for a native C++ instance.
            </summary>
        </member>
        <member name="F:WX.Event.wxEVT_CALENDAR_SEL_CHANGED">
            \name Calendar Control Events 
        </member>
        <member name="F:WX.Event.wxEVT_COMMAND_FIND">
            \name Search Dialog Events 
        </member>
        <member name="F:WX.Event.wxEVT_COMMAND_TREE_BEGIN_DRAG">
            \name Tree List Events 
        </member>
        <member name="F:WX.Event.wxEVT_COMMAND_LIST_BEGIN_DRAG">
            \name List Control Events 
        </member>
        <member name="F:WX.Event.wxEVT_COMMAND_NOTEBOOK_PAGE_CHANGED">
            \name Note Book Events 
        </member>
        <member name="F:WX.Event.wxEVT_COMMAND_LISTBOOK_PAGE_CHANGED">
            \name List Book Events 
        </member>
        <member name="F:WX.Event.wxEVT_GRID_CELL_LEFT_CLICK">
            \name Grid Events 
        </member>
        <member name="F:WX.Event.wxEVT_LOAD_HTML_PAGE">
            This is a new event type which is used in wx.HtmlWindow for deferred loading of HTML pages. 
        </member>
        <member name="F:WX.Event.wxEVT_TASKBAR_MOVE">
            \name wx.TaskBarIcon events impementation 
        </member>
        <member name="F:WX.Event.wxEVT_WIZARD_CANCEL">
            \name wx.Wizard Events 
        </member>
        <member name="F:WX.Event.wxEVT_HTML_CELL_CLICKED">
            \name HTML Help Events 
        </member>
        <member name="M:WX.Event.#cctor">
            <summary> This initializes the event types.</summary> 
        </member>
        <member name="M:WX.Event.AddEventType(System.Int32,System.Type)">
            <summary>
            Use this to declare a new custom event class. You may use CreateNewEventId()
            to define the event ID. Provide a class for <c>type</c> that implements wx.Event.
            </summary>
            <param name="evt">The ID of the new event.</param>
            <param name="type">The class implementing the new event. This shall be assignable to wx.Event. This class 
            also MUST implement a public CTor accepting an IntPtr to a c++ instance of <c>wxEvent</c>.</param>
            <seealso cref="!:wx.EvtHandler.AddEventListener"/>
        </member>
        <member name="M:WX.Event.CreateNewEventId">
            <summary>
            Creates a new, yet unused ID for a custom event class.
            </summary>
            <see cref="M:WX.Event.AddEventType(System.Int32,System.Type)"/>
            <seealso cref="!:wx.EvtHandler.AddEventListener"/>
            <returns></returns>
        </member>
        <member name="M:WX.Event.AddEventType(System.Type)">
            <summary>
            Creates a new custom event of the provided type. This event will have a new unique ID that will
            be created automatically. The result of this method will return this new ID.
            </summary>
            <param name="type">The class implementing the new event. This shall be assignable to wx.Event. This class 
            also MUST implement a public CTor accepting an IntPtr to a c++ instance of <c>wxEvent</c>.</param>
            <seealso cref="!:wx.EvtHandler.AddEventListener"/>
            <seealso cref="M:WX.Event.CreateNewEventId"/>
        </member>
        <member name="M:WX.Event.Skip">
            <summary>Equivalent to <c>Skipt(true)</c>.
            This tells the chain of event handlers to search for additional handlers of this
            event.</summary>
        </member>
        <member name="M:WX.Event.Skip(System.Boolean)">
            <summary>This method can be used inside an event handler to control whether further event handlers bound to this event will be called after the current one returns.
            Without Skip() (or equivalently if Skip(false) is used), the event will
            not be processed any more. If <c>Skip(true)</c> is called, the event processing
            system continues searching for a further handler function for this event, even
            though it has been processed already in the current handler.
            </summary>
            <remarks>
            In general, it is recommended to skip all non-command events to allow the
            default handling to take place. The command events are, however, normally not
            skipped as usually a single command such as a button click or menu item
            selection must only be processed by one handler.
            </remarks>
            <param name="skip">Indicates with TRUE, that wxWidgets shall proceed searchign for a handler of the event.
            With FALSE (default behaviour of the event system), this method indicates that the event has been processed.
            </param>
        </member>
        <member name="P:WX.Event.EventType">
            <summary>
            Type identifier of the event. Usually not used by applications because
            you have the opportunity to handle each event type independently.
            Example content: wx.Event.wxEVT_SCROLLWIN_TOP.
            </summary>
        </member>
        <member name="P:WX.Event.Skipped">
            <summary>
            TRUE iff this has been skipped (shall not be handled by another handler).
            </summary>
        </member>
        <member name="T:WX.Dialog">
            <summary>
            A dialog box is a window with a title bar and sometimes a system menu, which can be moved around the screen. It can
            contain controls and other windows and is often used to allow the user to make some choice or to answer a question.
            
            Dialog Buttons:
            
            The dialog usually contains either a single button allowing to close the dialog or two buttons, one accepting the
            changes and the other one discarding them (such button, if present, is automatically activated if the user presses
            the "Esc" key). By default, buttons with the standard MenuIDs.Ok and MenuIDs.CANCEL identifiers behave as expected.
            Starting with wxWidgets 2.7 it is also possible to use a button with a different identifier instead, see
            SetAffirmativeId() and SetEscapeId().
            
            Also notice that the CreateButtonSizer() should be used to create the buttons appropriate for the current platform
            and positioned correctly (including their order which is platform-dependent).
            </summary>
        </member>
        <member name="T:WX.Window">
            <summary>Window is the base class for all windows and represents any visible object on screen.
             All controls, top level windows and so on are windows. Sizers and device contexts are not,
             however, as they don't appear on screen themselves.
             Please note that all children of the window will be deleted automatically by
             the destructor before the window itself is deleted which means that you
             don't have to worry about deleting them manually.
            </summary>
        </member>
        <member name="T:WX.EvtHandler">
            <summary>Interface to the event handler.
            Main methods: wx.EvtHandler.AddCommandListener() and wx.EvtHandler.AddEventListener().
            </summary>
            
        </member>
        <member name="M:WX.EvtHandler.AddCommandListener(System.Int32,System.Int32,WX.EventListener,System.Object)">
            <summary> Use this form of adding a listener for a command event if the owner, who implements \c listener, might be accidentally disposed by the garbage collection.</summary>
        </member>
        <member name="M:WX.EvtHandler.RemoveListener(WX.EventListener)">
            <summary>This will remove event listener <c>listenerToRemove</c> from the list of event listeners.</summary>
        </member>
        <member name="M:WX.EvtHandler.AddCommandRangeListener(System.Int32,System.Int32,System.Int32,WX.EventListener,System.Object)">
            <summary>Use this form of adding a listener for a command event if the owner, who implements <c>listener</c>, might be accidentally disposed by the garbage collection.</summary>
        </member>
        <member name="M:WX.EvtHandler.AddEventListener(System.Int32,WX.EventListener)">
            <summary>
            Installs a new event listener listening to the event of the provided type.
            Use this method if this handler implements the listener. To add listeners
            here that are provided by other classes, use the form of this method that
            additionally accepts an owner.
            </summary>
            <param name="eventType">The event type that will be handled by this listener.
            This might have been created by wx.Event.AddEventType</param>
            <param name="listener">The delegate that actually handles this event.</param>
            <seealso cref="!:wx.Event.AddEventType"/>
        </member>
        <member name="M:WX.EvtHandler.AddEventListener(System.Int32,WX.EventListener,System.Object)">
            <summary>Use this form of adding a listener for a command event if the owner,
            that implements <c>listener</c>, might be accidentally disposed by the garbage collection.
            </summary>
            <param name="eventType">The event type that will be handled by this listener.
            This might have been created by wx.Event.AddEventType</param>
            <param name="listener">The delegate that actually handles this event.</param>
            <seealso cref="!:wx.Event.AddEventType"/>
        </member>
        <member name="M:WX.EvtHandler.ProcessEvent(WX.Event)">
            <summary>
            Thsi will process the event passed to the argument list.
            </summary>
            <param name="evt">The event to be processed.</param>
            <returns></returns>
        </member>
        <member name="M:WX.EvtHandler.AddPendingEvent(WX.Event)">
             <summary>
             This function posts an event to be processed later.
             </summary>
             <param name="evt">Event to add to process queue.</param>
             <remarks>
             The difference between sending an event (using the ProcessEvent method) and posting it is that in the first
             case the event is processed before the function returns, while in the second case, the function returns
             immediately and the event will be processed sometime later (usually during the next event loop iteration).
            
             A copy of event is made by the function, so the original can be deleted as soon as function returns (it is common
             that the original is created on the stack). This requires that the wxEvent::Clone method be implemented by event
             so that it can be duplicated and stored until it gets processed.
            
             This is also the method to call for inter-thread communication---it will post events safely between different
             threads which means that this method is thread-safe by using critical sections where needed. In a multi-threaded 
             program, you often need to inform the main GUI thread about the status of other working threads and such
             notification should be done using this method.
            
             This method automatically wakes up idle handling if the underlying window system is currently idle and thus
             would not send any idle events. (Waking up idle handling is done calling wxApp.WakeUpIdle().)
             </remarks>
        </member>
        <member name="M:WX.EvtHandler.MarshalEvent(System.IntPtr,System.Int32)">
            
            <summary>
            All listened-for events are received here. The event code is
            mapped to an actual Event type, and then the listener EventListener lnsertion is called.
            </summary>
            <param name="wxEvent">Ptr to C++ event</param>
            <param name="iListener">Designator of the event listener</param>	
        </member>
        <member name="M:WX.EvtHandler.RunErrorHandler(System.Exception)">
            <summary>
            Runs the defined error handlers to display the error as given by the argument.
            This will run the default error handler if not skipped by one of the handlers
            of the error event.
            </summary>
            <param name="exc">The error to be displayed.</param>
        </member>
        <member name="M:WX.EvtHandler.RunDefaultErrorHandler(System.Exception)">
            <summary>
            Runs the default error handler. This will raise a message box.
            </summary>
            <param name="exc"></param>
        </member>
        <member name="M:WX.EvtHandler.OnObjectDeleted(System.Object,WX.Event)">
            <summary>This handler is called whenever an object's associated C++ instance
            is deleted, so that any C# references can be cleaned up.</summary>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_MOVE(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_LEFT_DOWN(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_LEFT_UP(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_RIGHT_DOWN(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_RIGHT_UP(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_LEFT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_RIGHT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TASKBAR_CLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SIZE(WX.EventListener)">
             <summary>
             A size event holds information about size change events.
            
             The EVT_SIZE handler function will be called when the window has been resized.
            
             You may wish to use this for frames to resize their child windows as appropriate.
            
             Note that the size passed is of the whole window: call wx.Window.GetClientSize for the area which may be used
             by the application.
            
             When a window is resized, usually only a small part of the window is damaged and you may only need to
             repaint that area. However, if your drawing depends on the size of the window, you may need to clear
             the DC explicitly and repaint the whole window. In which case, you may need to call wx.Window.Refresh to
             invalidate the entire window.
             </summary>
             <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CLOSE(WX.EventListener)">
            <summary>
            This will handle wx.CloseEvent. The event handler may veto the closing of the application
            if <c>CanVeto</c> is true.
            Please do not forget to skip the event. Otherwise, the application may not be able to close
            down.
            </summary>
            <param name="lsnr">Event listener. This will provide the handler of the event.
            Please do not forget to skip the event in order to proceed with the closing section.</param>
            <see cref="T:WX.CloseEvent"/>
        </member>
        <member name="M:WX.EvtHandler.EVT_PAINT(WX.EventListener)">
             <summary>A paint event is sent when a window's contents needs to be repainted.
            
             Please notice that in general it is impossible to change the drawing of a standard control
             (such as wx.Button) and so you shouldn't attempt to handle paint events for them as even if it might
             work on some platforms, this is inherently not portable and won't work everywhere.
             </summary>
             <param name="lsnr">Event listener.</param>
             <remarks>
             Note that In a paint event handler, the application must always create a wx.PaintDC object, even if
             you do not use it. Otherwise, under MS Windows, refreshing for this and other windows will go wrong.
             
             For example:
             
             <code>
               void MyWindow
               {
                   public MyWindow(...)
                   {
                     ...
                     this.EVT_PAINT(new EventListener(OnPaint));
                     ...
                   }
                   
                   void OnPaint(object sender, wx.PaintEvent event)
                   {
                     using (wx.PaintDC dc = new wx.PaintDC(this))
                     {
                         DrawMyDocument(dc);
                     }
                   }
               }
             </code>
             
             You can optimize painting by retrieving the rectangles that have been damaged and only repainting these. The rectangles are in terms of the client area, and are unscrolled, so you will need to do some calculations using the current view position to obtain logical, scrolled units.
             </remarks>
        </member>
        <member name="M:WX.EvtHandler.EVT_ERASE_BACKGROUND(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_IDLE(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MOVE(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TIMER(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SOCKET(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_KILL_FOCUS(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SET_FOCUS(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MOUSE_EVENTS(WX.EventListener)">
            <summary>
            Installs a handler for all mouse events, i.e. EVT_ENTER_WINDOW().
            EVT_LEAVE_WINDOW(), EVT_LEFT_DOWN(), EVT_RIGHT_DOWN(), EVT_MIDDLE_DOWN(),
            EVT_LEFT_DCLICK(), EVT_RIGHT_DCLICK(), EVT_MIDDLE_DCLICK(), EVT_MOTION(),
            EVT_LEFT_UP(), EVT_RIGHT_UP(), EVT_MIDDLE_UP().
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_ENTER_WINDOW(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LEAVE_WINDOW(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LEFT_DOWN(WX.EventListener)">
            <summary>
            Raised if user is pressing left mouse button down.
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_RIGHT_DOWN(WX.EventListener)">
            <summary>
            Raised if user is pressing right mouse button down.
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MIDDLE_DOWN(WX.EventListener)">
            <summary>
            Raised if user is pressing middle mouse button down.
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LEFT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_RIGHT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MIDDLE_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MOTION(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LEFT_UP(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_RIGHT_UP(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MIDDLE_UP(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_UPDATE_UI(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EvtMenu(System.Object,WX.EventListener)">
            <summary><c>id</c> will be converted to <c>int</c>.
            </summary>
        </member>
        <member name="M:WX.EvtHandler.EVT_MENU(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_BUTTON(System.Object,WX.EventListener)">
            <summary>Adds a command listener of type Event.wxEVT_COMMAND_BUTTON_CLICKED.
            This version of the method is appropriate to deal with enumeration constants
            as ID.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_BUTTON(System.Int32,WX.EventListener)">
            <summary>Adds a command listener of type Event.wxEVT_COMMAND_BUTTON_CLICKED.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CHECKBOX(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LISTBOX(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LISTBOX_DCLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CHOICE(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_COMBOBOX(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TEXT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TEXT_ENTER(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_RADIOBOX(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_RADIOBUTTON(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SLIDER(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SPINCTRL(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SPIN_UP(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SPIN_DOWN(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SPIN(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TOGGLEBUTTON(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_KEY_DOWN(WX.EventListener)">
            <summary>
            Adds a listener to the event of pressing a key down.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_KEY_UP(WX.EventListener)">
            <summary>
            Adds a listener to the event on releasing an event.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CHAR(WX.EventListener)">
            <summary>
            Adds a listener to character events.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_DATE_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_COLOURPICKER_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FONTPICKER_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_SEL_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_DAY(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_MONTH(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_YEAR(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_DOUBLECLICKED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALENDAR_WEEKDAY_CLICKED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND(WX.EventListener)">
            \name Search Dialog Events 
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND_NEXT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND_REPLACE(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND_REPLACE_ALL(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_FIND_CLOSE(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EvtTreeBeginDrag(System.Int32,WX.EventListener)">
            <summary>
            The user has started dragging an item with the left mouse button.
            The event handler must call wx.TreeEvent.Allow() for the drag operation to continue. 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_BEGIN_RDRAG(System.Int32,WX.EventListener)">
            <summary>
            The user has started dragging an item with the right mouse button.
            The event handler must call wx.TreeEvent.Allow() for the drag operation to continue.  
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_BEGIN_LABEL_EDIT(System.Int32,WX.EventListener)">
            <summary>
            Begin editing a label. This can be prevented by calling Veto(). 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_END_LABEL_EDIT(System.Int32,WX.EventListener)">
            <summary>
            The user has finished editing a label. This can be prevented by calling Veto(). 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_DELETE_ITEM(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_GET_INFO(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_SET_INFO(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_EXPANDED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_EXPANDING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_COLLAPSED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_COLLAPSING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EvtTreeSelChanged(System.Int32,WX.EventListener)">
            <summary>
            Event will be fired after selecting a node in a wx.TreeCtrl.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_SEL_CHANGING(System.Int32,WX.EventListener)">
            <summary>
            Event will be fired on selecting a node in a wx.TreeCtrl.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_KEY_DOWN(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_ACTIVATED(System.Int32,WX.EventListener)">
            <summary>The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard .
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EvtTreeItemRightClick(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_ITEM_MIDDLE_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_TREE_END_DRAG(System.Int32,WX.EventListener)">
            <summary>
            The user has released the mouse after dragging an item. 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_BEGIN_DRAG(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_BEGIN_RDRAG(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_BEGIN_LABEL_EDIT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_END_LABEL_EDIT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_DELETE_ITEM(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_DELETE_ALL_ITEMS(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_SELECTED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_DESELECTED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_ACTIVATED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_FOCUSED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_MIDDLE_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_ITEM_RIGHT_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_KEY_DOWN(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_INSERT_ITEM(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_COL_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_COL_RIGHT_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_COL_BEGIN_DRAG(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_COL_DRAGGING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_COL_END_DRAG(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LIST_CACHE_HINT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_NOTEBOOK_PAGE_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_NOTEBOOK_PAGE_CHANGING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LISTBOOK_PAGE_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_LISTBOOK_PAGE_CHANGING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_BOTTOM(WX.EventListener)">
            <summary>
            Scroll to bottom.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_LINEDOWN(WX.EventListener)">
            <summary>
            Scroll a line down.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_LINEUP(WX.EventListener)">
            <summary>
            Scroll a line up.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_PAGEDOWN(WX.EventListener)">
            <summary>
            Scroll a page down.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_PAGEUP(WX.EventListener)">
            <summary>
            Scroll a page up.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_THUMBRELEASE(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_THUMBTRACK(WX.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN_TOP(WX.EventListener)">
            <summary>
            Scroll to top.
            </summary>
            <param name="lsnr">The event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SCROLLWIN(WX.EventListener)">
            <summary>
            Registers a handler for all events on scrolling an instance
            of wx.Window.
            </summary>
            <param name="lsnr">the event handler.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_CELL_LEFT_CLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_CELL_RIGHT_CLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_CELL_LEFT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_CELL_RIGHT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_LABEL_LEFT_CLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_LABEL_RIGHT_CLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_LABEL_LEFT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_LABEL_RIGHT_DCLICK(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_ROW_SIZE(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_COL_SIZE(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_RANGE_SELECT(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_CELL_CHANGE(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_SELECT_CELL(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_EDITOR_SHOWN(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_EDITOR_HIDDEN(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_GRID_EDITOR_CREATED(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_ACTIVATE(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_DISPLAY_CHANGED(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SASH_DRAGGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SASH_DRAGGED_RANGE(System.Int32,System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_QUERY_LAYOUT_INFO(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CALCULATE_LAYOUT(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CHECKLISTBOX(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_CONTEXT_MENU(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SYS_COLOUR_CHANGED(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_QUERY_NEW_PALETTE(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_PALETTE_CHANGED(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_INIT_DIALOG(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_SIZING(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_MOVING(WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_HELP(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_DETAILED_HELP(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_CHANGE(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_STYLENEEDED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_CHARADDED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_SAVEPOINTREACHED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_SAVEPOINTLEFT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_ROMODIFYATTEMPT(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_KEY(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_DOUBLECLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_UPDATEUI(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_MODIFIED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_MACRORECORD(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_MARGINCLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_NEEDSHOWN(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_PAINTED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_USERLISTSELECTION(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_URIDROPPED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_DWELLSTART(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_DWELLEND(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_START_DRAG(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_DRAG_OVER(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_DO_DROP(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_ZOOM(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_HOTSPOT_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_HOTSPOT_DCLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_STC_CALLTIP_CLICK(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_WIZARD_CANCEL(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_WIZARD_FINISHED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_WIZARD_HELP(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_WIZARD_PAGE_CHANGED(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_WIZARD_PAGE_CHANGING(System.Int32,WX.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_HTML_CELL_CLICKED(System.Int32,WX.EventListener)">
            <summary>User clicked on a wx.Html.HtmlCell.
            The event will be of type wx.Html.HtmlCellEvent.
            </summary>
            <remarks>
            When handling this event, remember to assign <c>true</c> to
            <c>wx.Html.HtmlCellEvent.LinkClicked</c>
            if the cell contains a link.
            </remarks>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_HTML_CELL_HOVER(System.Int32,WX.EventListener)">
            <summary>Declares a handler for a wx.Html.HtmlCellEvent that
            will be raised if the user moved the mouse over a wx.Html.HtmlCell.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EvtHtmlLinkClicked(System.Int32,WX.EventListener)">
            <summary>Declares a handler for a wx.Html.HtmlLinkEvent that
            will be raised if the user clicked a hyper link.
            </summary>
            <remarks>This event will be raised if wx.Html.HtmlWindow.OnLinkClicked()
            is called (the default implementation). The HTML window will only use the
            default implementation of this method - that actually loads a HTML page - if
            this event has not been handled or the handler skipped the event.</remarks>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:WX.EvtHandler.EVT_DESTROY(WX.EventListener)">
            <summary>
            Adds a handler that will be started if this window is going to be destroyed.
            </summary>
            <param name="lsnr">The handler that will be started on the event.</param>
        </member>
        <member name="E:WX.EvtHandler.OnError">
            <summary>
            This event will be raised if this event handler encounters an exception executing an event.
            Each of the handlers of an error may skip the default handler that will raise a message box
            showing the message of the exception.
            If this event handler does not know a handler for this event or non of the handlers skips
            the default handler, the default action on errors will be initiated by this handler:
            This will raise a message box showing the message on the exception.
            </summary>
        </member>
        <member name="F:WX.Window.WxAnyId">
            <summary>
            Constant representing an unknown or unspecified window ID.
            </summary>
        </member>
        <member name="F:WX.Window.WxDefaultPosition">
            <summary>Default position.
            Use this when you are allowed to provide a position
            but you do not want to provide a particular position.
            </summary>
        </member>
        <member name="F:WX.Window.WxDefaultSize">
            <summary>Default size.
            Use this when you are allowed to provide a size
            but you do not want to specify a particular size.</summary>
        </member>
        <member name="F:WX.Window.WxDefaultCoord">
            <summary>Default coordinate.
            Use this when you are allowed to provide a coordinate
            but you do not want to provide information on a particular coordinate.</summary>
        </member>
        <member name="F:WX.Window.ClientData">
            <summary>
            In addition to the client data concept in wxWidgets, WX.Net offers you the 
            option to tag each window with client data. The motivation for this: When
            you deal with events, you usually know the sender. You may use the client data
            to attach data to the sender that is required to deal with the event. For instance,
            you may have a button that shall have an effect on a particular widget. You may
            ease implementation of such a solution assigning the widget to the button's
            client data. Thus, the event handler may retrieve the widgets that is required
            to implement the action directly from the control that caused the action.
            </summary>
        </member>
        <member name="M:WX.Window.#ctor(WX.Window)">
            <summary>
            Creates a window.
            </summary>
            <param name="parent">The parent window.</param>
        </member>
        <member name="M:WX.Window.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>
            Creates a window.
            </summary>
            <param name="parent">The parent window.</param>
            <param name="id">A numeric identifier of the window that can be used to search for particular
            subwindows. Use -1 if undefined.</param>
            <param name="name">A string identifier of the window.</param>
            <param name="pos">The upper left position of the window.</param>
            <param name="size">The size of the window.</param>
            <param name="style">The style of the window.</param>
        </member>
        <member name="M:WX.Window.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,WX.wxString)">
            <summary>
            Creates a window.
            </summary>
            <param name="parent">The parent window.</param>
            <param name="id">A numeric identifier of the window that can be used to search for particular
            subwindows. Use -1 if undefined.</param>
            <param name="pos">The upper left position of the window.</param>
            <param name="size">The size of the window.</param>
            <param name="style">The style of the window.</param>
        </member>
        <member name="M:WX.Window.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>
            Creates a window.
            </summary>
            <param name="parent">The parent window.</param>
            <param name="name">A string identifier of the window.</param>
            <param name="pos">The upper left position of the window.</param>
            <param name="size">The size of the window.</param>
            <param name="style">The style of the window.</param>
        </member>
        <member name="M:WX.Window.Dispose(System.Boolean)">
            <summary>Overriden disposition.
            Even if we do not own the memory, we have to delete the window, since this
            is apparently intended by the user calling this method.</summary>
        </member>
        <member name="M:WX.Window.SetOwnBackgroundColour(WX.Colour)">
            <summary>
            Sets the background colour of the window but prevents it from being inherited by the children of this window.
            </summary>
            <param name="colour"></param>
        </member>
        <member name="M:WX.Window.SetOwnForegroundColour(WX.Colour)">
            <summary>
            Sets the foreground colour of the window but prevents it from being inherited by the children of this window.
            </summary>
            <param name="colour"></param>
        </member>
        <member name="M:WX.Window.SetOwnFont(WX.Font)">
            <summary>
            Sets the font of the window but prevents it from being inherited by the children of this window.
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:WX.Window.Close">
            <summary>This function simply generates a wxCloseEvent whose handler usually tries to close the window.
             It doesn't close the window itself, however.
            
             Close calls the close handler for the window, providing an opportunity for the window to choose whether to destroy
             the window. Usually it is only used with the top level windows (wx.Frame and wx.Dialog classes) as the others are
             not supposed to have any special <c>OnClose()</c> logic.
            
             The close handler should check whether the window is being deleted forcibly, using wx.CloseEvent.CanVeto, in which
             case it should destroy the window using wx.Window.Destroy().
            
             Note that calling <c>Close()</c> does not guarantee that the window will be destroyed; but it provides a way to simulate a manual
             close of a window, which may or may not be implemented by destroying the window. The default implementation of
             <c>wx.Dialog.OnCloseWindow()</c> does not necessarily delete the dialog, since it will simply simulate an <c>CANCEL</c> event
             which is handled by the appropriate button event handler and may do anything at all.
            
             To guarantee that the window will be destroyed, call wx.Window.Destroy instead.</summary>
        </member>
        <member name="M:WX.Window.Close(System.Boolean)">
            <summary>This will create a <c>wx.CloseEvent</c> but handlers are not allowed to veto if <c>force</c> is <c>true</c>.
            Try wx.Utils.Exit() if you want the application to be exited. Otherwise, the application will exit
            automatically, if all top level windows are closed.
            
            Refer also to Close().</summary>
        </member>
        <member name="M:WX.Window.GetUniqueID">
            <summary>This always returns a unique ID that is appropriate to denote windows.</summary>
        </member>
        <member name="M:WX.Window.Show">
            <summary>Shows or hides the window.
            You may need to call Raise() for a top level window if you want to bring it to top, although this
            is not needed if Show() is called immediately after the frame creation.
            </summary>
            <returns>true if the window has been shown or hidden or false if nothing was done because
            it already was in the requested state.</returns>
            <seealso cref="P:WX.Window.IsShown"/>
            <seealso cref="M:WX.Window.Hide"/>
            <seealso cref="M:WX.Window.Raise"/>
        </member>
        <member name="M:WX.Window.Show(System.Boolean)">
            <summary>Shows or hides the window.
            You may need to call Raise() for a top level window if you want to bring it to top, although this
            is not needed if Show() is called immediately after the frame creation.
            </summary>
            <param name="show">If true displays the window. Otherwise, hides it.</param>
            <returns>true if the window has been shown or hidden or false if nothing was done because
            it already was in the requested state.</returns>
            <seealso cref="P:WX.Window.IsShown"/>
            <seealso cref="M:WX.Window.Hide"/>
            <seealso cref="M:WX.Window.Raise"/>
        </member>
        <member name="M:WX.Window.IsEnabled">
            <summary>Returns true iff enabled.</summary>
        </member>
        <member name="M:WX.Window.ToString">
            <summary>
            String presenting type, name, and ID.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Window.OnDestroy(System.Object,WX.Event)">
            <summary>
            This will be called if this window is going to be destroyed.
            </summary>
            <param name="sender"></param>
            <param name="evt"></param>
        </member>
        <member name="M:WX.Window.Destroy">
            <summary>Destroy the window.
            Call this only is you do not want to show it again.</summary>
        </member>
        <member name="M:WX.Window.DestroyChildren">
            <summary>Destroy the window's children.
            Call this only is you do not want to show them again.</summary>
        </member>
        <member name="M:WX.Window.NewControlId">
            <summary>Generate a control id for the controls which were not given one by
            user.
            
             WX.Net provides property wx.Window.GetUniqueID() to generate uniqe IDs
            which are appropriate to designate windows.</summary>
        </member>
        <member name="M:WX.Window.NextControlId(System.Int32)">
            <summary>Get the id of the control following the one with the given
            (autogenerated) id.</summary>
        </member>
        <member name="M:WX.Window.PrevControlId(System.Int32)">
            <summary>Get the id of the control preceding the one with the given
            (autogenerated) id</summary>
        </member>
        <member name="M:WX.Window.Raise">
            <summary>Raises the window to the top of the window hierarchy (z-order).
            In current version of wxWidgets this works both for managed and child windows.
             </summary>
             <seealso cref="M:WX.Window.Lower"/>
        </member>
        <member name="M:WX.Window.Lower">
            <summary>
            Lowers the window to the bottom of the window hierarchy (z-order).
            </summary>
            <seealso cref="M:WX.Window.Raise"/>
        </member>
        <member name="M:WX.Window.CentreOnParent">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
        </member>
        <member name="M:WX.Window.CenterOnParent">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
        </member>
        <member name="M:WX.Window.CentreOnParent(WX.Orientation)">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
            <param name="direction">Specifies the direction for the centering. May be Orientation.wxHORIZONTAL,
            Orientation.wxVERTICAL or Orientation.wxBOTH.
            </param>
        </member>
        <member name="M:WX.Window.CenterOnParent(WX.Orientation)">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
            <param name="direction">Specifies the direction for the centering. May be Orientation.wxHORIZONTAL,
            Orientation.wxVERTICAL or Orientation.wxBOTH.
            </param>
        </member>
        <member name="M:WX.Window.Fit">
            <summary>
            Sizes the window so that it fits around its subwindows. This function won't do anything if there
            are no subwindows and will only really work correctly if the sizers are used for the subwindows layout.
            </summary>
            <remarks>
            Also, if the window has exactly one subwindow it is better (faster and the result is more precise as
            Fit() adds some margin to account for fuzziness of its calculations) to call
            <code>
             window->SetClientSize(child->GetSize());
            </code>
            instead of calling Fit.
            </remarks>
        </member>
        <member name="M:WX.Window.FitInside">
            <summary>
            Similar to Fit, but sizes the interior (virtual) size of a window.
            Mainly useful with scrolled windows to reset scrollbars after sizing changes that do not trigger
            a size event, and/or scrolled windows without an interior sizer.
            This function similarly won't do anything if there are no subwindows.
            </summary>
        </member>
        <member name="M:WX.Window.SetSizeHints(System.Drawing.Size)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
            <param name="minimalSize">Minimal size of the dialog or frame that will be propagated to the size of the children.</param>
        </member>
        <member name="M:WX.Window.SetSizeHints(System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
            <param name="minW">Minimal width of the dialog or frame that will be propagated to the size of the children.</param>
            <param name="minH">Minimal width of the dialog or frame that will be propagated to the size of the children.</param>
        </member>
        <member name="M:WX.Window.SetSizeHints(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
        </member>
        <member name="M:WX.Window.SetSizeHints(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
        </member>
        <member name="M:WX.Window.HasFlag(WX.WindowStyles)">
            <summary>True if the designated style flag has been set for this window.</summary>
        </member>
        <member name="M:WX.Window.SetFocus">
            <summary>This sets the window to receive keyboard input.
            Please note, that this method cannot be overridden from any class.
            Currently, inheritors of <c>wx.Panel</c> and <c>wx.Dialog</c> can override this.</summary>
        </member>
        <member name="M:WX.Window.SetFocusFromKbd">
            <summary>This function is called by  wxWidgets keyboard navigation code
            when the user gives the focus to this window from keyboard (e.g. using TAB key).
            By default this method simply calls <c>SetFocus</c> but can be overridden to do something in addition
            to this in the derived classes.
            Please note, that this method cannot be overridden from any class.
            Currently, inheritors of <c>wx.Panel</c> and <c>wx.Dialog</c> can override this.</summary>
        </member>
        <member name="M:WX.Window.FindFocus">
            <summary>
            Finds the window or control which currently has the keyboard focus.
            
            Note that this is a static function, so it can be called without needing a wx.Window pointer.
            </summary>
        </member>
        <member name="M:WX.Window.AcceptsFocus">
            <summary>
            can this window have focus?
            </summary>
        </member>
        <member name="M:WX.Window.AcceptsFocusFromKeyboard">
            <summary>
            can this window be given focus by keyboard navigation? if not, the
            only way to give it focus (provided it accepts it at all) is to
            click it
            </summary>
        </member>
        <member name="M:WX.Window.FindWindow(System.Int32)">
            <summary>This will find the window of the provided <c>id</c>.
            The result will be <c>null</c> if no such window exists.
            </summary>
        </member>
        <member name="M:WX.Window.FindWindow(System.Int32,System.Type)">
            <summary>This will find the window of the provided <c>id</c> and or create one of class <c>type</c>.
            </summary>
        </member>
        <member name="M:WX.Window.FindWindowById(System.Int32,WX.Window)">
             <summary>
             Find the first window with the given id.
            
             If parent is <c>null</c>, the search will start from all top-level 
             frames and dialog boxes; if non-null, the search will be
             limited to the given window hierarchy. The search is recursive 
             in both cases.
             </summary>
             <param name="id">The number identifying the searched window.</param>
             <param name="parent">If not <c>null</c>, this method will only search
             this window and its children.</param>
             <returns></returns>
        </member>
        <member name="M:WX.Window.FindWindowByName(System.String,WX.Window)">
             <summary>
             Find a window by its name (as given in a window constructor or <c>Create</c> function call).
             If parent is NULL, the search will start from all top-level frames
             and dialog boxes; if non-NULL, the search will be limited to the
             given window hierarchy. The search is recursive in both cases.
            
             If no window with such name is found, <c>FindWindowByLabel</c> is called.
             </summary>
             <param name="name">The window name that this method will search for.</param>
             <param name="parent">If not <c>null</c>, this method will only search
             this window and its children.</param>
             <returns></returns>
             <seealso cref="M:WX.Window.FindWindowByLabel(System.String,WX.Window)"/>
        </member>
        <member name="M:WX.Window.FindWindowByName(WX.wxString,WX.Window)">
             <summary>
             Find a window by its name (as given in a window constructor or <c>Create</c> function call).
             If parent is NULL, the search will start from all top-level frames
             and dialog boxes; if non-NULL, the search will be limited to the
             given window hierarchy. The search is recursive in both cases.
            
             If no window with such name is found, <c>FindWindowByLabel</c> is called.
             </summary>
             <param name="name">The window name that this method will search for.</param>
             <param name="parent">If not <c>null</c>, this method will only search
             this window and its children.</param>
             <returns></returns>
             <seealso cref="M:WX.Window.FindWindowByLabel(System.String,WX.Window)"/>
        </member>
        <member name="M:WX.Window.FindWindowByLabel(System.String,WX.Window)">
            <summary>
            Find a window by its label.
            Depending on the type of window, the label may be a window title
            or panel item label. If parent is <c>null</c>, the search will start
            from all top-level frames and dialog boxes; if non-NULL, the
            search will be limited to the given window hierarchy.
            The search is recursive in both cases.
            </summary>
            <param name="label">The window label that this method will search for.</param>
            <param name="parent">If not <c>null</c>, this method will only search
            this window and its children.</param>
        </member>
        <member name="M:WX.Window.FindWindowByLabel(WX.wxString,WX.Window)">
            <summary>
            Find a window by its label.
            Depending on the type of window, the label may be a window title
            or panel item label. If parent is <c>null</c>, the search will start
            from all top-level frames and dialog boxes; if non-NULL, the
            search will be limited to the given window hierarchy.
            The search is recursive in both cases.
            </summary>
            <param name="label">The window label that this method will search for.</param>
            <param name="parent">If not <c>null</c>, this method will only search
            this window and its children.</param>
        </member>
        <member name="M:WX.Window.PushEventHandler(WX.EvtHandler)">
            <summary>Pushes this event handler onto the event stack for the window.
                      * \param handler Specifies the handler to be pushed.
                      * An event handler is an object that is capable of processing the events sent to a window.
                     * By default, the window is its own event handler, but an application may wish to substitute another, 
                     * for example to allow central implementation of event-handling for a variety of different window classes.
                     *
                     * wx.Window.PushEventHandler allows an application to set up a chain of event handlers, where an event not
                     * handled by one event handler is handed to the next one in the chain. Use wx.Window.PopEventHandler to remove
                     * the event handler.</summary>
        </member>
        <member name="M:WX.Window.PopEventHandler(System.Boolean)">
            <summary>cf. PushEventHandler().</summary>
        </member>
        <member name="M:WX.Window.CaptureMouse">
             <summary>
             Directs all mouse input to this window. Call wxWindow::ReleaseMouse to release the capture.
            
             Note that wxWidgets maintains the stack of windows having captured the mouse and when the mouse is released 
             the capture returns to the window which had had captured it previously and it is only really released if there
             were no previous window. In particular, this means that you must release the mouse as many times as you capture
             it, unless the window receives the wx.MouseCaptureLostEvent event.
            
             Any application which captures the mouse in the beginning of some operation must handle wx.MouseCaptureLostEvent 
             and cancel this operation when it receives the event. The event handler must not recapture mouse.
             </summary>
        </member>
        <member name="M:WX.Window.ReleaseMouse">
            <summary>
            Releases mouse input captured with wx.Window.CaptureMouse().
            </summary>
        </member>
        <member name="M:WX.Window.GetCapture">
            <summary>
            Returns the currently captured window.
            </summary>
            <seealso cref="M:WX.Window.CaptureMouse"/>
        </member>
        <member name="M:WX.Window.HasCapture">
            <summary>
            Returns true if this window has the current mouse capture.
            </summary>
            <seealso cref="M:WX.Window.CaptureMouse"/>
        </member>
        <member name="M:WX.Window.PrepareDC(WX.DC)">
            <summary>This prepares the argument for drawing.</summary>
        </member>
        <member name="M:WX.Window.IsExposed(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns true if the given point or rectangle area has been exposed since the last repaint.
            Call this in an paint event handler to optimize redrawing by only redrawing
            those areas, which have been exposed.</summary>
        </member>
        <member name="M:WX.Window.HasScrollbar(WX.Orientation)">
            <summary>
            True if this displays a scrollbar on the given orientation.
            </summary>
            <param name="orient"></param>
            <returns></returns>
        </member>
        <member name="M:WX.Window.SetScrollbar(WX.Orientation,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the scrollbar properties of a built-in scrollbar.
            </summary>
            <remarks>
            Let's say you wish to display 50 lines of text, using the same font.
            The window is sized so that you can only see 16 lines at a time.
            
            You would use:
            <code>SetScrollbar(wxVERTICAL, 0, 16, 50);</code>
            
            Note that with the window at this size, the thumb position can never go above
            50 minus 16, or 34.
            
            You can determine how many lines are currently visible by dividing the current
            view size by the character height in pixels.
            
            When defining your own scrollbar behaviour, you will always need to recalculate
            the scrollbar settings when the window size changes. You could therefore put your
            scrollbar calculations and SetScrollbar call into a function named AdjustScrollbars,
            which can be called initially and also from your wxSizeEvent handler function.
            </remarks>
            <param name="orient">Determines the scrollbar whose page size is to be set.
            May be wxHORIZONTAL or wxVERTICAL.</param>
            <param name="pos">The position of the scrollbar in scroll units.</param>
            <param name="thumbSize">The size of the thumb, or visible portion of the scrollbar, in scroll units.</param>
            <param name="range">The maximum position of the scrollbar.</param>
            <param name="refresh">true to redraw the scrollbar, false otherwise.</param>
        </member>
        <member name="M:WX.Window.SetScrollPos(WX.Orientation,System.Int32,System.Boolean)">
            <summary>
            Sets the scrollbar properties of a built-in scrollbar.
            </summary>
            <remarks>
            This function does not directly affect the contents of the window: it is up to the application to take note of scrollbar attributes and redraw contents accordingly.
            
            Let's say you wish to display 50 lines of text, using the same font.
            The window is sized so that you can only see 16 lines at a time.
            
            You would use:
            <code>SetScrollbar(wxVERTICAL, 0, 16, 50);</code>
            
            Note that with the window at this size, the thumb position can never go above
            50 minus 16, or 34.
            
            You can determine how many lines are currently visible by dividing the current
            view size by the character height in pixels.
            
            When defining your own scrollbar behaviour, you will always need to recalculate
            the scrollbar settings when the window size changes. You could therefore put your
            scrollbar calculations and SetScrollbar call into a function named AdjustScrollbars,
            which can be called initially and also from your wxSizeEvent handler function.
            </remarks>
            <param name="orient">Determines the scrollbar whose page size is to be set.
            May be wxHORIZONTAL or wxVERTICAL.</param>
            <param name="pos">The position of the scrollbar in scroll units.</param>
            <param name="refresh">true to redraw the scrollbar, false otherwise. False is typically only appropriate
            if reacting on a scroll event.</param>
        </member>
        <member name="M:WX.Window.ScrollLines(System.Int32)">
            <summary>
            Scrolls the window by the given number of lines down (if lines is positive) or up.
            </summary>
            <param name="lines">Number of lines to scroll down (positive) or up (negative)</param>
            <returns>Returns true if the window was scrolled, false if it was already on top/bottom and nothing was done.</returns>
        </member>
        <member name="M:WX.Window.ScrollPages(System.Int32)">
            <summary>
            Scrolls the window by the given number of pages down (if pages is positive) or up.
            </summary>
            <param name="pages">Number of pages to scroll down (positive) or up.</param>
            <returns>This function is currently only implemented under MSW and wxGTK.</returns>
        </member>
        <member name="M:WX.Window.SetSizerAndFit(WX.Sizer)">
            <summary>
            The same as assigning a Sizer, except it also sets the size hints for the window based on the sizer's minimum size.
            </summary>
            <param name="sizer">The new sizer to use.</param>
            <seealso cref="P:WX.Window.Sizer"/>
        </member>
        <member name="M:WX.Window.SetSizerAndFit(WX.Sizer,System.Boolean)">
            <summary>
            The same as assigning a Sizer, except it also sets the size hints for the window based on the sizer's minimum size.
            </summary>
            <param name="sizer">The new sizer to use.</param>
            <param name="deleteOld">Default is true</param>
            <seealso cref="P:WX.Window.Sizer"/>
        </member>
        <member name="M:WX.Window.GetNextWindow">
            <summary>Get the next Window in the TAB order of the parent.
            This may be <c>null</c> if either this does not have a parent or the parent only has one child.</summary>
        </member>
        <member name="M:WX.Window.GetPreviousWindow">
            <summary>Get the previous Window in the TAB order of the parent.
            This may be <c>null</c> if either this does not have a parent or the parent only has one child.</summary>
        </member>
        <member name="M:WX.Window.InheritAttributes">
             <summary>
             This function is (or should be, in case of custom controls) called during window creation to intelligently set up the window visual attributes, that is the font and the foreground and background colours.
            
             By "intelligently'' the following is meant: by default, all windows use their own default attributes.
             However if some of the parents attributes are explicitly (that is, using the setter of WX.Window.Font and not WX.Window.SetOwnFont())
             changed and if the corresponding attribute hadn't been explicitly set for this window itself, then this window
             takes the same value as used by the parent. In addition, if the window overrides ShouldInheritColours()
             to return false, the colours will not be changed no matter what and only the font might.
             
             This rather complicated logic is necessary in order to accommodate the different usage scenarios. The most common one is when all default attributes are used and in this case, nothing should be inherited as in modern GUIs different controls use different fonts (and colours) than their siblings so they can't inherit the same value from the parent. However it was also deemed desirable to allow to simply change the attributes of all children at once by just changing the font or colour of their common parent, hence in this case we do inherit the parents attributes.
             </summary>
        </member>
        <member name="E:WX.Window.OnTransferDataFromWindow">
            <summary>This will be called on <c>wxWindow</c>::TransferDataFromWindow.
            This is the right place for validation.</summary>
        </member>
        <member name="P:WX.Window.BackgroundColour">
             <summary>
             Get or set the background colour of the window.
             Assign WX.Colour.NullColour to reset to the default colour.
             Please see InheritAttributes() for explanation of the difference between this method and SetOwnBackgroundColour().
             </summary>
             <remarks>
             The background colour is usually painted by the default WX.EraseEvent event handler function under Windows and automatically under GTK.
            
             Note that setting the background colour does not cause an immediate refresh, so you may wish to call WX.Window.ClearBackground() or WX.Window.Refresh() after calling this function.
            
             Using this function will disable attempts to use themes for this window, if the system supports them. Use with care since usually the themes represent the appearance chosen by the user to be used for all applications on the system.
             </remarks>
        </member>
        <member name="P:WX.Window.ForegroundColour">
             <summary>
             Get or set the foreground colour of the window. Assign WX.Colour.NullColour to reset to the default colour.
            
             Please see <c>InheritAttributes</c> for explanation of the difference between this method and
             <c>SetOwnForegroundColour</c>.
             </summary>
             <remarks>
             The interpretation of foreground colour is open to interpretation according to the window class; it may be the text colour or other colour, or it may not be used at all.
             
             Using this function will disable attempts to use themes for this window, if the system supports them. Use with care since usually the themes represent the appearance chosen by the user to be used for all applications on the system.
             </remarks>
        </member>
        <member name="P:WX.Window.Font">
            <summary>
            Get or set the font used by this window.
            Refer to InheritAttributes() for some additional information on using this setter.
            </summary>
        </member>
        <member name="P:WX.Window.StyleFlags">
            <summary>This will set or get the styles flags that define this window.</summary>
        </member>
        <member name="P:WX.Window.Enabled">
            <summary>Enable or disable cf. read whether enabled or disabled.</summary>
        </member>
        <member name="P:WX.Window.MinWidth">
            <summary>Get or set the minimal width of the window.</summary>
        </member>
        <member name="P:WX.Window.MinHeight">
            <summary>Get or set the minimal height of the window.</summary>
        </member>
        <member name="P:WX.Window.MinSize">
            <summary>Read and set the minimum size of the window.
            This should be set after changing the size for instance after construction and before
            adding this to the parent sizer.
            However, you should consider to set size hints instead of using this method.</summary>
        </member>
        <member name="P:WX.Window.MaxWidth">
            <summary>This is a read-only property. Use wx.Window.MaxSize to change this.</summary>
        </member>
        <member name="P:WX.Window.MaxSize">
            <summary>Read and set the maximum size of the window.
            This should be set after changing the size for instance after construction and before
            adding this to the parent sizer.
            However, you should consider to set size hints instead of using this method.</summary>
        </member>
        <member name="P:WX.Window.VirtualSize">
            <summary>
            This gets the virtual size of the window in pixels.
            By default it returns the client size of the window, but after a using the setter,
            this will return the size that has been set by the setter.
            </summary>
        </member>
        <member name="P:WX.Window.IsRetained">
             <summary>
             Returns true if the window is retained, false otherwise.
            
             Remarks: Retained windows are only available on X platforms.
             </summary>
        </member>
        <member name="P:WX.Window.Parent">
            <summary>
            Get or set the parent window of this window.
            </summary>
        </member>
        <member name="P:WX.Window.GrandParent">
            <summary>
            Returns the grandparent of a window, or <c>null</c> if there isn't one.
            </summary>
        </member>
        <member name="P:WX.Window.TopLevelWindow">
            <summary>
            Get the top level window that contains the current window.
            </summary>
        </member>
        <member name="P:WX.Window.HelpText">
            <summary>
            Refer to wx.Html.HtmlHelpController.
            </summary>
        </member>
        <member name="P:WX.Window.DropTarget">
            <summary>
            On setting a value: Associates a drop target with this window.
            If the window already has a drop target, it is deleted.
            On getting the value: Returns the associated drop target, which may be NULL.
            </summary>
            <remarks>
            Cf. \ref drag-and-drop.
            </remarks>
        </member>
        <member name="P:WX.Window.Sizer">
            <summary>
            The sizer of this window (if defined).
            Assign to this property to specify a dynamic layout providing a sizer.
            </summary>
        </member>
        <member name="P:WX.Window.Top">
            <summary>
            Get or set the top Y-position of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Left">
            <summary>
            Get or set the left X-position of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Right">
            <summary>
            Get or set the right X-position of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Bottom">
            <summary>
            Get or set the bottom Y-position of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Width">
            <summary>
            Get or set the width of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Height">
            <summary>
            Get or set the height of this window.
            </summary>
        </member>
        <member name="P:WX.Window.Children">
            <summary>The children of this window in an array.</summary>
        </member>
        <member name="P:WX.Window.AcceleratorTable">
            <summary>
            The accelerator table that is associated to this window.
            </summary>
        </member>
        <member name="P:WX.Window.BackgroundStyle">
            <summary>Returns or defines the background mode of the window.
             The background style indicates whether background colour should be determined by the system
             (System), be set to a specific colour (Colour), or should be left to the
             application to implement (Custom).
            
             On GTK+, use of Custom allows the flicker-free drawing of a custom background, such
             as a tiled bitmap. Currently the style has no effect on other platforms.</summary>
        </member>
        <member name="P:WX.Window.ShouldInheritColours">
            <summary>
            Return true from here to allow the colours of this window to be changed by <c>InheritAttributes</c>, returning
            false forbids inheriting them from the parent window.
            
            The base class version returns false, but this method is overridden in WX.Control where it returns true.
            </summary>
        </member>
        <member name="E:WX.Window.LeftUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_UP.
            </summary>
        </member>
        <member name="E:WX.Window.RightUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_UP.
            </summary>
        </member>
        <member name="E:WX.Window.MiddleUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_UP.
            </summary>
        </member>
        <member name="E:WX.Window.LeftDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_DOWN.
            </summary>
        </member>
        <member name="E:WX.Window.MiddleDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_DOWN.
            </summary>
        </member>
        <member name="E:WX.Window.RightDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_DOWN.
            </summary>
        </member>
        <member name="E:WX.Window.LeftDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_DCLICK.
            </summary>
        </member>
        <member name="E:WX.Window.RightDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_DCLICK.
            </summary>
        </member>
        <member name="E:WX.Window.MiddleDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_DCLICK.
            </summary>
        </member>
        <member name="E:WX.Window.MouseMove">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MOTION.
            </summary>
        </member>
        <member name="E:WX.Window.MouseThumbTrack">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_THUMBTRACK.
            </summary>
        </member>
        <member name="E:WX.Window.MouseEnter">
            <summary>
            Adds a listener to the wx.Event.wxEVT_ENTER_WINDOW.
            </summary>
        </member>
        <member name="E:WX.Window.MouseLeave">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEAVE_WINDOW.
            </summary>
        </member>
        <member name="E:WX.Window.ScrollLineUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_LINEUP.
            </summary>
        </member>
        <member name="E:WX.Window.ScrollLineDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_LINEDOWN.
            </summary>
        </member>
        <member name="E:WX.Window.UpdateUI">
            <summary>
            Adds a listener to the wx.Event.wxEVT_UPDATE_UI.
            </summary>
        </member>
        <member name="E:WX.Window.KeyDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_KEY_DOWN.
            </summary>
        </member>
        <member name="E:WX.Window.KeyUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_KEY_UP.
            </summary>
        </member>
        <member name="E:WX.Window.Char">
            <summary>
            Adds a listener to the wx.Event.wxEVT_CHAR.
            </summary>
        </member>
        <member name="E:WX.Window.Closing">
            <summary>
            Adds a listener to the wx.Event.wxEVT_CLOSE_WINDOW.
            </summary>
        </member>
        <member name="E:WX.Window.Activated">
            <summary>
            Adds a listener to the wx.Event.wxEVT_ACTIVATE.
            </summary>
        </member>
        <member name="E:WX.Window.Moved">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MOVE.
            </summary>
        </member>
        <member name="E:WX.Window.Resized">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SIZE.
            </summary>
        </member>
        <member name="T:WX.Window.Validator">
            <summary>Simply a delegator for validation.
            Asign <c>false</c> to the argument if you want to indicate</summary>
        </member>
        <member name="M:WX.Dialog.CreateButtonSizer(WX.Dialog.ButtonFlags)">
            <summary>
            Creates a sizer with standard buttons. flags is a bit list of the following flags:
            ButtonFlags.Ok, ButtonFlags.CANCEL, ButtonFlags.Yes, ButtonFlags.No, ButtonFlags.HELP, ButtonFlags.No_Default.
            
            The sizer lays out the buttons in a manner appropriate to the platform.
            
            This function uses CreateStdDialogButtonSizer internally for most platforms but doesn't create the sizer at all for the platforms with hardware buttons (such as smartphones) for which it sets up the hardware buttons appropriately and returns NULL, so don't forget to test that the return value is valid before using it.
            </summary>
            <param name="flags">The flags defining the buttons to be present.</param>
            <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="M:WX.Dialog.CreateSeparatedButtonSizer(WX.Dialog.ButtonFlags)">
             <summary>
             Creates a sizer with standard buttons using CreateButtonSizer() separated from the rest of the dialog
             contents by a horizontal wx.StaticLine.
            
             Please notice that just like CreateButtonSizer() this function may return <c>null</c> if no buttons were created.
             </summary>
             <param name="flags">The flags defining the buttons to be present.</param>
             <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="M:WX.Dialog.CreateStdDialogButtonSizer(WX.Dialog.ButtonFlags)">
             <summary>
             Creates a wxStdDialogButtonSizer with standard buttons. flags is a bit list of the following
             flags: ButtonFlags.Ok, ButtonFlags.CANCEL, ButtonFlags.Yes, ButtonFlags.No, ButtonFlags.HELP, ButtonFlags.No_Default.
            
             The sizer lays out the buttons in a manner appropriate to the platform.
             </summary>
             <param name="flags">The flags defining the buttons to be present.</param>
             <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="P:WX.Dialog.ReturnCode">
            <summary>
            Use this to get or set the value that will be returned by this dialog if shown modally.
            </summary>
        </member>
        <member name="P:WX.Dialog.DefaultItem">
            <summary>Get or set the default item.
            This usually is a button.</summary>
        </member>
        <member name="T:WX.Dialog.ButtonFlags">
            <summary>This is for CreateButtonSizer.
            </summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.YES">
            <summary>Show an YES button.
            This shall be used together either with NO or CANCEL.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.Ok">
            <summary>Show an OK button.</summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.NO">
            <summary>Show an NO button.
            This shall be used together either with DlgYes.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.Cancel">
            <summary>Show an CANCEL button.</summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.YES_NO">
            <summary>Show YES and NO button.</summary>
        </member>
        <member name="F:WX.Dialog.ButtonFlags.NO_Default">
            <summary>Used with <c>NO</c>, makes NO button the default.</summary>
        </member>
        <member name="T:WX.PaintEvent">
             <summary>
             A paint event is sent when a window's contents needs to be repainted.
            
             Please notice that in general it is impossible to change the drawing of a standard control (such as wx.Button)
             and so you shouldn't attempt to handle paint events for them as even if it might work on some platforms,
             this is inherently not portable and won't work everywhere.
             </summary>
             <remarks>
             To process a paint event, use this event handler macro to direct input to a member function that takes a
             wx.Event argument - expecting this to be of this class wx.PaintEvent.
             <list type="table">
             <item><term>EVT_PAINT(func)</term> <description>Process a wx.PaintEvent event.</description></item>
             </list>
             
             Note that In a paint event handler, the application must always create a wx.PaintDC object, even if you
             do not use it. Otherwise, under MS Windows, refreshing for this and other windows will go wrong.
             
             For example:
             
             <code>
               void MyWindow
               {
                   public MyWindow(...)
                   {
                     ...
                     this.EVT_PAINT(new EventListener(OnPaint));
                     ...
                   }
                   
                   void OnPaint(object sender, wx.PaintEvent event)
                   {
                     using (wx.PaintDC dc = new wx.PaintDC(this))
                     {
                         DrawMyDocument(dc);
                     }
                   }
               }
             </code>
             
             You can optimize painting by retrieving the rectangles that have been damaged and only repainting these. The rectangles are in terms of the client area, and are unscrolled, so you will need to do some calculations using the current view position to obtain logical, scrolled units.
             </remarks>
        </member>
        <member name="T:WX.Frame">
             <summary>
             A frame is a window whose size and position can (usually) be changed by the user. It usually has thick borders and a title bar, and can optionally contain a menu bar, toolbar and status bar. A frame can contain any window that is not a frame or dialog.
            
             A frame that has a status bar and toolbar created via the CreateStatusBar/CreateToolBar functions manages these windows, and adjusts the value returned by GetClientSize to reflect the remaining size available to application windows.
             
             Refer to the styles 
             WindowStyles.Default_FRAME_STYLE, WindowStyles.MINIMIZE_BOX, WindowStyles.MaximizeBox, WindowStyles.ResizeBorder
             WindowStyles.SYSTEM_MENU, WindowStyles.CAPTION, WindowStyles.CLOSE_BOX, WindowStyles.ClipChildren ...
             </summary>
        </member>
        <member name="M:WX.Frame.ShowFullScreen(System.Boolean,WX.Fullscreen)">
            <summary> Depending on the value of show parameter the window is either shown full screen or restored to its normal
            state.
            <c>style</c> is a bit list containing some or all of the following
            values, which indicate what elements of the window to hide in
            full-screen mode:
            
            This function has not been tested with MDI frames.
            Note that showing a window full screen also actually Show()s if it
            hadn't been shown yet. </summary>
        </member>
        <member name="M:WX.Frame.ShowFullScreen(System.Boolean)">
            <summary>The window is shown full screen.
            This function has not been tested with MDI frames.
            Note that showing a window full screen also actually Show()s if it
            hadn't been shown yet. </summary>
        </member>
        <member name="M:WX.Frame.CreateStatusBar">
             <summary>
             Creates a status bar at the bottom of the frame.
             </summary>
             <returns>A pointer to the status bar if it was created successfully, <c>null</c> otherwise.</returns>
             <seealso cref="M:WX.Frame.SetStatusText(System.String)"/>
             <seealso cref="P:wx.Frame.StatusBar"/>
             <remarks>
             The width of the status bar is the whole width of the frame (adjusted automatically when resizing),
             and the height and text size are chosen by the host windowing system.
            
             Note that you can put controls and other windows on the status bar if you wish.
             </remarks>
        </member>
        <member name="M:WX.Frame.CreateStatusBar(System.Int32)">
             <summary>
             Creates a status bar at the bottom of the frame.
             </summary>
             <param name="number">The number of fields to create. Specify a value greater than 1 to create a multi-field status bar.</param>
             <returns>A pointer to the status bar if it was created successfully, <c>null</c> otherwise.</returns>
             <seealso cref="M:WX.Frame.SetStatusText(System.String)"/>
             <seealso cref="P:wx.Frame.StatusBar"/>
             <remarks>
             The width of the status bar is the whole width of the frame (adjusted automatically when resizing),
             and the height and text size are chosen by the host windowing system.
            
             Note that you can put controls and other windows on the status bar if you wish.
             </remarks>
        </member>
        <member name="M:WX.Frame.CreateStatusBar(System.Int32,WX.WindowStyles)">
             <summary>
             Creates a status bar at the bottom of the frame.
             </summary>
             <param name="number">The number of fields to create. Specify a value greater than 1 to create a multi-field status bar.</param>
             <param name="style">The status bar style. See wxStatusBar for a list of valid styles.</param>
             <returns>A pointer to the status bar if it was created successfully, <c>null</c> otherwise.</returns>
             <seealso cref="M:WX.Frame.SetStatusText(System.String)"/>
             <seealso cref="P:wx.Frame.StatusBar"/>
             <remarks>
             The width of the status bar is the whole width of the frame (adjusted automatically when resizing),
             and the height and text size are chosen by the host windowing system.
            
             Note that you can put controls and other windows on the status bar if you wish.
             </remarks>
        </member>
        <member name="M:WX.Frame.CreateStatusBar(System.Int32,WX.WindowStyles,System.Int32)">
             <summary>
             Creates a status bar at the bottom of the frame.
             </summary>
             <param name="number">The number of fields to create. Specify a value greater than 1 to create a multi-field status bar.</param>
             <param name="style">The status bar style. See wxStatusBar for a list of valid styles.</param>
             <param name="id">The status bar window identifier. If -1, an identifier will be chosen by wxWidgets.</param>
             <returns>A pointer to the status bar if it was created successfully, <c>null</c> otherwise.</returns>
             <seealso cref="M:WX.Frame.SetStatusText(System.String)"/>
             <seealso cref="P:wx.Frame.StatusBar"/>
             <remarks>
             The width of the status bar is the whole width of the frame (adjusted automatically when resizing),
             and the height and text size are chosen by the host windowing system.
            
             Note that you can put controls and other windows on the status bar if you wish.
             </remarks>
        </member>
        <member name="M:WX.Frame.CreateStatusBar(System.Int32,WX.WindowStyles,System.Int32,System.String)">
             <summary>
             Creates a status bar at the bottom of the frame.
             </summary>
             <param name="number">The number of fields to create. Specify a value greater than 1 to create a multi-field status bar.</param>
             <param name="style">The status bar style. See wxStatusBar for a list of valid styles.</param>
             <param name="id">The status bar window identifier. If -1, an identifier will be chosen by wxWidgets.</param>
             <param name="name">The status bar window name.</param>
             <returns>A pointer to the status bar if it was created successfully, <c>null</c> otherwise.</returns>
             <seealso cref="M:WX.Frame.SetStatusText(System.String)"/>
             <seealso cref="P:wx.Frame.StatusBar"/>
             <remarks>
             The width of the status bar is the whole width of the frame (adjusted automatically when resizing),
             and the height and text size are chosen by the host windowing system.
            
             Note that you can put controls and other windows on the status bar if you wish.
             </remarks>
        </member>
        <member name="M:WX.Frame.SetStatusText(System.String)">
            <summary>
            Setting text for the status bar.
            </summary>
            <param name="text">Text to be displayed by the status bar-</param>
        </member>
        <member name="M:WX.Frame.SetStatusText(System.String,System.Int32)">
            <summary>
            Set text for the status bar 
            </summary>
            <param name="text">Text to be displayed by the status bar-</param>
            <param name="number">Index of the field of the status bar that shall display the text.</param>
        </member>
        <member name="M:WX.Frame.SetStatusWidths(System.Int32[])">
            <summary>
            Sets the widths of the fields in the status bar.
            The widths of the variable fields are calculated from the total width of all fields, minus the sum of widths of the non-variable fields, divided by the number of variable fields.
            </summary>
            <param name="widths">Array of values each representing the width of a status line.</param>
        </member>
        <member name="M:WX.Frame.CreateToolBar">
            <summary>
            Create a toolbar of undefined ID and name (of the toolbar control) "toolBar".
            </summary>
            <returns>The created toolbar.</returns>
        </member>
        <member name="M:WX.Frame.CreateToolBar(WX.WindowStyles)">
            <summary>
            Create a toolbar of undefined ID and name (of the toolbar control) "toolBar".. 
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="M:WX.Frame.CreateToolBar(WX.WindowStyles,System.Int32)">
            <summary>
            Create a toolbar with name (of the toolbar control) "toolBar".
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <param name="id">Window ID of the toolbar.</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="M:WX.Frame.CreateToolBar(WX.WindowStyles,System.Int32,System.String)">
            <summary>
            Create a toolbar. 
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <param name="id">Window ID of the toolbar.</param>
            <param name="name">Name of the window.</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="M:WX.Frame.Iconize(System.Boolean)">
            <summary>
            Iconizes or restores the window.
            </summary>
            <param name="value">If true, iconizes the window, otherwise it restores it.</param>
        </member>
        <member name="M:WX.Frame.Maximize(System.Boolean)">
            <summary>
            Maximizes or restores the window.
            </summary>
            <param name="value">If true, maximizes the window, otherwise it restores it.</param>
        </member>
        <member name="P:WX.Frame.IsFullScreen">
            <summary>
            The getter returns true iff this frame is in full screen mode.
            The setter is a synonym for ShowFullScreen() either with Fullscreen.ALL (assigning <c>true</c>) or Fullscreen.None.
            </summary>
            <see cref="M:wx.Frame.ShowFullScreen"/>
        </member>
        <member name="P:WX.Frame.StatusBar">
            <summary>
            The setter associates a status bar with the frame.
            </summary>
        </member>
        <member name="P:WX.Frame.StatusBarPane">
            <summary>
            Get or set the status bar pane used to display menu and toolbar help. Using -1 disables help display.
            </summary>
        </member>
        <member name="P:WX.Frame.Icon">
            <summary>
            Get or set the icon that will be displayed in the window decorator or when iconifying.
            </summary>
        </member>
        <member name="P:WX.Frame.MenuBar">
            <summary>
            The menu bar of this instance.
            You may get the current instance using this property or set
            a new menu bar assigning to this property.
            </summary>
        </member>
        <member name="P:WX.Frame.StatusText">
            <summary>
            Set text for the status bar here. Unfortunately, reading the displayed text is not supported.
            </summary>
        </member>
        <member name="P:WX.Frame.StatusWidths">
            <summary>
            Alternative form of SetStatusWidths(): Only the setter is defined.
            </summary>
            <see cref="M:WX.Frame.SetStatusWidths(System.Int32[])"/>
        </member>
        <member name="P:WX.Frame.Iconized">
             <summary>
             True iff the frame has been iconized. This is false if the frame has been deallocated.
            
             The setter is a synonym for Iconize().
             </summary>
             <seealso cref="P:WX.Frame.Maximized"/>
        </member>
        <member name="P:WX.Frame.Maximized">
            <summary>
            True iff the frame has been maximized. This is false if the frame has been deallocated.
            The setter is a synonym for Maximize().
            </summary>
            <seealso cref="P:WX.Frame.Iconized"/>
            <seealso cref="M:WX.Frame.Maximize(System.Boolean)"/>
        </member>
        <member name="P:WX.Frame.DefaultItem">
            <summary>
            Get or set the default item.
            This usually is a button.
            </summary>
        </member>
        <member name="M:WX.FontDialog.Create(WX.Window,WX.FontData)">
            <summary>
            Create the dialog.
            </summary>
            <param name="parent">The parent window of the dialog. This may be <c>null</c>.</param>
            <param name="data">The initially selected font.</param>
            <returns></returns>
        </member>
        <member name="M:WX.FontDialog.ShowModal">
            <summary>Modal display of the dialog. Returns whether input has been confirmed or cancelled.
            </summary>
        </member>
        <member name="P:WX.FontDialog.FontData">
            <summary>
            The font that has been selected by the user.
            </summary>
        </member>
        <member name="T:WX.ControlWithItems">
            <summary>
            base class of some controls presenting a list of items.
            </summary>
        </member>
        <member name="T:WX.Control">
            <summary>This is the base class for a control or "widget''.
             A control is generally a small window which processes user input and/or displays one or more item of data.
            </summary>
        </member>
        <member name="M:WX.ControlWithItems.SetString(System.Int32,System.String)">
            <summary>Set the label of the entry of index <c>n</c>.
            Refer also to the indexer of this class.
            </summary>
        </member>
        <member name="M:WX.ControlWithItems.GetString(System.Int32)">
            <summary>Get the label of the entry of index <c>n</c>.
             Refer also to the indexer of this class.
            </summary>
        </member>
        <member name="M:WX.ControlWithItems.FindString(System.String)">
            <summary>Finds an item whose label matches the given string.</summary>
            <returns> The zero-based position of the item, or -1 if the string was not found.</returns>
        </member>
        <member name="M:WX.ControlWithItems.SetStringSelection(System.String)">
            <summary>Select the designated label. Return <c>true</c> on success and <c>false</c> otherwise.
             Refer also to property <c>StringSelection()</c>.
            </summary>
        </member>
        <member name="M:WX.ControlWithItems.GetClientObject(System.Int32)">
            <summary>Reads client data for item <c>n</c>.
            </summary>
        </member>
        <member name="M:WX.ControlWithItems.Append(System.String[])">
            \name Maintaining items.
        </member>
        <member name="M:WX.ControlWithItems.Append(System.String,WX.ClientData)">
            <summary>This will append <c>item</c> to the end of the item list and associate it with the provided client data.
             The client data may be <c>null</c>.
            </summary> 
             <returns> The index of the new item.</returns>
        </member>
        <member name="M:WX.ControlWithItems.Insert(System.String,System.Int32,WX.ClientData)">
            <summary>Inserts the item into the list before pos, associating the given, typed or untyped, client data pointer with the item.
            Not valid for ListBox.wxLB_SORT or ComboBox.wxCB_SORT styles, use Append() instead.</summary>
            <returns> The return value is the index of the newly inserted item. If the insertion failed for some reason, -1 is returned.</returns>
        </member>
        <member name="M:WX.ControlWithItems.Clear">
            <summary>Deletes all items.
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.StringSelection">
            <summary>Also refer to method SetStringSelection() that returns a Boolean that is true on success and false otherwise.
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.Count">
            <summary>Returns the number of items.
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.IsEmpty">
            <summary>True iff this is empty.
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.Strings">
            <summary>All the currently known labels.
             Read only property. Alternatively, use the indexer of this class.
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.Item(System.Int32)">
            <summary>This is equivalent to the methods GetString() and SetString().
            </summary>
        </member>
        <member name="P:WX.ControlWithItems.ShouldInheritColours">
            <summary>
            Return true from here to allow the colours of this window to be changed by <c>InheritAttributes</c>, returning
            false forbids inheriting them from the parent window.
            
            The base class version returns false, but this method is overridden in WX.Control where it returns true.
            </summary>
        </member>
        <member name="T:WX.Colour">
            <summary>This class represents colours.
            </summary>
        </member>
        <member name="T:WX.ICanBeMadeReadonly">
            <summary>
            Objects implement this interface if they can be readonly. In that case, all 
            calls to modifiers will cause exceptions of class  CannotChangeReadonly.
            </summary>
        </member>
        <member name="M:WX.ICanBeMadeReadonly.MakeReadOnly">
            <summary>
            From this call, all calls to modifiers will cause exceptions.
            This shall return <c>this</c>.
            </summary>
        </member>
        <member name="P:WX.ICanBeMadeReadonly.IsReadonly">
            <summary>
            If this is true, all modifiers will cause exceptions. If this is false,
            modfiers can be used.
            </summary>
        </member>
        <member name="F:WX.Colour.AlphaTransparent">
            <summary>This is the APLPHA value indicating transparency.
            </summary>
        </member>
        <member name="F:WX.Colour.AlphaOpaque">
            <summary>This is the APLPHA value indicating opaque colour.
            </summary>
        </member>
        <member name="M:WX.Colour.Set(System.Byte,System.Byte,System.Byte)">
            <summary>Assign RGB values.</summary>
        </member>
        <member name="M:WX.Colour.Set(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Assign RGB and Alpha values.</summary>
        </member>
        <member name="M:WX.Colour.Set(WX.wxString)">
            <summary>
            Set RGB values from the provided string.
            Set() accepts: colour names (those listed in wxTheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green,
            blue components).
            </summary>
            <param name="str">Colour name, RGB-syntax string or HTML-like colour notation</param>
        </member>
        <member name="M:WX.Colour.Set(System.String)">
            <summary>
            Set RGB values from the provided string.
            Set() accepts: colour names (those listed in wxTheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green,
            blue components).
            </summary>
            <param name="str">Colour name, RGB-syntax string or HTML-like colour notation</param>
        </member>
        <member name="M:WX.Colour.GetAsString(WX.Colour.C2S)">
            <summary>Returns the colour in string form according to the provided flags.</summary>
        </member>
        <member name="M:WX.Colour.ToString">
            <summary>Returns a string form representing the colour.
            Implemented by GetAsString().</summary>
        </member>
        <member name="P:WX.Colour.TheColourDatabase">
            <summary>Returns ColourDatabase.TheColourDatabase.
            
            The standard database contains at least the following colours:
            AQUAMARINE, BLACK, BLUE, BLUE VIOLET, BROWN, CADET BLUE, CORAL, CORNFLOWER BLUE, CYAN, DARK GREY,
            DARK GREEN, DARK OLIVE GREEN, DARK ORCHID, DARK SLATE BLUE, DARK SLATE GREY DARK TURQUOISE,
            DIM GREY, FIREBRICK, FOREST GREEN, GOLD, GOLDENROD, GREY, GREEN, GREEN YELLOW, INDIAN RED, KHAKI,
            LIGHT BLUE, LIGHT GREY, LIGHT STEEL BLUE, LIME GREEN, MAGENTA, MAROON, MEDIUM AQUAMARINE, MEDIUM BLUE,
            MEDIUM FOREST GREEN, MEDIUM GOLDENROD, MEDIUM ORCHID, MEDIUM SEA GREEN, MEDIUM SLATE BLUE,
            MEDIUM SPRING GREEN, MEDIUM TURQUOISE, MEDIUM VIOLET RED, MIDNIGHT BLUE, NAVY, ORANGE, ORANGE RED,
            ORCHID, PALE GREEN, PINK, PLUM, PURPLE, RED, SALMON, SEA GREEN, SIENNA, SKY BLUE, SLATE BLUE,
            SPRING GREEN, STEEL BLUE, TAN, THISTLE, TURQUOISE, VIOLET, VIOLET RED, WHEAT, WHITE, YELLOW,
            YELLOW GREEN.</summary>
        </member>
        <member name="T:WX.Colour.C2S">
            <summary>Options for wx.Colour.GetAsString()
            </summary>
        </member>
        <member name="F:WX.Colour.C2S.Name">
            <summary>return colour name, when possible
            </summary>
        </member>
        <member name="F:WX.Colour.C2S.CssSyntax">
            <summary>return colour in rgb(r,g,b) syntax
            </summary>
        </member>
        <member name="F:WX.Colour.C2S.HtmlSyntax">
            <summary> return colour in #rrggbb syntax.
            </summary>
        </member>
        <member name="T:WX.AcceleratorEntry">
            <summary>
            An entry in the AcceleratorTable.
            </summary>
        </member>
        <member name="T:WX.AcceleratorEntry.AccelFlags">
            <summary>Use this to define any modifier key that has to be pressed together with the provided key code.</summary>
        </member>
        <member name="T:WX.AcceleratorTable">
            <summary>
            An accelerator table allows the application to specify a table of keyboard shortcuts for menu or button commands.
            Initially, windows bear an accelerator table with no data.
            </summary>
        </member>
        <member name="M:WX.AcceleratorTable.#ctor(System.IntPtr)">
            <summary>This is for internal purposes only.
            This CTor will be used on creating wrappers for internally created instances.</summary>
        </member>
        <member name="M:WX.AcceleratorTable.#ctor">
            <summary>Creates a NULL accelerator table.</summary>
        </member>
        <member name="M:WX.AcceleratorTable.#ctor(WX.AcceleratorEntry[])">
            <summary>Creates an accelerator table from an array of accelerator entries.</summary>
        </member>
        <member name="M:WX.CommandEvent.#ctor(System.Int32,System.Int32)">
            <summary>Refer to wx.Event for available values for <c>evtType</c>.
            </summary>
            <param name="evtType">The type of the created event, e.g. Event.wxEVT_COMMAND_TEXT_ENTER</param>
            <param name="winId">The id of the windows that fires the event.</param>
        </member>
        <member name="M:WX.CommandEvent.#ctor(System.Int32)">
            <summary>Refer to wx.Event for available values for <c>evtType</c>.
            </summary>
        </member>
        <member name="T:WX.Printout">
            <summary>
            This class encapsulates the functionality of printing out an application document.
            A new class must be derived and members overridden to respond to calls such as OnPrintPage() and HasPage()
            and to render the print image onto an associated wx.DC. Instances of this class are passed to wx.Printer.Print()
            or to a wx.PrintPreview object to initiate printing or previewing.
            </summary>
            <remarks>
            Your derived wx.Printout is responsible for drawing both the preview image and the printed page. If your windows'
            drawing routines accept an arbitrary DC as an argument, you can re-use those routines within your wxPrintout subclass
            to draw the printout image. You may also add additional drawing elements within your wx.Printout subclass,
            like headers, footers, and/or page numbers. However, the image on the printed page will often differ from the
            image drawn on the screen, as will the print preview image -- not just in the presence of headers and footers,
            but typically in scale. A high-resolution printer presents a much larger drawing surface (i.e., a higher-resolution
            DC); a zoomed-out preview image presents a much smaller drawing surface (lower-resolution DC). By using the routines
            <c>FitThisSizeToXXX()</c> and/or <c>MapScreenSizeToXXX()</c> within your wxPrintout subclass to set the user scale
            and origin of the associated DC, you can easily use a single drawing routine to draw on your application's windows,
            to create the print preview image, and to create the printed paper image, and achieve a common appearance to the
            preview image and the printed page.
            </remarks>
        </member>
        <member name="T:WX.Html.HtmlCond">
            <summary>Conditions for HtmlCell.Find().</summary>
        </member>
        <member name="F:WX.Html.HtmlCond.IS_ANCHOR">
            <summary>Finds the anchor of 'param' name (argument is a string).</summary>
        </member>
        <member name="F:WX.Html.HtmlCond.IS_IMAGEMAP">
            <summary>Finds imagemap of 'param' name (argument is a string).</summary>
        </member>
        <member name="T:WX.Html.HtmlFind">
            <summary>Refer to HtmlCell.FindCellByPos().</summary>
        </member>
        <member name="T:WX.Html.HtmlWindow">
            <summary>A window displaying (reduced) HTML formatted text.
            </summary>
            <remarks>
            \image html helpview.jpg
            </remarks>
        </member>
        <member name="T:WX.ScrolledWindow">
            <summary>The wx.ScrolledWindow class manages scrolling for its client area, transforming the coordinates according to the scrollbar positions, and setting the scroll positions, thumb sizes and ranges according to the area in view.
             Starting from version 2.4 of wxWidgets, there are several ways to use a
             wx.ScrolledWindow. In particular, there are now three ways to set the size of
             the scrolling area:
             One way is to set the scrollbars directly using a call to
             wx.ScrolledWindow.SetScrollbars(). This is the way it used to be in any previous
             version of  wxWidgets and it will be kept for backwards compatibility.
            
             An additional method of manual control, which requires a little less computation
             of your own, is to set the total size of the scrolling area by calling either
             wx.Window.VirtualSize, or wx.Window.FitInside(), and setting the scrolling
             increments for it by calling wx.ScrolledWindow.SetScrollRate(). Scrolling in some
             orientation is enabled by setting a non-zero increment for it.
            
             The most automatic and newest way is to simply let sizers determine the scrolling
             area. This is now the default when you set an interior sizer into a
             wx.ScrolledWindow with wx.Window.SetSizer. The scrolling area will be set to the
             size requested by the sizer and the scrollbars will be assigned for each
             orientation according to the need for them and the scrolling increment set by
             wx.Scrolled.Window.SetScrollRate. As above, scrolling is only enabled in
             orientations with a non-zero increment. You can influence the minimum size of the
             scrolled area controlled by a sizer by calling wx.Window.SetVirtualSizeHints().
            
             Note: if Maximum size hints are still supported by SetVirtualSizeHints(), use
             them at your own dire risk. They may or may not have been removed for 2.4, but it
             really only makes sense to set minimum size hints here. We should probably replace
             SetVirtualSizeHints() with SetMinVirtualSize() or similar and remove it entirely
             in future.
            
             As with all windows, an application can draw onto a wx.ScrolledWindow using a
             device context.
            
             You have the option of handling the OnPaint handler or overriding the <c>OnDraw()</c>
             function, which is passed a pre-scrolled device context (prepared by <c>DoPrepareDC)</c>.
            
             If you don't wish to calculate your own scrolling, you must call <c>DoPrepareDC</c> when
             not drawing from within <c>OnDraw</c>, to set the device origin for the device context
             according to the current scroll position.
            
             A wx.ScrolledWindow will normally scroll itself and therefore its child windows as
             well. It might however be desired to scroll a different window than itself: e.g.
             when designing a spreadsheet, you will normally only have to scroll the
             (usually white) cell area, whereas the (usually grey) label area will scroll very
             differently. For this special purpose, you can call <c>SetTargetWindow</c> which means
             that pressing the scrollbars will scroll a different window.
            
             Note that the underlying system knows nothing about scrolling coordinates, so that
             all system functions (mouse events, expose events, refresh calls etc) as well as
             the position of subwindows are relative to the "physical" origin of the scrolled
             window. If the user insert a child window at position (10,10) and scrolls the
             window down 100 pixels (moving the child window out of the visible area), the
             child window will report a position of (10,-90).
            
             Remarks:
             Use wx.ScrolledWindow for applications where the user scrolls by a fixed amount,
             and where a 'page' can be interpreted to be the current visible portion of the
             window. For more sophisticated applications, use the wx.ScrolledWindow
             implementation as a guide to build your own scroll behaviour.
            
             See also wx.ScrollBar, wx.ClientDC, wx.PaintDC, and wx.VScrolledWindow.</summary>
        </member>
        <member name="T:WX.Panel">
            <summary>A panel is a window on which controls are placed.
             It is usually placed within a frame. It contains minimal extra functionality over and above its parent
             class wx.Window; its main purpose is to be similar in appearance and functionality to a dialog, but with
             the flexibility of having any window as a parent.
            
             Note: if not all characters are being intercepted by your OnKeyDown or OnChar handler, it may be because you are
             using the wx.WindowStyles.TabTraversal style, which grabs some keypresses for use by child controls.</summary>
        </member>
        <member name="M:WX.Panel.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,WX.wxString)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.Create(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.Panel.Create(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,WX.wxString)">
            <summary>Do not forget to use style wx.WindowStyles.TabTraversal if you want this panel to be traversal.</summary>
        </member>
        <member name="M:WX.ScrolledWindow.OnDraw(WX.DC)">
            <summary>
            Called by the default paint event handler to allow the application to define painting behaviour without having to worry about calling <c>DoPrepareDC</c>.
            </summary>
            <remarks>
            Instead of overriding this function you may also just process the paint event in the derived class as usual, 
            but then you will have to call DoPrepareDC() yourself.
            </remarks>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.ScrolledWindow.PrepareDC(WX.DC)" ignoriert -->
        <member name="M:WX.ScrolledWindow.SetScrollbars(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets up vertical and/or horizontal scrollbars.
            </summary>
            <param name="pixelsPerUnitX">Pixels per scroll unit in the horizontal direction.</param>
            <param name="pixelsPerUnitY">Pixels per scroll unit in the vertical direction.</param>
            <param name="noUnitsX">Number of units in the horizontal direction.</param>
            <param name="noUnitsY">Number of units in the vertical direction.</param>
            <remarks>
            The first pair of parameters give the number of pixels per 'scroll step', i.e. amount moved when the up or down scroll arrows are pressed. The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual window.
            
            xPos and yPos optionally specify a position to scroll to immediately.
            
            For example, the following gives a window horizontal and vertical scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000 pixels) in each direction.
            \code
              window-&gt;SetScrollbars(20, 20, 50, 50);
            \endcode
            wxScrolledWindow manages the page size itself, using the current client window size as the page size.
            Note that for more sophisticated scrolling applications, for example where scroll steps may be variable according to the position in the document, it will be necessary to derive a new class from wxWindow, overriding OnSize and adjusting the scrollbars appropriately.
            </remarks>
            <seealso cref="!:SetVirtualSize"/>
        </member>
        <member name="M:WX.ScrolledWindow.SetScrollbars(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets up vertical and/or horizontal scrollbars.
            </summary>
            <param name="pixelsPerUnitX">Pixels per scroll unit in the horizontal direction.</param>
            <param name="pixelsPerUnitY">Pixels per scroll unit in the vertical direction.</param>
            <param name="noUnitsX">Number of units in the horizontal direction.</param>
            <param name="noUnitsY">Number of units in the vertical direction.</param>
            <param name="x">Position to initialize the scrollbars in the horizontal direction, in scroll units.</param>
            <param name="y">Position to initialize the scrollbars in the vertical direction, in scroll units.</param>
            <remarks>
            The first pair of parameters give the number of pixels per 'scroll step', i.e. amount moved when the up or down scroll arrows are pressed. The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual window.
            
            xPos and yPos optionally specify a position to scroll to immediately.
            
            For example, the following gives a window horizontal and vertical scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000 pixels) in each direction.
            \code
              window-&gt;SetScrollbars(20, 20, 50, 50);
            \endcode
            wxScrolledWindow manages the page size itself, using the current client window size as the page size.
            Note that for more sophisticated scrolling applications, for example where scroll steps may be variable according to the position in the document, it will be necessary to derive a new class from wxWindow, overriding OnSize and adjusting the scrollbars appropriately.
            </remarks>
            <seealso cref="!:SetVirtualSize"/>
        </member>
        <member name="M:WX.ScrolledWindow.SetScrollbars(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets up vertical and/or horizontal scrollbars.
            </summary>
            <param name="pixelsPerUnitX">Pixels per scroll unit in the horizontal direction.</param>
            <param name="pixelsPerUnitY">Pixels per scroll unit in the vertical direction.</param>
            <param name="noUnitsX">Number of units in the horizontal direction.</param>
            <param name="noUnitsY">Number of units in the vertical direction.</param>
            <param name="x">Position to initialize the scrollbars in the horizontal direction, in scroll units.</param>
            <param name="y">Position to initialize the scrollbars in the vertical direction, in scroll units.</param>
            <param name="noRefresh">Will not refresh window if true.</param>
            <remarks>
            The first pair of parameters give the number of pixels per 'scroll step', i.e. amount moved when the up or down scroll arrows are pressed. The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual window.
            
            xPos and yPos optionally specify a position to scroll to immediately.
            
            For example, the following gives a window horizontal and vertical scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000 pixels) in each direction.
            \code
              window-&gt;SetScrollbars(20, 20, 50, 50);
            \endcode
            wxScrolledWindow manages the page size itself, using the current client window size as the page size.
            Note that for more sophisticated scrolling applications, for example where scroll steps may be variable according to the position in the document, it will be necessary to derive a new class from wxWindow, overriding OnSize and adjusting the scrollbars appropriately.
            </remarks>
            <seealso cref="!:SetVirtualSize"/>
        </member>
        <member name="M:WX.ScrolledWindow.GetViewStart(System.Int32@,System.Int32@)">
            <summary>Get the position at which the visible portion of the window starts.
             \params x Receives the first visible x position in scroll units.
             \params y Receives the first visible y position in scroll units.
            
             If either of the scrollbars is not at the home position, x and/or y will be greater than zero.
             Combined with wx.Window.ClientSize, the application can use this function to efficiently redraw only the
             visible portion of the window. The positions are in logical scroll units, not pixels, so to convert to pixels
             you will have to multiply by the number of pixels per scroll increment.
             See also wx.ScrolledWindow.SetScrollbars()</summary>
        </member>
        <member name="M:WX.ScrolledWindow.GetScrollPixelsPerUnit(System.Int32@,System.Int32@)">
            <summary>Get the number of pixels per scroll unit (line), in each direction, as set by wx.ScrolledWindow.SetScrollbars().
            A value of zero indicates no scrolling in that direction.
            <list type="table">
            <item><term>xUnit</term><description> Receives the number of pixels per horizontal unit.</description></item>
            <item><term>yUnit</term><description> Receives the number of pixels per vertical unit.</description></item>
            </list>
            
            See also wx.ScrolledWindow.SetScrollbars(), wx.ScrolledWindow.GetVirtualSize()
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.ScrolledWindow.CalcScrolledPosition(System.Int32,System.Int32,System.Int32@,System.Int32@)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.ScrolledWindow.CalcScrolledPosition(System.Drawing.Point)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.ScrolledWindow.CalcUnscrolledPosition(System.Int32,System.Int32,System.Int32@,System.Int32@)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.ScrolledWindow.CalcUnscrolledPosition(System.Drawing.Point)" ignoriert -->
        <member name="M:WX.ScrolledWindow.Scroll(System.Int32,System.Int32)">
            <summary>Scrolls to the designated virtual position in scroll units.</summary>
        </member>
        <member name="M:WX.ScrolledWindow.Scroll(System.Drawing.Point)">
            <summary>Scrolls to the designated virtual position in points.
            This will do the translation via GetScrollPixelsPerUnit() for you.</summary>
        </member>
        <member name="M:WX.ScrolledWindow.SetScrollRate(System.Int32,System.Int32)">
            <summary>
            Set the horizontal and vertical scrolling increment only. See the <c>pixelsPerUnit</c> parameter in <c>SetScrollbars</c>.
            </summary>
            <param name="pixelsPerUnitX">Pixels per scroll unit in the horizontal direction.</param>
            <param name="pixelsPerUnitY">Pixels per scroll unit in the vertical direction.</param>
        </member>
        <member name="M:WX.ScrolledWindow.SetTargetWindow(WX.Window)">
            <summary>
            Call this function to tell wxScrolledWindow to perform the actual scrolling on a different window (and not on itself).
            </summary>
        </member>
        <member name="P:WX.ScrolledWindow.ViewStart">
            <summary>Get the position at which the visible portion of the window starts.
            If either of the scrollbars is not at the home position, x and/or y will be greater than zero.
            Combined with wx.Window.ClientSize, the application can use this function to efficiently redraw only the
            visible portion of the window. The positions are in logical pixels, so this is the result of GetViewStart()
            multiplied by the number of pixels per scroll increment.
            </summary>
        </member>
        <member name="P:WX.ScrolledWindow.ScrollPixelsPerUnit">
            <summary>The result of GetScrollPixelsPerUnit() as size.
            This returns the size of a square defining the scroll unit.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.OnNewPage">
            <summary>This has to be called before changing the displayed HTML page.
            This method increments the version counter and will remove the wrappers
            of the currently displayed page if they don't own their memory.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.RegisterWidgetCell(WX.Html.HtmlWidgetCell)">
            <summary>A .NET wx.HtmlWidgetCell will register itself here.
            Reason: ClearWidgetCells().</summary>
            
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.Html.HtmlWindow.SetInvisibleWidgetCells" ignoriert -->
        <member name="M:WX.Html.HtmlWindow.SetPage(System.String)">
            <summary>This will set a new HTML text to be displayed.</summary>
            <param name="source">The HTML source code that shall be displayed.</param>
        </member>
        <member name="M:WX.Html.HtmlWindow.SetPage(WX.wxString)">
            <summary>This will set a new HTML text to be displayed.</summary>
            <param name="source">The HTML source code that shall be displayed.</param>
        </member>
        <member name="M:WX.Html.HtmlWindow.AppendToPage(System.String)">
            <summary>This will append string <c>source</c> to the currently displayed text.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.AppendToPage(WX.wxString)">
            <summary>This will append string \c source to the currently displayed text.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.OnLoadPageEvent(System.Object,WX.Event)">
            <summary>Call this only on wx.CommandEvent().
            This will load the page URL retrieved from the client string wx.CommandEvent.String.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.LoadPage(System.String)">
            <summary>Overload this to change the behaviour on loading a page from the designated location.
            Refer to FSFile and FileSystemHandler for remarks on available locations.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.LoadPage(WX.wxString)">
            <summary>Overload this to change the behaviour on loading a page from the designated location.
            Refer to FSFile and FileSystemHandler for remarks on available locations.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.LoadFile(System.String)">
            <summary>Overload this to change the behaviour on loading a file.
            The argument is a file name in native style.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.LoadFile(WX.wxString)">
            <summary>Overload this to change the behaviour on loading a file.
            The argument is a file name in native style.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SetRelatedFrame(WX.Frame,System.String)">
            <summary>Sets the related frame.
                       This window will change the title of the related frame according to
                       the title definition of the displayed HTML text.</summary>
                       <remarks>
                       Sample: 
                     <code>
                     m_html.SetRelatedFrame(this, "HTML: %s");
                     </code>
                        This will display the title according to the displayed HTML page plus
                       a prefix "HTML:"
                       </remarks>
        </member>
        <member name="M:WX.Html.HtmlWindow.SetRelatedFrame(WX.Frame,WX.wxString)">
            <summary>Sets the related frame.
                       This window will change the title of the related frame according to
                       the title definition of the displayed HTML text.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.ReadCustomization(WX.Config)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. WriteCustomization().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.ReadCustomization(WX.Config,System.String)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. WriteCustomization().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.ReadCustomization(WX.Config,WX.wxString)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.WriteCustomization(WX.Config)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. ReadCustomization().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.WriteCustomization(WX.Config,System.String)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. ReadCustomization().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.OnCellMouseHover(WX.Html.HtmlCell,System.Int32,System.Int32)">
            <summary>This will be called when the mouse is moved over the cell.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.OnCellClicked(WX.Html.HtmlCell,System.Int32,System.Int32,WX.MouseEvent)">
            <summary>This is called when the user clicks at a particular cell.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.OnLinkClicked(WX.Html.HtmlLinkInfo)">
            <summary>This is called when the user clicks on a cell representing a hyper link.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SelectAll">
            <summary>This will select the whole text.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SelectLine(System.Drawing.Point)">
            <summary>This will select a line in the text.
            Please note, that this method will not scroll to the selected word.
            Call wx.Window.Scroll().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SelectWord(System.Drawing.Point)">
            <summary>This will select a word that is displayed at the provided position.
            Please note, that this method will not scroll to the selected word.
            Call wx.Window.Scroll().</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SelectCell(WX.Html.HtmlCell)">
            <summary>This will select the content of the provided cell.
            Note, that the provided cell may be a formatting cell. So, you might
            see nothing of the selection.
            
            Please also note, that this method will not scroll the window to
            the selected cell. Call ScrollToCell() for this purpose.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.SelectCells(WX.Html.HtmlCell,WX.Html.HtmlCell)">
            <summary>Additional method to select cells.
            <c>fromCell</c> and <c>lastCell</c> may be the same cell. Otherwise,
            leafs of <c>fromCell</c> must be before those of <c>lastCell</c> when traversing
            the HTML document.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.ScrollToCell(WX.Html.HtmlCell)">
            <summary>This will scroll to the position of the provided cell.</summary><remarks>
            Equivalent to \code this.Scroll(cell.AbsPos) \endcode.</remarks>
        </member>
        <member name="M:WX.Html.HtmlWindow.OpenFindDialog(WX.FindReplaceData)">
            <summary>This will open a find dialog for the current HTML page.
            The result will be <c>true</c> in case of success and <c>false</c> in case of any problem.
            This method will fail to open the dialog if it is already open.
            
            Cf. wx.HtmlWindow.FindDialog and HtmlFindDialog.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.OpenedPage">
            <summary>HTML text displayed by this window.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.Version">
            <summary>This will be incremented whenver the displayed document changes.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.RelatedFrame">
            <summary>Set or gets the related frame.
            This window will change the title of the related frame according to
            the title definition of the displayed HTML text.
            This will simply use "%s" as format for the related frame.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InternalRepresentation">
            <summary>Use this to gain access to the internal representation of the displayed HTML text.
            HTML is displayed as a tree of cells where the container cell represends a node
            with occasionally more than one sibling.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.HasSelection">
            <summary>This is true if the window knows a selection.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.SelectionInfo">
            <summary>Returns a new instance providing information in the current selection.
            The result will be <c>null</c> if nothing is selected.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.Text">
            <summary>This is the displayed HTML as text.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.SelectionText">
            <summary>This is the selected part of the HTML</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.FindDialog">
            <summary>This is a new feature explusive to  WX.Net: A search dialog for searching the presented HTML page.
            This will read the dialog and create one if this has not yet been created.
            You may alteratively use ShowFindDialog() to show the dialog with particular data.</summary>
        </member>
        <member name="T:WX.Html.HtmlWindow.InfoOnSelection">
            <summary>This contains detailled information of a selection if there is any.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindow.InfoOnSelection.#ctor(WX.Html.HtmlWindow)">
            <summary>This will read and store the current information on the provided window.
            This will throw an exception if the argument does not have a selection.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.Window">
            <summary>This is the window where the selection has been recorded.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.FromPosition">
            <summary>This will return the position where the current selection starts.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.ToPosition">
            <summary>This will return the position where the current selection ends.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.FromCell">
            <summary>This is the first cell of selected content.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.ToCell">
            <summary>This is the last cell of selected content.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindow.InfoOnSelection.Text">
            <summary>Returns the selected text.</summary>
        </member>
        <member name="T:WX.Html.HtmlTerminalCellIterator">
            <summary>This is a pure .NET 2 implementation iterating over terminal siblings of an wx.HtmlCell.
            You may turn this off defining <c>NET_1_1_ONLY</c> on compilation.
            
            You may increment or decrement the iterator. The iterator will complete a list of all
            terminal cells on demand. Once this list has been created, it will not be maintained. So,
            you probably will encounter problems if you edit cells while iterating thair siblings.
            </summary>
        </member>
        <member name="F:WX.Html.HtmlTerminalCellIterator._currentCellSelection">
            <summary>This will be used if searching for consecutive words to record the text
            content of previously selected cells (wx.FindReplaceFlags.WHOLEWORD).</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.#ctor(WX.Html.HtmlCell)">
            <summary>This will iterate all relevant cells that are siblings of <c>root</c>.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.#ctor(WX.Html.HtmlCell,WX.Html.HtmlCell)">
            <summary>This will iterate all relevant cells that are siblings of <c>root</c> starting  after <c>start</c>.
            The start of iteration is not defined if <c>start</c> is not a sibling of
            <c>root</c>.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.LoadFindString(System.String,WX.FindReplaceFlags@)">
            <summary>Central private method to create an array of words that will be used as a filter for terminal cells.
            Use double quotes to suppress splitting.
            </summary>
            <param name="findFlags"> defines the mode of the search (that might influence normalization
                   of the find string) and will be changed if the find string comprises mode specifications.
                   If the find string is quoted by either single or double quotes, mode will switch to
                   searching for whole words. In that case, the words in the find string do not define
                   alternatives for matching but a sequence of constraints that have to be met.
            </param>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.#ctor(WX.Html.HtmlCell,System.String,WX.FindReplaceFlags)">
            <summary>Enumerates terminal cells below <c>root</c> that comprise text complying with <c>findString</c>.
            The text contents complies with <c>findString</c> if it is a word from <c>findString</c>.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.#ctor(WX.Html.HtmlCell,WX.Html.HtmlCell,System.String,WX.FindReplaceFlags)">
            <summary>Enumerates terminal cells below <c>root</c> starting at position after <c>start</c> that comprise text complying with <c>findString</c>.
            The text contents complies with <c>findString</c> if it is a word from <c>findString</c>.
            
            Refer to the remarks on the CTor defining a start position without a find string for
            details on setting the start position.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.MoveNext">
            <summary>Moves one position forward to the next element.
            This must be called once before reading a current element.
            this will return <c>true</c> iff more elements exist in this direction.</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.Reset">
            <summary>Moves the iterator back to the initial position before the first element or behind the next.</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.SelectCurrent(WX.Html.HtmlWindow)">
            <summary>Selects in the argument according to the currently enumerated selection.
            This iterator enumerated cells but also selections that may comprise more than
            cell. The current cell is always the last cell of this selection. However, if
            this searches for more than one word (searching e.g. for a quoted find string),
            then the resulting selection will comprise also cells preceeding the current.
            This iterator keeps track of this. So, if you want select in the searched dialog
            acording to this iterator, use this method.
            
            Please note: <c>wnd</c> must comprise the root of this document.</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.EquivalentToFindString(System.String,WX.FindReplaceFlags)">
            <summary>This is <c>true</c> iff the argument is equivalent to the currently used find string.</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.MoveBack">
            <summary>Moves back to the previous position.
            If the current position is the initial position, this will move to
            the last terminal cell.
            The result will be <c>true</c> iff more elements exist in this direction.</summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.CompliesWithFindString(System.String)">
            <summary>Use this to test text associated with a HTML cell agains the find string.
            If this iterator does filter according to string input, this is always <c>true</c>.
            
            This method will be used within IsCellRelevant() to test with resp. to a find string.
            You may either reuse this in alternative implementations of IsCellRelevant() or
            you may replace this to implement alternative filters regarding text.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.CompliesWithFindString(System.String[])">
            <summary>Use this to test text associated with a HTML cell agains the find string.
            If this iterator does filter according to string input, this is always <c>true</c>.
            
            This method will be used within IsCellRelevant() to test with resp. to a find string.
            You may either reuse this in alternative implementations of IsCellRelevant() or
            you may replace this to implement alternative filters regarding text.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.IsCellRelevant(System.Collections.Generic.Queue{WX.Html.HtmlCell})">
            <summary>Overload this to implement iterators selecting non-terminal or more specific terminal nodes.
            This method will be asked before selecting a new Current() node on MoveNext() and
            MoveBack(). This must be true for all Current() nodes.
            
            Overload and change this to select different classes of nodes.
            
            Currently, this will select terminal nodes which are not formatting nodes.
            If this iterations defines a find string then this method will also take
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.IsCellRelevant(WX.Html.HtmlCell)">
            <summary>Overload this to implement iterators selecting non-terminal or more specific terminal nodes.
            This method will be asked before selecting a new Current() node on MoveNext() and
            MoveBack(). This must be true for all Current() nodes.
            
            Overload and change this to select different classes of nodes.
            
            Currently, this will select terminal nodes which are not formatting nodes.
            If this iterations defines a find string then this method will also take
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTerminalCellIterator.FindNextNode(WX.Html.HtmlCell)">
            <summary>This method will return the next relevant cell after <c>current</c>.
            You may pass <c>null</c> as an argument. In that case, this will start with
            <c>root</c>.
            This will return <c>null</c> if this cannot find a next relevant cell.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.CallbackProgressReport">
            <summary>Set this if you want a specific function to be called regularly during search.
            This function may terminate the search returning <c>false</c>.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.FindString">
            <summary>The original strings that this dialog shall find.
            You may also set this here.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.NumberOfFoundCells">
            <summary>Returns the number of yet found cells that comply.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.VisitedAllRelevantCells">
            <summary>True iff all relevant cells have been visited at least once.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.FindFlags">
            <summary>These are the flags that will be used for searching the HTML page.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.ListOfCells">
            <summary>This is a list of all cells that will be enumerated by this enumerator.
            \b Do \b not \b modify \b this.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.RelevantCells">
            <summary>The array of relevant cells.</summary>
        </member>
        <member name="P:WX.Html.HtmlTerminalCellIterator.FindStrings">
            <summary>Returns the array of words that this instance uses as a filter.
            This might be <c>null</c>;</summary>
        </member>
        <member name="T:WX.Html.HtmlTerminalCellIterator.DelegateProgressReport">
            <summary>Something of this kind will be called on searching.
            \param current snd <c>end</c> specify a measure for the progress. 
            \param end is the end point for current on completed search. However, if this
                   is negative, progress report is not supported.
            
            You may return <c>false</c> in order to stop searching and <c>true</c> to proceed.</summary>
        </member>
        <member name="T:WX.Html.HtmlFindDialog">
            <summary>This is a dialog supporting finding strings in HTML cells.
            You will normally not create this on your own but use wx.HtmlWindow.OpenFindDialog()
            to open this.</summary>
        </member>
        <member name="T:WX.FindReplaceDialog">
            <summary>wx.FindReplaceDialog is a standard modeless dialog which is used to allow the user to search for some text
            (and possibly replace it with something else).
            The actual searching is supposed to be done in the owner window which is the parent of this
            dialog. Note that it means that unlike for the other standard dialogs this one must have a
            parent window. Also note that there is no way to use this dialog in a modal way; it is
            always, by design and implementation, modeless (non-modal).
            
            The dialog issues a FindDialogEvent if a search has been requested.
            
            Currently only one find dialog is supported. So, if you create them on the fly,
            be sure to place them in <c>using</c> environments to ensure early finalization.</summary>
        </member>
        <member name="M:WX.FindReplaceDialog.#ctor(WX.Window,WX.FindReplaceData,System.String,WX.WindowStyles)">
            <summary>* Use dialog styles here. Specific styles will start with prefix FR_.</summary>
        </member>
        <member name="P:WX.FindReplaceDialog.Data">
            <summary>Use this to change the data model.
            This is virtual to enable implementations extending this dialog which have to react
            on changes in the data model.</summary>
        </member>
        <member name="E:WX.FindReplaceDialog.Find">
            <summary>The unique listener for the "find" event.</summary>
        </member>
        <member name="E:WX.FindReplaceDialog.FindNext">
            <summary>The unique listener for the "find next" event.</summary>
        </member>
        <member name="E:WX.FindReplaceDialog.FindReplace">
            <summary>The unique listener for the "find/replace" event.</summary>
        </member>
        <member name="E:WX.FindReplaceDialog.FindReplaceAll">
            <summary>The unique listener for the "find/replace all" event.</summary>
        </member>
        <member name="M:WX.Html.HtmlFindDialog.DoFind">
            <summary>Act as if [ENTER] has been pressed in the search string control.</summary>
        </member>
        <member name="M:WX.Html.HtmlFindDialog.DoFindNext">
            <summary>Act as if the "find next" button has been pressed.</summary>
        </member>
        <member name="P:WX.Html.HtmlFindDialog.State">
            <summary>True if this dialog is currently searching. 
            If this is <c>true</c>, all further actions will be aborted.</summary>
        </member>
        <member name="F:WX.Html.HtmlWindowWithSearch.TextBgOnError">
            <summary>Background of the search text will switch to this colour if the specified text cannot be found.</summary>
        </member>
        <member name="F:WX.Html.HtmlWindowWithSearch.TextBgOnCompletedSearch">
            <summary>Background of the search text will switch to this colour if all occurances of the search text have been found but the search can be restarted.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.#ctor">
            <summary>This is for two step construction.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.CreateHtmlWindow">
            <summary>You may overload this if you want to have a specialization of this class dealing with specific HTML windows.
            The result mus have <c>this</c> as parent.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.Bell">
            <summary>This is the bell on error or completed search.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.ShowSearchPanel(System.Boolean)">
            <summary>This will show or hide the search panel.
            Run with <c>true</c> to show and with <c>false</c> to hide the search panel.
            
            This will initialize the search text with the current selection of
            the search panel becomes visible because of this method call.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.ShowSearchPanel(System.Boolean,System.Boolean)">
            <summary>This will show or hide the search panel.
            Run with <c>true</c> to show and with <c>false</c> to hide the search panel.
            \param pickCurrentSelection will cause this method with <c>true</c> to initialize
                   the search text with the current selection.</summary>
        </member>
        <member name="M:WX.Html.HtmlWindowWithSearch.ToggleSearchPanel">
            <summary>Changes visibility of the internal search panel.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindowWithSearch.Html">
            <summary>This is the encapsulated HTML window.</summary>
        </member>
        <member name="P:WX.Html.HtmlWindowWithSearch.IsSearchPanelShown">
            <summary>True iff the integrated search panel is shown.</summary>
        </member>
        <member name="T:WX.Html.HtmlFontCell">
            <summary>A wx.HtmlCell containing font information.</summary>
        </member>
        <member name="T:WX.Html.HtmlCell">
            <summary>Internal representation of HTML in a wx.HtmlWindow.
            HTML is represented as a tree of nodes, the so-called cells.
            The framework uses several classes of nodes.
            
            Please note, that the current implementation might not call all virtual methods.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.wxHtmlCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="F:WX.Html.HtmlCell._siblings">
            <summary>This will hold all wrappers of siblings if this is a root node.
            DisposeAllNonOwners() depends on this.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.RelativePos(WX.Html.HtmlCell)">
            <summary>This returns the position of this cell relative to the argument.
            The argument shall be a parent or a parent of the parent etc.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.GetTextUpToLength(System.Int32)">
            <summary>This will load all texts from this node or the children up to the maximum length.
            Words will be separated by a single blank.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.IsBefore(WX.Html.HtmlCell)">
            <summary>Returns true if the cell appears before 'cell' in natural order of cells (as they are read).
             If cell A is (grand)parent of cell B, then both A.IsBefore(B) and B.IsBefore(A)
             returns true.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlCell.SetPos(System.Int32,System.Int32)">
            <summary>Deprecated: Use property <c>pos</c>.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.Html.HtmlCell.Draw(WX.DC,System.Int32,System.Int32,System.Int32,System.Int32)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.Html.HtmlCell.Draw(WX.DC,System.Int32,System.Int32,System.Int32,System.Int32,WX.Html.HtmlRenderingInfo)" ignoriert -->
        <member name="M:WX.Html.HtmlCell.Find(WX.Html.HtmlCond,System.String)">
            <summary>This method returns the first cell complying with the designated condition referring to the provided string.</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.Find(WX.Html.HtmlCond,WX.Object)">
            <summary>This method returns a pointer to the FIRST cell for that the condition is true.</summary>
                     * <remarks>
                     * It first checks if the condition is true for this
                     * cell and then calls the next ones. (Note: it checks
                     * all subcells if the cell is container).
                     * Condition is unique condition identifier (see htmldefs.h)
                     * (user-defined condition IDs should start from 10000)
                     * and param is optional parameter
                     * Example:
                     * \code
                     cell.Find(HtmlCond.IS_ANCHOR, "news");
                     \endcode
                     * returns pointer to anchor news.
                     * </remarks>
        </member>
        <member name="M:WX.Html.HtmlCell.FindCellByPos(System.Drawing.Point)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.FindCellByPos(System.Int32,System.Int32)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.FindCellByPos(System.Drawing.Point,WX.Html.HtmlFind)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:WX.Html.HtmlCell.FindCellByPos(System.Int32,System.Int32,WX.Html.HtmlFind)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.PosX">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.PosY">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.Pos">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.AbsPos">
            <summary>This returns the absolute position of the cell relative to the root.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.FirstChild">
            <summary>First cell that is part of this node.
            Follow the HtmlCell.Next() cells to enumerate all direct siblings of this node.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.FirstTerminal">
            <summary>First terminal cell below.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.LastTerminal">
            <summary>Last terminal cell below.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.Text">
            <summary>The contained text.</summary>
        </member>
        <member name="P:WX.Html.HtmlCell.Link">
            <summary>Get or set the information on contained hyper link.
            Note, that this infor may be <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlFontCell.wxHtmlFontCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Html.HtmlFontCell.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.Html.HtmlColourCell">
            <summary>A wx.HtmlCell containing colour information.</summary>
        </member>
        <member name="M:WX.Html.HtmlColourCell.wxHtmlColourCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Html.HtmlColourCell.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.Html.HtmlWidgetCell">
            <summary>The wrapper for the <c>wxHtmlWidgetCell</c> of  wxWidgets.
            Please note, that the  WX.Net system uses a specialization of <c>wxHtmlWidgetCell</c>
            that contains some fixes.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlWordCell.wxHtmlWordCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Html.HtmlWordCell.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.Html.HtmlContainerCell">
            <summary>Internal representation of HTML in a wx.HtmlWindow.
            HTML is represented as a tree of nodes, the so-called cells.
            The framework uses several classes of nodes. This class represends a node that
            occasionally has more than one sibling.
            
            Please note, that the current implementation might not call all virtual methods.
            
            Note, that the HtmlCell.Next cell is the next cell of the HtmlCell.Parent.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlContainerCell.wxHtmlContainerCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:WX.Html.HtmlContainerCell.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Html.HtmlTag.GetParamAsColour(System.String,WX.Colour)">
            <summary>
            Reads a parameter of the tag as colour.
            </summary>
            <param name="par">The name of the parameter to read.</param>
            <param name="clr">If the tag defines this parameter, the result will be assigned to this.</param>
            <returns>True on success, false on failure.</returns>
        </member>
        <member name="M:WX.Html.HtmlTag.GetParamAsInt(System.String,System.Int32@)">
            <summary>
            Reads a parameter of the tag as integer.
            </summary>
            <param name="par">The name of the parameter to read.</param>
            <param name="clr">If the tag defines this parameter, the result will be assigned to this.</param>
            <returns>True on success, false on failure.</returns>
        </member>
        <member name="M:WX.Html.HtmlParser.FindObject(System.IntPtr)">
            <summary>A virtual construction of a  WX.Net parser object from a pointer to a  wxWidgets parser object.
            Use this method to ensure existance of an appropriate wrapper for a HTML parser object.
            Problem:  wxWidgets knows 2 classes: The general <c>wxHtmlParser</c> and the <c>wxHtmlWinParser</c>.
            This will return (and create of not existing) an instance of wx.HtmlWinParser iff the
            argument is a pointer to a <c>wxHtmlWinParser</c> instance. This method will use the internal
            run time type information built into  wxWidgets.
            
            Consider this as a specialization of method wx.Object.FindObject().
            
            <c>IntPtr.Zero</c> will always result into <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlParser.FS">
            <summary>.NET form of <c>wxHtmlParser</c>::GetFS() and <c>wxHtmlParser</c>::SetFS().
            Please note, on setting the file system of the parser: The HTML parser
            will take control of the native C++ instance that is wrapped by assigned
            instance of wx.FileSystem. So, the .NET wrapper must have memory ownership of
            instances, that will be assigned to this property. Otherwise, this will raise
            an exception.</summary>
        </member>
        <member name="T:WX.Html.HtmlTagHandler">
            <summary>Overload this and add this to an HtmlParser to define new tags.
            The typical use of tag handlers is the definition of new tags that designate
            forms which have been implemented as  wxWidgets panels. Refer to wx.HtmlHelpFrame.OnAboutBox()
            for a simple example.
            
            Refer to HtmlButtonTagHandler for a tag presenting a button that raises a CommandEvent.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlTagHandler.GetSupportedTags">
            <summary>Use this to define the tags that this handler implements.
            Return a comma-separated list of tag names like "I,B,FONT,P".
            
            Please note, that in contrast to modern XML-compatible conventions  wxWidgets 
            uses upper case letters as standard form for tag names. For this reason,  WX.Net
            will convert th result of this method automatically into upper case form. However,
            analogous code in C++ will probably not run with the original  wxWidgets in C++ if
            this result contains lower case letters.</summary>
        </member>
        <member name="M:WX.Html.HtmlTagHandler.HandleTag(WX.Html.HtmlTag)">
            <summary>Implement the tags as defined by GetSupportedTags().</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Html.HtmlButtonTagHandler" ignoriert -->
        <member name="M:WX.Html.HtmlButtonTagHandler.GetSupportedTags">
            <summary> Handler for HTML tag "WXBUTTON".
            Please note, that in contrast to modern XML-compatible conventions wxWidgets 
            uses upper case letters as standard form for tag names. So, use upper class letters
            here exclusively.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlButtonTagHandler.HandleTag(WX.Html.HtmlTag)">
            <summary>This generates a window with a single button to be placed into the HTML page.
            Return value is false to enable inner parsing.</summary>
        </member>
        <member name="T:WX.Html.HtmlButtonTagHandler.CmdClosure">
            <summary>This contains the <c>eventstr</c> if one is specified and this implements the addition of the event string to the event.</summary>
        </member>
        <member name="M:WX.Html.HtmlButtonTagHandler.CmdClosure.OnButtonSelect(System.Object,WX.Event)">
            <summary>This will complete the button event if an event string has been specified by the hyperlink.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Html.HtmlOptionTagHandler" ignoriert -->
        <member name="M:WX.Html.HtmlOptionTagHandler.GetSupportedTags">
            <summary> Handler for HTML tag "WXOPTION".
            </summary>
        </member>
        <member name="M:WX.Html.HtmlOptionTagHandler.HandleTag(WX.Html.HtmlTag)">
            <summary>This generates a window with a check box to be placed into the HTML page.
            Return value is false to enable inner parsing.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Html.HtmlImageListHandler" ignoriert -->
        <member name="M:WX.Html.HtmlImageListHandler.#ctor(System.String,WX.ImageList)">
            <summary>
            Creates a handler providing the tag &lt;tagname index=&gt; to display images from the
            provided image list.
            </summary>
            <param name="tagname">The name if the tag.</param>
            <param name="images">The images to be displayed.</param>
        </member>
        <member name="M:WX.Html.HtmlImageListHandler.GetSupportedTags">
            <summary>
            The name that has been passed to the CTOR of the handler.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Html.HtmlImageListHandler.Images">
            <summary>
            The image list.
            </summary>
        </member>
        <member name="T:WX.Html.HtmlArtProviderTagHandler">
            <summary>Tag presenting a bitmap from an art provider.</summary>
            <remarks>
            Tag is WXART, legal attributes are 
            <list type="table">
            <item><term> ARTID</term><description> with a string describing an art id as argument. The string will be passed to
                the parser of enumeration wx.ArtID. For compatibility reasons, a trailing "wxArt_" and all underscores will be removed from
                the tag value before parsing. Example: Value "wxART_CROSS_MARK" will be converted to
                "CROSSMARK" that will be parsed to wx.ArtID.CrossMark. However, you may also
                pass "CrossMark" directly as attribute or a number representing the index
                of the art work.
                This attribute is mandatory.
                </description></item>
            <item><term> WIDTH</term><description> is a number providing the desired size in X direction.</description></item>
            <item><term> HEIGHT</term><description> is a number providing the desired size in Y direction.</description></item>
            <item><term> CLIENT</term><description> is analog to ARTID a string describing an element of wx.ArtClient with our without prefix.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:WX.Html.HtmlArtProviderTagHandler.GetSupportedTags">
            <summary>"WXART"</summary>
        </member>
        <member name="M:WX.Html.HtmlArtProviderTagHandler.HandleTag(WX.Html.HtmlTag)">
            <summary>This generates a window presenting an image of the specified size.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Html.HtmlChoiceTagHandler" ignoriert -->
        <member name="M:WX.Html.HtmlChoiceTagHandler.#ctor(WX.Html.HtmlChoiceTagHandler.Style,System.String,System.Drawing.Size,System.Int32)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
            <param name="id">The window id of the choice dialog. This may be overridden by attribute ID.</param>
            <param name="size">The size of the control in pixel.</param>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.#ctor(WX.Html.HtmlChoiceTagHandler.Style,System.String,System.Int32)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
            <param name="id">The window id of the choice dialog. This may be overridden by attribute ID.</param>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.#ctor(WX.Html.HtmlChoiceTagHandler.Style,System.String)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.Append(System.String)">
            <summary>Adds an item to the control without any command associated.</summary>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.Append(System.String,System.Int32)">
            <summary>Add an item to the control.
             Selecting the item will cause a command event that may be processed in surrounding
             windows.
            </summary>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.Append(System.String,System.String)">
            <summary>Add an item to the control loading a URL on selection.</summary>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.Append(System.String,System.Object)">
            <summary>
            this creates a choice with attached client data.
            </summary>
            <param name="item">The name of the item.</param>
            <param name="clientdata">The client data.</param>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.FindItem(System.String)">
            <summary>Find the provided item string and return its index on success or -1 otherwise.</summary>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.FindCmd(System.Int32)">
            <summary>Find the first item of the provided command ID and return its index on success or -1 otherwise.
            Items are often subject of localization/translation. A neutral designator for
            selecting item is a representation of the action issued by the item. Therefore,
            this method enables a user to select an item issueing a certain command.</summary>
        </member>
        <member name="M:WX.Html.HtmlChoiceTagHandler.FindHyperref(System.String)">
            <summary>Find the first item of the provided hyperref and return its index on success or -1 otherwise.
            Items are often subject of localization/translation. A neutral designator for
            selecting item is a representation of the action issued by the item. Therefore,
            this method enables a user to select an item issueing a new page to be displayed.</summary>
        </member>
        <member name="P:WX.Html.HtmlChoiceTagHandler.SelectionString">
            <summary>Returns or sets the label of the selected item.
            This is an empty string if nothing is selected.
            Please refer to SelectCmd() and SelectHyperref() for alternative methods
            of selecting items.
            
            Assignments trying to select an unknown item will be ignored silently.
            Refer to SelectItem() for an alternative method.</summary>
        </member>
        <member name="T:WX.Html.HtmlTextFieldTagHandler">
            <summary>This tag handler will produce a text field in wxHTML pages using the wx.TextCtrl.</summary>
            <remarks>
            Add an instance of this to the tag handlers of an HTML parser before use:
            <code>
            wx.Html.HtmlWindow html = new wx.Html.HtmlWindow(this);
            html.Parser.AddTagHandler(new wx.Html.HtmlTextFieldTagHandler());
            </code>
            From this code on, <c>html.Parser</c> will understand the tag "WXTEXT"
            with the following parameters:
            <list type="table">
            <listheader><term>Parameter</term><description>Effect</description></listheader>
            <item><term>text</term><description>Provides the default text that will be displayed before the user put something in.</description></item>
            <item><term>id</term><description>A positive integer - the id of the created text window.</description></item>
            <item><term>width</term><description>Specifies the width in pixels</description></item>
            <item><term>height</term><description>Specifies the height in pixels</description></item>
            <item><term>styles</term><description>Is a comma-separated list of style names (like <c>TextCtrlMultiline</c> or <c>TE_PASSWORD</c>) that will be used to create the window.
            Additional styles: DIRECTORY or DIRECTORY_LIST. These styles will add a button that will open a directory selector.
            </description></item>
            <item><term>fgcolor</term><description>The foreground (text) color in HTML notation</description></item>
            <item><term>bgcolor</term><description>The background color in HTML notation.</description></item>
            </list>
            Please note, that the tag handler may raise EVT_TEXT() events (class wx.CommantEvent) with empty
            string on startup. 
            In contrast to the standard bahaviour of the wx.TextCtrl, the control used by this tag handler
            will also raise a EVT_TEXT_ENTER event on loosing the focus. Unfortunately, you may encounter
            unexpected senders. The sender will be determined according to the C++ interface to the wxWidgets
            system - the class that implements the used event table.
            </remarks>
        </member>
        <member name="M:WX.Html.HtmlTextFieldTagHandler.OnLeave(System.Object,WX.Event)">
            <summary>
            This will be called on the EVT_LEAVE_WINDOW event of the created text window and will send
            a Event.wxEVT_COMMAND_TEXT_ENTER
            </summary>
            <param name="sender"></param>
            <param name="evt"></param>
        </member>
        <member name="M:WX.Html.HtmlTextFieldTagHandler.OnAskForDirectories(System.Object,WX.Event)">
            <summary>
            Will be called on pressing the button and opening the directory selector.
            </summary>
            <param name="sender">This should be the button for opening the directory selector.</param>
            <param name="evt"></param>
        </member>
        <member name="T:WX.Html.HtmlLinkEvent">
            <summary>
            This event class is used for the events generated by wxHtmlWindow.
            </summary>
            <remarks>
            To process input from a HtmlLinkEvent, use one of these event handler macros to direct input to member function that take a wxHtmlLinkEvent argument:
            <list type="table">
            <item><term>EvtHtmlLinkClicked(id, func)</term> <description>User clicked on an hyperlink.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:WX.Html.HtmlLinkEvent.#ctor(System.IntPtr)">
            <summary>
            For internal purposes only.
            </summary>
            <param name="self">Pointer to a native C++ instance of this event.</param>
        </member>
        <member name="P:WX.Html.HtmlLinkEvent.LinkInfo">
            <summary>
            Returns the wx.HtmlLinkInfo which contains info about the cell clicked and the hyperlink it contains.
            </summary>
        </member>
        <member name="T:WX.Html.HtmlCellEvent">
            <summary>
            This event class is used for the events generated by wxHtmlWindow.
            </summary>
            <remarks>
            To process input from a wxHtmlCellEvent, use one of these event
            handler macros to direct input to member function that take a
            wx.HtmlCellEvent argument:
            <list type="table">
            <item><term>EVT_HTML_CELL_HOVER(id, func)</term> <description> User moved the mouse over a wxHtmlCell.</description></item>  
            <item><term>EVT_HTML_CELL_CLICKED(id, func)</term> <description> User clicked on a wxHtmlCell. When handling this event, remember to use wxHtmlCell::SetLinkClicked(true) if the cell contains a link. </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:WX.Html.HtmlCellEvent.#ctor(System.IntPtr)">
            <summary>
            For internal purposes only.
            </summary>
            <param name="self">Pointer to a native C++ instance of this event.</param>
        </member>
        <member name="P:WX.Html.HtmlCellEvent.Cell">
            <summary>
            Returns the HtmlCell associated with the event.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlCellEvent.X">
            <summary>
            The X coordinate of the point associated with this event.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlCellEvent.Y">
            <summary>
            The Y coordinate of the point associated with this event.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlCellEvent.Point">
            <summary>
            The point associated with this event.
            </summary>
        </member>
        <member name="P:WX.Html.HtmlCellEvent.LinkClicked">
            <summary>
            Get or set the indicator whether this event has been caused by a click on a cell.
            </summary>
            <remarks>
            Set this to true if the cell which has been clicked contained a link or
            false otherwise (which is the default). With this function the
            event handler can return info to the wx.HtmlWindow which sent the
            event.
            </remarks>
        </member>
        <member name="T:WX.Graph.IGraph`1">
            <summary>
            Methods of graphs that can be provided without references to internal representations.
            </summary>
        </member>
        <member name="M:WX.Graph.IGraph`1.GetEdgesFromNode(System.Int32)">
            <summary>
            Returns a collection of that nodes A (designated by their IDs) where there is an arc from A to
            the node designated by <c>nodeId</c>.
            </summary>
            <param name="nodeId">The node that is the target of the selected edges</param>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.IGraph`1.GetEdgesToNode(System.Int32)">
            <summary>
            Returns a collection of that nodes A (designated by their IDs) where there is an edge from the
            node designated by <c>nodeId</c> to A.
            </summary>
            <param name="nodeId">The node that is the target of the selected edges</param>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.IGraph`1.GetDataOfNode(System.Int32)">
            <summary>
            This will return the data that is associated with the graph node of the provided ID.
            </summary>
            <param name="nodeId">designates the graph node whose data will be returned.</param>
            <returns></returns>
        </member>
        <member name="P:WX.Graph.IGraph`1.NodeIds">
            <summary>
            Collection of node IDs.
            </summary>
        </member>
        <member name="P:WX.Graph.IGraph`1.Arcs">
            <summary>
            A collection of tuples of integers that represent the arcs between the nodes.
            The integers are node IDs.
            </summary>
        </member>
        <member name="T:WX.Graph.GraphNode`1">
            <summary>
            Represents a node in a graph.
            Please note, that instances can at most be part of exactly one graph.
            </summary>
        </member>
        <member name="M:WX.Graph.GraphNode`1.#ctor(`0)">
            <summary>
            Creates a new node of a unique ID associated with the provided data.
            </summary>
            <param name="data">The data of the new node.</param>
        </member>
        <member name="M:WX.Graph.GraphNode`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Graph.GraphNode`1.Id">
            <summary>
            A unique identifier of the node.
            </summary>
        </member>
        <member name="P:WX.Graph.GraphNode`1.LevelFromStart">
            <summary>
            This is exactly one more than the largest LevelFromStart of a predecessor node.
            </summary>
        </member>
        <member name="P:WX.Graph.GraphNode`1.LevelFromEnd">
            <summary>
            This is exactly on more than the largest LevelFromEnd of a successor node.
            </summary>
        </member>
        <member name="P:WX.Graph.GraphNode`1.Data">
            <summary>
            The data associated with this node.
            </summary>
        </member>
        <member name="P:WX.Graph.GraphNode`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="T:WX.Graph.GraphEdge`1">
            <summary>
            Directed edge from one node to another.
            Please not that edges between the same nodes are equal.
            If edges bears data, two edges are usually equal if the from node, the to node, and the data are equal.
            </summary>
        </member>
        <member name="M:WX.Graph.GraphEdge`1.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.GraphEdge`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Graph.GraphEdge`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="T:WX.Graph.DirectedGraph`1">
            <summary>
            Represents a graph, a collection of nodes and edges.
            </summary>
        </member>
        <member name="M:WX.Graph.DirectedGraph`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.DirectedGraph`1.Add(WX.Graph.GraphNode{`0})">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="newNode">The new node.</param>
            <exception cref="T:WX.CannotChangeReadonly">Will be thrown iff this is readonly.</exception>
            <exception cref="T:System.ArgumentException">Will be thrown iff the new node has already been added to another graph.</exception>
        </member>
        <member name="M:WX.Graph.DirectedGraph`1.Add(WX.Graph.GraphEdge{`0})">
            <summary>
            Adds a new edge to the graph. The nodes will be added to the this graph of they are not already
            parts of the graph.
            </summary>
            <param name="edge">The new edge (between two nodes).</param>
            <exception cref="T:WX.CannotChangeReadonly">Will be raised if this is readonly.</exception>
            <exception cref="T:System.ArgumentException">Will be raised if the nodes of the edge are already part of another
            graph.</exception>
        </member>
        <member name="P:WX.Graph.DirectedGraph`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="P:WX.Graph.DirectedGraph`1.NodeIds">
            <summary>
            Collection of node IDs.
            </summary>
        </member>
        <member name="P:WX.Graph.DirectedGraph`1.Arcs">
            <summary>
            A collection of tuples of integers that represent the edges between the nodes.
            The integers are node IDs.
            </summary>
        </member>
        <member name="M:WX.Graph.TreeNode`1.#ctor(`0)">
            <summary>
            Creates an instance with the provided data.
            </summary>
            <param name="data">The data that will be associated with the new node.</param>
        </member>
        <member name="M:WX.Graph.TreeNode`1.#ctor(WX.Graph.TreeNode{`0})">
            <summary>
            Creates a deep copy of the argument and its children that is NOT readonly.
            </summary>
            <param name="src">A subtree.</param>
        </member>
        <member name="M:WX.Graph.TreeNode`1.GetChild(System.Int32)">
            <summary>
            Returns a particular child node.
            </summary>
            <param name="id">The ID of the desired child.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Will be raised of none of the children of this code has the specified id.</exception>
            <returns></returns>
            <seealso cref="M:WX.Graph.TreeNode`1.HasChild(System.Int32)"/>
        </member>
        <member name="M:WX.Graph.TreeNode`1.HasChild(System.Int32)">
            <summary>
            True iff this node has a child of the provided ID.
            </summary>
            <param name="id">ID of a potential child.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.TreeNode`1.Add(WX.Graph.TreeNode{`0})">
            <summary>
            Adds a child to the node. Preconditions: This must not be read-only. Thsi must be a part of
            a tree. The new node must not be part of a tree.
            </summary>
            <param name="newChild">The new child node</param>
            <exception cref="T:System.ArgumentException">This is not part of a tree or the new node
            is already a part of a tree.</exception>
            <exception cref="T:WX.CannotChangeReadonly">If this is read-only.</exception>
        </member>
        <member name="M:WX.Graph.TreeNode`1.CollectNodes(System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Adds this tree node and all siblings to the argument.
            </summary>
            <param name="collector">Collection that will be extended by tree node IDs.</param>
        </member>
        <member name="M:WX.Graph.TreeNode`1.CollectArcs(System.Collections.Generic.ICollection{System.Int32[]})">
            <summary>
            Collects the arcs between tree nodes. Adds tuples of the form (parent ID, child ID) to the argument.
            </summary>
            <param name="collector">List that will be loaded.</param>
        </member>
        <member name="M:WX.Graph.TreeNode`1.Find(System.Int32)">
            <summary>
            Returns the tree node if the ID as defined by the argument.
            The result is <c>null</c> if neither this node nor one of its siblings
            bear this ID.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.TreeNode`1.Clone">
            <summary>
            Returns a deep copy of this.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Graph.TreeNode`1.Id">
            <summary>
            The ID of the node.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.Parent">
            <summary>
            The parent of this node. This is <c>null</c> if this is a root or this is not part of a tree.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.ParentId">
            <summary>
            this is the ID of the parent.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.ChildrenIds">
            <summary>
            Collection of children.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.ChildrenCount">
            <summary>
            The number of children.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.Data">
            <summary>
            Get or set the data that is associated with this node.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.IsRoot">
            <summary>
            True iff this is the root node of a tree.
            </summary>
        </member>
        <member name="P:WX.Graph.TreeNode`1.IsInTree">
            <summary>
            True iff this is part of a tree.
            </summary>
        </member>
        <member name="M:WX.Graph.Tree`1.SetRoot(WX.Graph.TreeNode{`0})">
            <summary>
            Sets the argument as a new root node.
            </summary>
            <param name="newRoot">The node that shall be the root node.</param>
            <exception cref="T:WX.CannotChangeReadonly">Will be thrown if this is read-only.</exception>
            <exception cref="T:System.ArgumentException">If the argument is already part of a tree.</exception>
        </member>
        <member name="P:WX.Graph.Tree`1.Root">
            <summary>
            This is the root node of the tree. This is <c>null</c> if the tree is empty.
            </summary>
        </member>
        <member name="T:WX.ArtID">
            <summary>The elements of this enumeration are used in wx.ArtProvider to designate requested bitmaps.
            If you are viewing this with the <c>helpview.exe</c> tool, then <a href="helpview:artprovider.html">this
            provides a table of the contained bitmaps</a>.</summary>
        </member>
        <member name="T:WX.ArtClient">
            <summary>Elements of this enumerations will be used in wx.ArtProvider to describe the client of a request for a bitmap.</summary>
        </member>
        <member name="T:WX.ArtProvider">
            <summary>This class provides some bitmaps (cf. to wx.ArtID).</summary>
        </member>
        <member name="T:WX.App">
            <summary>The wxApp class represents the application itself.
            It is used to:
            <list type="bullet">
            <item> set and get application-wide properties; </item>
            <item> implement the windowing system message or event loop; </item>
            <item> initiate application processing via wxApp.OnInit();</item>
            <item> allow default processing of events not handled by other objects in the application. </item> 
            </list>
            </summary>
        </member>
        <member name="M:WX.App.GetLastOSError">
            <summary>
            This method is a helper for platform specific diagnostics.
            The method will return an error code directly from the operating system or other
            platform specific software. The resulting code is platform specific but 0 is guaranteed
            to mean "no error" or "this function is not supported".
            
            The currently only supported platform is MS WINDOWS, where this return 
            <c>GetLastError()</c>.
            </summary>
            <returns>Error code or 0 if not error or not supported.</returns>
        </member>
        <member name="M:WX.App.OnInit">
            <summary>This must be provided by the application, and will usually create the application's main window, optionally calling wx.App.SetTopWindow.
             You may use wx.App.OnExit to clean up anything initialized here, provided that the function
             returns true.
            
             Notice that if you want to to use the command line processing provided by wxWidgets you have
             to call the base class version in the derived class OnInit().
             
             Please note, that the <c>STAThreadAttribute</c> shall be set in threads running this. wxWidgets as well as 
             .NET will conduct OLE initialization and these initializations must be done consistently.
            </summary>
             <returns>
             Return true to continue processing, false to exit the application immediately
             </returns>
        </member>
        <member name="M:WX.App.OnExceptionInMainLoop">
            <summary>This function is called if an unhandled exception occurs inside the main application event loop.
             It can return true to ignore the exception and to continue running the loop or false to exit the
             loop and terminate the program. \b Warning: Do not throw an exception here.
            
             The default behaviour of this function is the latter in all ports except under Windows where
             a dialog is shown to the user which allows him to choose between the different options.
             You may override this function in your class to do something more appropriate.
             </summary>
        </member>
        <member name="M:WX.App.OnExit">
            <summary>Override this member function for any processing which needs to be done as the application is about to exit.
             OnExit() is called after destroying all application windows and controls, but before
             wxWidgets cleanup. Note that it is not called at all if OnInit() failed.
            
             The return value of this function is currently ignored, return the same value as returned
             by the base class method if you override it.
             </summary>
        </member>
        <member name="M:WX.App.OnFatalException">
            <summary>This function may be called if something fatal happens: an unhandled exception under Win32 or a a fatal signal under Unix, for example.
             However, this will not happen by default: you have to explicitly call
             SetHandleFatalExceptions() to enable this.
            
             Generally speaking, this function should only show a message to the user and return.
             You may attempt to save unsaved data but this is not guaranteed to work and, in fact,
             probably won't.
             
             The standard implementation does nothing.
             </summary>
        </member>
        <member name="M:WX.App.SetHandleFatalException(System.Boolean)">
            <summary>Enable callback on fatal exceptions.
            Refer to OnFatalException().</summary>
        </member>
        <member name="M:WX.App.SafeYield">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
            Returns the result of the call to wx.App.Yield().
            </summary>
        </member>
        <member name="M:WX.App.SafeYield(WX.Window)">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
             If win is not NULL, this window will remain enabled, allowing the implementation
             of some limited user interaction.
            </summary>
            <returns>
             Returns the result of the call to wx.App.Yield().
             </returns>
             <param name="win">A top level window that will remain enabled or <c>null</c>.</param>
        </member>
        <member name="M:WX.App.SafeYield(WX.Window,System.Boolean)">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
             If win is not NULL, this window will remain enabled, allowing the implementation
             of some limited user interaction.
            </summary>
            <returns>
             Returns the result of the call to wx.App.Yield().
            </returns>
             <param name="win">A top level window that will remain enabled or <c>null</c>.</param>
        </member>
        <member name="M:WX.App.Yield">
            <summary>cf. Yield(bool).</summary>
        </member>
        <member name="M:WX.App.Yield(System.Boolean)">
            <summary>Yields control to pending messages in the windowing system.
             This can be useful, for example, when a time-consuming process writes to
             a text window. Without an occasional yield, the text window will not be
             updated properly, and on systems with cooperative multitasking, such as
             Windows 3.1 other processes will not respond.
            
             Caution should be exercised, however, since yielding may allow the user to
             perform actions which are not compatible with the current task. Disabling
             menu items or whole menus during processing can avoid unwanted reentrance
             of code: see wx.App.SafeYield for a better function.
            
             Note that Yield() will not flush the message logs. This is intentional as
             calling Yield() is usually done to quickly update the screen and popping up
             a message box dialog may be undesirable. If you do wish to flush the log
             messages immediately (otherwise it will be done during the next idle loop
             iteration), call wx.Log.FlushActive.
            
             Calling Yield() recursively is normally an error and an assert failure is
             raised in debug build if such situation is detected. However if the
             <c>onlyIfNeeded</c> parameter is true, the method will just silently return
             false instead.
             </summary>
        </member>
        <member name="P:WX.App.TheApp">
            <summary>Returns the application instance.</summary>
        </member>
        <member name="E:WX.App.OnExitEvent">
            <summary>This will be called in the standard implementation of OnExit() before closing down the application.</summary>
        </member>
        <member name="P:WX.App.IsActive">
            <summary>Returns true if the application is active, i.e. if one of its windows is currently in the foreground. </summary>
        </member>
        <member name="P:WX.App.IsMainLoopRunning">
            <summary>Returns true if the main event loop is currently running, i.e. if the application is initialized and runs.
            
             This can be useful to test whether the events can be dispatched. For example, if this
             function returns false, non-blocking sockets cannot be used because the events from them
             would never be processed.
             </summary>
        </member>
        <member name="P:WX.App.VendorName">
            <summary>
            Name of the vendor.
            Will be used e.g. in the hierarchy of the Windows registry entries.
            </summary>
        </member>
        <member name="P:WX.App.AppName">
            <summary>
            Get or set the name of the application.
            Will be used e.g. to create keys in the hierarchy of registry entries.
            </summary>
        </member>
        <member name="M:WX.VListBox.GetEnumerator">
            <summary>This returns a new instance of EnumerateSelections on this list box.</summary>
        </member>
        <member name="T:WX.VListBox.EnumerateSelections">
            <summary>This will enumerate all selections in the argument list passed to the constructor.
            This is more convenient and comprehensable than using the original calls to
            GetFirstSelected()/GetNextSelected().</summary>
        </member>
        <member name="P:WX.VListBox.EnumerateSelections.Cookie">
            <summary>To whom it may concern.
            This is the cookie used for reading the selections. Nothing users need to know.</summary>
        </member>
        <member name="M:WX.DatePickerCtrl.#ctor(System.IntPtr)">
            <summary>CTor for internal use only.</summary>
        </member>
        <member name="M:WX.DatePickerCtrl.#ctor">
            <summary>CTor for 2 step construction.
            Use create to provide the control with data.</summary>
        </member>
        <member name="P:WX.DatePickerCtrl.Range">
            <summary>Constraint on the allowed values.</summary>
        </member>
        <member name="T:WX.DateEvent">
            <summary>This event class holds information about a date change and is used together with wx.DatePickerCtrl.
            It also serves as a base class for wx.CalendarEvent.</summary>
        </member>
        <member name="P:WX.PickerBase.IsPickerCtrlGrowable">
            <summary>True if the picker grows with the control.</summary>
        </member>
        <member name="P:WX.PickerBase.IsTextCtrlGrowable">
            <summary>True if the contained text control grows with the whole control.</summary>
        </member>
        <member name="P:WX.PickerBase.TextCtrlProportion">
            <summary>Read or set the text control's proportion.</summary>
        </member>
        <member name="P:WX.PickerBase.PickerCtrlProportion">
            <summary>Read or set the picker control's proportion.</summary>
        </member>
        <member name="P:WX.PickerBase.HasTextCtrl">
            <summary>True iff this shows a text control.</summary>
        </member>
        <member name="P:WX.PickerBase.TextCtrl">
            <summary>Reads the text control. 
            This is <c>null</c> if this does not show a text control.</summary>
        </member>
        <member name="T:WX.ColourPickerCtrl">
            <summary>This control allows the user to select a colour.
            The generic implementation is a button which brings up a wx.ColourDialog when clicked. Native implementation may differ but this
            is usually a (small) widget which give access to the colour-chooser dialog.
            
            Available styles: wx.WindowStyles.CLRP_Default_STYLE, wx.WindowStyles.CLRP_USE_TEXTCTRL, wx.WindowStyles.CLRP_SHOW_LABEL.</summary>
        </member>
        <member name="M:WX.ColourPickerCtrl.#ctor">
            <summary>Default CTor for two step construction using Create().</summary>
        </member>
        <member name="M:WX.ColourPickerCtrl.SetColour(System.String)">
            <summary>Setting the clour from a string.
            This accepts: colour names (those listed in wx.Colour.TheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green, blue components).</summary>
        </member>
        <member name="M:WX.ColourPickerCtrl.SetColour(WX.wxString)">
            <summary>Setting the clour from a string.
            This accepts: colour names (those listed in wx.Colour.TheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green, blue components).</summary>
        </member>
        <member name="P:WX.ColourPickerCtrl.Colour">
            <summary>The displayed colour.</summary>
        </member>
        <member name="T:WX.ColourPickerEvent">
            <summary>Events raised by the wx.ColourPickerCtrl</summary>
        </member>
        <member name="P:WX.ColourPickerEvent.Colour">
            <summary>The affected colour.
            If this indicates a change, then this is e.g. the new colour.</summary>
        </member>
        <member name="T:WX.FontPickerCtrl">
            <summary>This control allows the user to select a font.
            The generic implementation is a button which brings up a wxFontDialog when clicked.
            Native implementation may differ but this is usually a (small) widget which give access to the font-chooser dialog.
            
            Uses the styles wx.WindowStyles.FNTP_FONTDESC_AS_LABEL, wx.WindowStyles.FNTP_USEFONT_FOR_LABEL,
            wx.WindowStyles.FNTP_USE_TEXTCTRL, wx.WindowStyles.FNTP_Default_STYLE.</summary>
        </member>
        <member name="M:WX.FontPickerCtrl.#ctor">
            <summary>Default CTor.
            Use this in two step construction in combination with <c>Create()</c>.</summary>
        </member>
        <member name="M:WX.FontPickerCtrl.Create(WX.Window,System.Int32,WX.Font,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,WX.wxString)">
            <summary>Second step in 2-step construction.</summary>
        </member>
        <member name="P:WX.FontPickerCtrl.SelectedFont">
            <summary>Get or set the selected font.
            Please keep care that the result will be finalized as soon as possible since
            some platforms only allow a certain amount of allocated font objects.</summary>
        </member>
        <member name="P:WX.FontPickerCtrl.MaxPointSize">
            <summary>Reads or defines the maximal point size of a font.</summary>
        </member>
        <member name="T:WX.FontPickerEvent">
            <summary>This event refers to wx.FontPickerCtrl</summary>
        </member>
        <member name="P:WX.FontPickerEvent.Font">
            <summary>Get or set the affected font.
            Please keep care that the result will be finalized as soon as possible since
            some platforms only allow a certain amount of allocated font objects.</summary>
        </member>
        <member name="T:WX.Bitmap">
            <summary>
            This class encapsulates the concept of a platform-dependent bitmap, either monochrome or colour or colour
            with alpha channel support.
            </summary>
        </member>
        <member name="M:WX.GDIObject.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns>Returns <c>this</c>.</returns>
        </member>
        <member name="P:WX.GDIObject.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="M:WX.Bitmap.#ctor(System.String)">
            <summary>Be careful: Create an wx.Image first before creating a bitmap from a file.
            In fact I don't know why, but this works better for <c>wxGTK</c>.
            </summary>
        </member>
        <member name="M:WX.Bitmap.#ctor(System.String,System.Reflection.Assembly)">
            <summary>Convenience CTor for reading the resource of the provided name from the provided assembly.</summary>
        </member>
        <member name="M:WX.Bitmap.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary>
            <param name="archiveName">Name of the archive file like <c>"Resources.zrs"</c>.</param>
            <param name="resourceName">Name of the resource in the resource file.</param>
            <remarks>
            This will load an image <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
            \code
            wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
            wx.Bitmap icon=new wx.Bitmap("archiveName.zrs", "iconname.png");
            \endcode
            </remarks>
        </member>
        <member name="M:WX.Bitmap.FromBits(System.Boolean[],System.Int32)">
            <summary>This will create a monochrome bitmaps with data from <c>bits</c>.</summary>
                     * <remarks>
                     * Sample:
                     * <code>
                     wx.Bitmap monochromeCross=new wx.Bitmap(new bool[]
                       {false, false,  true,  true,  true,  true, false, false,
                        false, false, false,  true,  true, false, false, false,
                         true, false, false,  true,  true, false, false,  true,
                         true,  true,  true,  true,  true,  true,  true,  true,
                         true,  true,  true,  true,  true,  true,  true,  true,
                         true, false, false,  true,  true, false, false,  true,
                        false, false, false,  true,  true, false, false, false,
                        false, false,  true,  true,  true,  true, false, false},
                        8);
                     </code>
                     * </remarks>
        </member>
        <member name="M:WX.Bitmap.FromBits(System.Byte[],System.Int32)">
            <summary>This will create a monochrome bitmaps with data from <c>bytes</c>.
            </summary>
        </member>
        <member name="M:WX.Bitmap.ConvertToImage">
            <summary>
            Creates an image from a platform-dependent bitmap. This preserves mask information so that
            bitmaps and images can be converted back and forth without loss in that respect.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Bitmap.Size">
            <summary>Get or set the size of the bitmap.
            Equivalent to sequential use of Width() and Height().
            </summary>
        </member>
        <member name="P:WX.Bitmap.Mask">
            <summary>
            Gets the associated mask (if any) which may have been loaded from a file or set for the bitmap.
            
            The setter sets the mask for this bitmap. Refer to the ctors of wx.Mask for your options to create
            a mask.
            </summary>
        </member>
        <member name="P:WX.Bitmap.NullBitmap">
            <summary>This is a static instance of an empty bitmap.
            This instance may be of use as default argument to several methods,
            e.g. wx.ToolBar. Don't copy or draw into this.
            </summary>
        </member>
        <member name="M:WX.Icon.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary>
            <param name="archiveName">Name of the archive file like <c>"Resources.zrs"</c>.</param>
            <param name="resourceName">Name of the resource in the resource file.</param>
            <remarks>
            This will load an image <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
            \code
            wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
            wx.Icon icon=new wx.Icon("archiveName.zrs", "iconname.png");
            \endcode
            </remarks>
        </member>
        <member name="M:WX.Icon.#ctor(System.String)">
            <summary>This loads the icon from a local file.
            This CTor will NOT raise exceptions but display a default icon if the file cannot be loaded.
            You may use the CTor requiring a BitmapType to specify alternative ways of loading.</summary>
            <param name="name">Filename of the icon to be displayed.</param>
        </member>
        <member name="M:WX.Icon.#ctor(System.String,System.Boolean)">
            <summary>This loads the icon from a local file. You may use the CTor requiring a BitmapType to specify alternative ways of loading.</summary>
            <param name="name">Filename of the icon to be displayed.</param>
            <param name="enableException">Enables with <c>true</c> raising of exceptions if the file has not been found.</param>
            <exception cref="T:System.ArgumentException">Raised if <c>enableExceptions</c> and the icon file cannot be loaded.</exception>
        </member>
        <member name="M:WX.Icon.#ctor(System.String,WX.BitmapType)">
            <summary>Loads a bitmap of the provided type.
            Use wx.BitmapType.wxBITMAP_TYPE_ANY if you have no information on the type
            of the bitmap. Use wx.BitmapType.wxBITMAP_TYPE_RESOURCE to load a bitmap
            from the .NET resource named <c>name</c>.
            </summary>
        </member>
        <member name="M:WX.Icon.#ctor(System.String,System.Reflection.Assembly)">
            <summary>Convenience CTor for reading the resource of the provided name from the provided assembly.</summary>
        </member>
        <member name="T:WX.BoxSizer">
            <summary>Wrapps the  wxWidgets <c>wxBoxSizer</c> class, the most frequently used specification of dynamic layouts.</summary><remarks>
                 * 
                 * The basic idea behind a wxBoxSizer is that windows will most often be laid out in
                 * rather simple basic geometry, typically in a row or a column or several
                 * hierarchies of either.
                 *
                 * As an example, we will construct a dialog that will contain a text field at the
                 * top and two buttons at the bottom. This can be seen as a top-hierarchy column with
                 * the text at the top and buttons at the bottom and a low-hierarchy row with an
                 * OK button to the left and a Cancel button to the right. In many cases
                 * (particularly dialogs under Unix and normal frames) the main window will be
                 * resizable by the user and this change of size will have to get propagated to
                 * its children. In our case, we want the text area to grow with the dialog, whereas
                 * the button shall have a fixed size. In addition, there will be a thin border
                 * around all controls to make the dialog look nice and - to make matter worse - the
                 * buttons shall be centred as the width of the dialog changes.
                 * 
                 * It is the unique feature of a box sizer, that it can grow in both directions
                 * (height and width) but can distribute its growth in the main direction (horizontal
                 * for a row) unevenly among its children. In our example case, the vertical sizer
                 * is supposed to propagate all its height changes to only the text area, not to the
                 * button area. This is determined by the proportion parameter when adding a window
                 * (or another sizer) to a sizer. It is interpreted as a weight factor, i.e. it can
                 * be zero, indicating that the window may not be resized at all, or above zero.
                 * If several windows have a value above zero, the value is interpreted relative
                 * to the sum of all weight factors of the sizer, so when adding two windows with
                 * a value of 1, they will both get resized equally much and each half as much as
                 * the sizer owning them. Then what do we do when a column sizer changes its width?
                 * This behaviour is controlled by flags (the second parameter of the wx.Sizer.Add()
                 * function): Zero or no flag indicates that the window will preserve it is original
                 * size, wx.SizerFlag.wxGROW flag (same as wx.SizerFlag.wxEXPAND) forces the window
                 * to grow with the sizer, and wx.SizerFlag.Shaped flag tells the window to change
                 * it is size proportionally, preserving original aspect ratio. When
                 * wx.SizerFlag.wxGROW flag is not used, the item can be aligned within available
                 * space. wx.SizerFlag.Left, wx.SizerFlag.Top,
                 * wx.SizerFlag.Right, wx.SizerFlag.Bottom,
                 * wx.SizerFlag.wxALIGN_CENTER_HORIZONTAL and wx.SizerFlag.wxALIGN_CENTER_VERTICAL do
                 * what they say. wx.SizerFlag.Centre (same as wx.SizerFlag.wxALIGN_CENTER)
                 * is defined as
                 * \verbatim
                 (wx.SizerFlag.wxALIGN_CENTER_HORIZONTAL | wx.SizerFlag.wxALIGN_CENTER_VERTICAL).
                 \endverbatim
                 * Default alignment is <c>wx.SizerFlag.Left</c> \c | <c>wx.SizerFlag.Top</c>.
                 * 
                 * As mentioned above, any window belonging to a sizer may have border, and it can be specified which of the four sides may have this border, using the Top, wxLEFT, Right and Bottom constants or All for all directions (and you may also use North, West etc instead). These flags can be used in combination with the alignment flags above as the second parameter of the Add() method using the binary or operator |. The sizer of the border also must be made known, and it is the third parameter in the Add() method. This means, that the entire behaviour of a sizer and its children can be controlled by the three parameters of the Add() method.
                 *
                 * <code>
                 * 
                 * // we want to get a dialog that is stretchable because it
                 * // has a text ctrl at the top and two buttons at the bottom
                 * 
                 * MyDialog(Frame *parent, int id, string title )
                 *   : Dialog(parent, id, title, wxDefaultPosition, wxDefaultSize,
                 *               DialogDefaultStyle | ResizeBorder)
                 * {
                 *   BoxSizer topsizer = new BoxSizer( Orientation.wxVERTICAL );
                 * 
                 *   // create text ctrl with minimal size 100x60
                 *   topsizer.Add(
                 *     new TextCtrl( this, -1, "My text.", wxDefaultPosition, wxSize(100,60), TextCtrlMultiline),
                 *     1,                      // make vertically stretchable
                 *     SizerFlag.wxEXPAND |    // make horizontally stretchable
                 *     SizerFlag.All,        //   and make border all around
                 *     10 );                   // set border width to 10
                 * 
                 * 
                 *   BoxSizer button_sizer = new BoxSizer( Orientation.wxHORIZONTAL );
                 *   button_sizer.Add(
                 *      new Button( this, -1, "OK" ),
                 *      0,                  // make horizontally unstretchable
                 *      SizerFlag.All,    // make border all around (implicit top alignment)
                 *      10 );               // set border width to 10
                 *   button_sizer.Add(
                 *      new Button( this, -1, "Cancel" ),
                 *      0,                  // make horizontally unstretchable
                 *      SizerFlag.All,    // make border all around (implicit top alignment)
                 *      10 );               // set border width to 10
                 * 
                 *   topsizer.Add(
                 *      button_sizer,
                 *      0,                           // make vertically unstretchable
                 *      SizerFlag.wxALIGN_CENTER );  // no border and centre horizontally
                 * 
                 *   this.SetSizer( topsizer );      // use the sizer for layout
                 * 
                 *   topsizer.SetSizeHints( this ); // set size hints to honour minimum size
                 * }
                 * </code>
                 * Note that the new way of specifying flags to wxSizer is via wxSizerFlags. This class greatly eases the burden of passing flags to a wxSizer.
                 * Here's how you'd do the previous example with wxSizerFlags:
                 * 
                 * <code>
                 * // we want to get a dialog that is stretchable because it
                 * // has a text ctrl at the top and two buttons at the bottom
                 * 
                 * MyDialog(Frame *parent, int id, string title )
                 *        : Dialog(parent, id, title, wxDefaultPosition, wxDefaultSize,
                 *                    DialogDefaultStyle | ResizeBorder)
                 * {
                 *   BoxSizer topsizer = new BoxSizer( Orientation.wxVERTICAL );
                 * 
                 *   // create text ctrl with minimal size 100x60 that is horizontally and 
                 *   // vertically stretchable with a border width of 10
                 *   topsizer.Add(
                 *     new TextCtrl( this, -1, "My text.", wxDefaultPosition, new Size(100,60), TextCtrlMultiline),
                 *     SizerFlag.wxALIGN|SizerFlag.wxEXPAND|SizerFlag.All, 10);
                 * 
                 *   BoxSizer button_sizer = new BoxSizer( Orientation.wxHORIZONTAL );
                 * 
                 *   //create two buttons that are horizontally unstretchable, 
                 *   // with an all-around border with a width of 10 and implicit top alignment
                 *   button_sizer.Add(
                 *      new Button( this, -1, "OK" ),
                 *      SizerFlag.wxEXPAND|SiserFlag.All, 10);       
                 * 
                 *   button_sizer.Add(
                 *      new Button( this, -1, "Cancel" ),
                 *      SizerFlag.wxALIGN|SizerFlags.wxEXPAND|SizerFlags.All, 10);    
                 * 
                 *   //create a sizer with no border and centered horizontally
                 *   topsizer.Add(
                 *      button_sizer,
                 *      SizerFlag.wxALIGN_CENTER ); 
                 * 
                 *   this.SetSizer( topsizer );      // use the sizer for layout
                 * 
                 *   topsizer.SetSizeHints( this );  // set size hints to honour minimum size
                 * }
                 * </code>
                 * </remarks>
        </member>
        <member name="T:WX.Sizer">
             <summary>
             wx.Sizer is the abstract base class used for laying out subwindows in a window.
             You cannot use wx.Sizer directly; instead, you will have to use one of the sizer classes derived from it.
             Currently there are wx.BoxSizer, wx.StaticBoxSizer, wx.GridSizer wx.FlexGridSizer and wx.GridBagSizer.
            
             The layout algorithm used by sizers in wxWidgets is closely related to layout in other GUI toolkits, such as
             Java's AWT, the GTK toolkit or the Qt toolkit. It is based upon the idea of the individual subwindows reporting
             their minimal required size and their ability to get stretched if the size of the parent window has changed.
             This will most often mean that the programmer does not set the original size of a dialog in the beginning,
             rather the dialog will be assigned a sizer and this sizer will be queried about the recommended size.
             The sizer in turn will query its children, which can be normal windows, empty space or other sizers, 
             so that a hierarchy of sizers can be constructed. Note that wx.Sizer does not derive from wxWindow and
             thus does not interfere with tab ordering and requires very little resources compared to a real window on screen.
            
             What makes sizers so well fitted for use in wxWidgets is the fact that every control reports its own minimal size
             and the algorithm can handle differences in font sizes or different window (dialog item) sizes on different
             platforms without problems. If e.g. the standard font as well as the overall design of Motif widgets requires
             more space than on Windows, the initial dialog size will automatically be bigger on Motif than on Windows.
            
             Sizers may also be used to control the layout of custom drawn items on the window. The Add, Insert, and Prepend
             functions return a pointer to the newly added wxSizerItem. Just add empty space of the desired size and attributes,
             and then use the wxSizerItem::GetRect method to determine where the drawing operations should take place.
            
             Please notice that sizers, like child windows, are owned by the library and will be deleted by it which implies that
             they must be allocated on the heap. However if you create a sizer and do not add it to another sizer or window,
             the library wouldn't be able to delete such an orphan sizer and in this, and only this, case it should be deleted
             explicitly.
             </summary>
        </member>
        <member name="M:WX.Sizer.#ctor(System.IntPtr)">
            <summary>
            Do not use this. This is for internal purposes only.
            </summary>
            <param name="wxObject">Address of the pointer to the native sizer.</param>
        </member>
        <member name="M:WX.Sizer.Add(WX.Window,System.Int32,WX.SizerFlag)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
        </member>
        <member name="M:WX.Sizer.Add(WX.Window,System.Int32,WX.SizerFlag,System.Int32)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:WX.Sizer.Add(WX.Window,System.Int32,WX.SizerFlag,System.Int32,WX.Object)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:WX.Sizer.Add(System.Int32,System.Int32)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
        </member>
        <member name="M:WX.Sizer.Add(System.Int32,System.Int32,System.Int32,WX.SizerFlag,System.Int32)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:WX.Sizer.Add(System.Int32,System.Int32,System.Int32,WX.SizerFlag,System.Int32,WX.Object)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:WX.Sizer.Fit(WX.Window)">
             <summary>
             Tell the sizer to resize the window to match the sizer's minimal size.
             This is commonly done in the constructor of the window itself, see sample in the description of wx.BoxSizer.
             Returns the new size.
            
             For a top level window this is the total window size, not client size.
             </summary>
             <param name="window"></param>
             <returns></returns>
        </member>
        <member name="M:WX.Sizer.FitInside(WX.Window)">
            <summary>
            Tell the sizer to resize the virtual size of the window to match the sizer's minimal size.
            This will not alter the on screen size of the window, but may cause the addition/removal/alteration of
            scrollbars required to view the virtual area in windows which manage it.
            </summary>
            <param name="window"></param>
        </member>
        <member name="M:WX.Sizer.SetSizeHints(WX.Window)">
            <summary>This will cause the layout to honour minimal size of <c>window</c>.
             Note: First assign the sizer. Then, set size hints.
             
             This method first calls <c>wx.Sizer.Fit</c> and then <c>SetSizeHints</c> on the window passed to it.
             This only makes sense when window is actually a top level window such as a wx.Frame or a wx.Dialog,
             since <c>SetSizeHints</c> only has any effect in these classes. It does nothing in normal windows or controls.
            
              This method is commonly invoked in the constructor of a toplevel window itself if the toplevel window is resizable.
              </summary>
        </member>
        <member name="M:WX.BoxSizer.#ctor(WX.Orientation)">
            <summary>Creates a new sizer of the designated orientation.
             Refer to class wx.Orientation for applicable flags.
            </summary>
        </member>
        <member name="F:WX.Aui.AuiToolBarTextOrientation.LEFT">
            <summary>
            unused/unimplemented
            </summary>
        </member>
        <member name="F:WX.Aui.AuiToolBarTextOrientation.TOP">
            <summary>
            unused/unimplemented
            </summary>
        </member>
        <member name="T:WX.wxDateTime">
            <summary>A wrapper to the  wxWidgets representation of points in time.
            </summary>
        </member>
        <member name="M:WX.wxDateTime.ToString">
            <summary>Comprehensable output.
            </summary>
        </member>
        <member name="M:WX.wxDateTime.FromWxWeekDay(System.Int32)">
            <summary>Converts the int into a DayOfWeek assuming the argumetn to be an index in  wxWidgets enumeration <c>WeekDay</c>.
            This will throw an System.ArgumentOutOfRangeException on negative arguments.
            </summary>
        </member>
        <member name="T:WX.TipProvider">
            <summary>
            Offers opportunity to display a unique tip dialog showing tips from a file.
            </summary>
        </member>
        <member name="M:WX.TipProvider.CreateFileTipProvider(System.String,System.Int32)">
            <summary>
            Creates a tip provider.
            </summary>
            <param name="filename">Name of the file providing the tips-
            </param>
            <param name="currentTip">Index of the current tip.
            </param>
        </member>
        <member name="M:WX.TipProvider.CreateFileTipProvider(WX.wxString,System.Int32)">
            <summary>
            Creates a tip provider.
            </summary>
            <param name="filename">Name of the file providing the tips-
            </param>
            <param name="currentTip">Index of the current tip.
            </param>
        </member>
        <member name="M:WX.TipProvider.ShowTip(WX.Window)">
            <summary>
            Shows the dialog.
            </summary>
            <param name="parent">This shall be the parent of the tip dialog.
            </param>
            <returns>True on success.
            </returns>
        </member>
        <member name="M:WX.TipProvider.ShowTip(WX.Window,System.Boolean)">
            <summary>
            Shows the dialog.
            </summary>
            <param name="parent">This shall be the parent of the tip dialog.
            </param>
            <returns>True on success.
            </returns>
        </member>
        <member name="P:WX.TipProvider.CurrentTip">
            <summary>
            Returns the current tip.
            </summary>
        </member>
        <member name="T:WX.TaskBarIcon">
            <summary>This class represents a taskbar icon.
             A taskbar icon is an icon that appears in the 'system tray' and responds to mouse clicks, optionally with a tooltip
             above it to help provide information.
             </summary>
             <remarks>
             \par wxNET notes
             Apparently, task icons prohibit application exit on closing the main frame. So, you will have to use
             <c>wx.Utils.Exit()</c> instead where appropriate.
             
             \par X Window System Note
             Under X Window System, the window manager must support either the System Tray Protocol by <c>freedesktop.org</c>
             (WMs used by modern desktop environments such as GNOME >= 2, KDE >= 3 and XFCE >= 4 all do) or the older
             methods used in GNOME 1.2 and KDE 1 and 2. If it doesn't, the icon will appear as a toplevel window on
             user's desktop.
            
             Because not all window managers have system tray, there's no guarantee that wx.TaskBarIcon will work correctly
             under X Window System and so the applications should use it only as an optional component of their user interface.
             The user should be required to explicitly enable the taskbar icon on Unix, it shouldn't be on by default.
            
             \par Event handling
            
             To process input from a taskbar icon, use the following event handler macros to direct input to member functions
             that take a wxTaskBarIconEvent argument. Note that not all ports are required to send these events and so it's 
             better to override CreatePopupMenu if all that the application does is that it shows a popup menu in reaction to
             mouse click.
            
             \li <c>EVT_TASKBAR_MOVE(func)</c>  Process a <c>wxEVT_TASKBAR_MOVE</c> event.  
             \li <c>EVT_TASKBAR_LEFT_DOWN(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_DOWN</c> event.  
             \li <c>EVT_TASKBAR_LEFT_UP(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_UP</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_DOWN(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_DOWN</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_UP(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_UP</c> event.  
             \li <c>EVT_TASKBAR_LEFT_DCLICK(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_DCLICK</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_DCLICK(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_DCLICK</c> event.  
             \li <c>EVT_TASKBAR_CLICK(func)</c>  This is a synonym for either <c>EVT_TASKBAR_RIGHT_DOWN</c> or <c>UP</c>
             depending on the platform, use this event macro to catch the event which should result in the menu being displayed on the current platform.  
             
             Contributed by Jacek Trublajewicz 2008 with some changes by Harald Meyer auf'm Hofe.
             </remarks>
        </member>
        <member name="M:WX.TaskBarIcon.SetIcon(WX.Icon,System.String)">
            <summary>Defines icon and optional tool tip to be presented inthe task bar.
            Call RemoveIcon() to remove the icon from the task bar.</summary>
        </member>
        <member name="M:WX.TaskBarIcon.RemoveIcon">
            <summary>This will remove the icon from the task bar.</summary>
        </member>
        <member name="M:WX.TaskBarIcon.CreatePopupMenu">
            <summary>This method is called by the library when the user requests popup menu (on Windows and Unix platforms, this is when the user right-clicks the icon).
             Override this function in order to provide popup menu associated with the icon.
            
             If CreatePopupMenu returns <c>null</c> (this happens by default), no menu is shown, otherwise the menu is displayed
             and then deleted by the library as soon as the user dismisses it. The events can be handled by a class derived
             from wx.TaskBarIcon.
             
             Note, that the returned wrapper will loose ownership of the native wx menu immediately after this method has
             been finished.</summary>
        </member>
        <member name="M:WX.TaskBarIcon.PopupMenu(WX.Menu)">
            <summary>Pops up a menu at the current mouse position.
            The events can be handled by a class derived from wx.TaskBarIcon.
            \par Note
            It is recommended to override <c>CreatePopupMenu()</c> callback instead of calling this method from event handler,
            because some ports (e.g. wxCocoa) may not implement <c>PopupMenu()</c> and mouse click events at all.</summary>
        </member>
        <member name="P:WX.TaskBarIcon.IsIconInstalled">
            <summary>True iff icon is presented in the task bar.
            Call RemoveIcon() to remove the icon from the task bar.</summary>
        </member>
        <member name="T:WX.NotifyEvent">
            <summary>This class is not used by the event handlers by itself, but is a base class for other event classes (such as wx.NotebookEvent).
            
             It (or an object of a derived class) is sent when the controls state is being changed and allows the program to <c>Veto()</c>
             this change if it wants to prevent it from happening.</summary>
        </member>
        <member name="M:WX.NotifyEvent.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="M:WX.NotifyEvent.Veto">
            <summary>Prevents the change announced by this event from happening.
            
             It is in general a good idea to notify the user about the reasons for vetoing the change because otherwise the
             applications behaviour (which just refuses to do what the user wants) might be quite surprising.</summary>
        </member>
        <member name="M:WX.NotifyEvent.Allow">
            <summary>Call this to explicitely allow processing of this event.
            This is the opposite of <c>Veto()</c>: it explicitly allows the event to be processed.
            For most events it is not necessary to call this method as the events are allowed anyhow 
            but some are forbidden by default (this will be mentioned in the corresponding event description).</summary>
        </member>
        <member name="P:WX.NotifyEvent.Allowed">
            <summary>This is <c>true</c> if processing this event is allowed (has not been vetoed).
            You may also set a value. This will either call Veto() or Allow().</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellDrawingPointEditor">
            <summary>
            Editor to put in the position of a point (System.Drawing.Point). Refer
            to the wx.GridCtrl.Renderers.GridCellpointRenderer for a compatible
            renderer or to registered grid datatype "System.Drawing.Point".
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellEditor">
            <summary>Inherit from this class to implement you won grid cell editor.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            \param memOwn defines whether this method creates wrappers owning the C++ object or not.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.DeregisterWrapper">
            <summary>This will deregister the wrapper.
            This is necessary if natice instance live longer than their wrappers.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.Create(WX.Window,System.Int32,WX.EvtHandler)">
            <summary>Do not forget to set the generated control (SetControl())
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.SetControl(WX.Control)">
            <summary>Sets the control to be raised on edit a cell.
             Setting this is a prerequisite for several methods and shall be done in Create().
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.GetControl">
            <summary>Gets the control that is used for editing cells.
            Note: This only works if the control has been generated from the WX.Net side.
            If this editor is a native implementation like for instance GridCellTextEditor,
            this method returns <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEditor.PaintBackground(System.Drawing.Rectangle,WX.GridCtrl.GridCellAttr)">
            <summary>
            Draws the part of the cell not occupied by the control: the base class version just fills it with background colour from the attribute.
            </summary>
            <param name="rectCell"></param>
            <param name="attr"></param>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellDrawingPointEditor.#ctor(System.String)">
            <summary>
            Creates an instance using the provided format string.
            </summary>
            <param name="format">Format string containing the format directives "{X}" (x coordinate) and "{Y}" (y coordinate).</param>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellDrawingPointEditor.SetSize(System.Drawing.Rectangle)">
            <summary>
            Normalize size of the control.
            This is a port of the wxWidgets source. 
            </summary>
            <param name="rect"></param>
        </member>
        <member name="P:WX.GridCtrl.Editors.GridCellDrawingPointEditor.InputCtrl">
            <summary>Returns the input control.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellDrawingSizeEditor">
            <summary>
            Editor to put in the position of a point (System.Drawing.Point). Refer
            to the wx.GridCtrl.Renderers.GridCellpointRenderer for a compatible
            renderer or to registered grid datatype "System.Drawing.Point".
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellDrawingSizeEditor.#ctor(System.String)">
            <summary>
            Creates an instance using the provided format string.
            </summary>
            <param name="format">Format string containing the format directives "{W}" (width) and "{H}" (height).</param>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellDrawingSizeEditor.#ctor">
            <summary>
            An editor using the format "{W} x {H}".
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellDrawingSizeEditor.SetSize(System.Drawing.Rectangle)">
            <summary>
            Normalize size of the control.
            This is a port of the wxWidgets source. 
            </summary>
            <param name="rect"></param>
        </member>
        <member name="P:WX.GridCtrl.Editors.GridCellDrawingSizeEditor.InputCtrl">
            <summary>Returns the input control.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellDateTimeEditor">
            <summary>Input of DateTime values using the wx.MaskedEdit.DateTimeCtrl.
            This will expect the grid model to store the natural string forms of System.DateTime
            values.
            
            Refer to wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer for a compatible renderer.</summary>
        </member>
        <member name="P:WX.GridCtrl.Editors.GridCellDateTimeEditor.InputCtrl">
            <summary>Returns the input control.</summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer">
            <summary>
            Renderer to display elements of type <c>System.Drawing.Point</c>.
            Output will be according to a format string containing the elements <c>{X}</c> and <c>{Y}</c>
            for the X or, repectively, the Y coordinate of the point. The standard format is <c>"{X}@{Y}</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellRenderer.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellRenderer.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            \param memOwn defines whether this method creates wrappers owning the C++ object or not.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.#ctor">
            <summary>
            Creates a renderer using the standard format.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.ExpandFormat(System.String,System.Drawing.Point)">
            <summary>
            Returns the expansion of the provided format string filling in data from the second argument.
            </summary>
            <param name="format">The format string that will be expanded. Currently implemented format
            options: {X} (X coordinate) and {Y} (Y coordinate).</param>
            <param name="position">The instance whose properties will be formatted.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.ExpandFormat(System.Drawing.Point)">
            <summary>
            Returns a string representing the argument such a way that can be parsed by Parse().
            </summary>
            <param name="position">The value that shall be returned as string.</param>
            <returns></returns>
            <see cref="M:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.Parse(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.Parse(System.String)">
            <summary>
            Parse a position from the argument string that shall have the format "{X}@{Y}". An empty string
            will be interpreted as an empty position description (both coordinates are -1).
            </summary>
            <param name="stringRepresentation">String of the format "{X}@{Y}" that will be parsed for the result.</param>
            <returns></returns>
            <exception cref="T:System.FormatException">Will be thrown if the argument is from an unsupported format.</exception>
        </member>
        <member name="P:WX.GridCtrl.Renderers.GridCellDrawingPointRenderer.Format">
            <summary>
            Readonly access to the format string.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer">
            <summary>
            Renderer to display elements of type <c>System.Drawing.Size</c>.
            Output will be according to a format string containing the elements <c>{W}</c> and <c>{H}</c>
            for the width or the height of the size respectively. The standard format is <c>"{W}x{H}</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer.#ctor">
            <summary>
            Creates a renderer using the standard format.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer.ExpandFormat(System.String,System.Drawing.Size)">
            <summary>
            Returns the expansion of the provided format string filling in data from the second argument.
            </summary>
            <param name="format">The format string that will be expanded. Currently implemented format
            options: {W} (width) and {H} (height).</param>
            <param name="size">The instance whose properties will be formatted.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer.ExpandFormat(System.Drawing.Size)">
            <summary>
            Creating a string complying with the standard serialization format "{W}x{H}".
            </summary>
            <param name="size">the data that will be pasted into the result.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer.Parse(System.String)">
            <summary>
            Parse a size from the argument string that shall have the format "{X}x{Y}". An empty string
            will be interpreted as an empty position description (both coordinates are -1).
            </summary>
            <param name="stringRepresentation">String of the format "{X}x{Y}" that will be parsed for the result.</param>
            <returns></returns>
            <exception cref="T:System.FormatException">Will be thrown if the argument is from an unsupported format.</exception>
        </member>
        <member name="P:WX.GridCtrl.Renderers.GridCellDrawingSizeRenderer.Format">
            <summary>
            Readonly access to the format string.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellRectangleRenderer">
            <summary>
            Renderer to display elements of type <c>System.Drawing.Rectangle</c>.
            Output will be according to a format string containing the elements <c>{X}</c>, <c>{Y}</c>, <c>{W}</c> and <c>{H}</c>
            for the X or the Y coordinates, the height, or the width, respectively. The standard format is <c>"{X}@{Y}, {W}x{H}</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellRectangleRenderer.#ctor">
            <summary>
            Creates a renderer using the standard format.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellRectangleRenderer.ExpandFormat(System.String,System.Drawing.Rectangle)">
            <summary>
            Returns the expansion of the provided format string filling in data from the second argument.
            </summary>
            <param name="format">The format string that will be expanded. Currently implemented format
            options: {X} (X coordinate) and {Y} (Y coordinate), {H} (height), and {W} (width).</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellRectangleRenderer.Parse(System.String)">
            <summary>
            Parse a rectangle from the argument string that shall have the format "{X}@{Y},{W}x{H}". An empty string
            will be interpreted as an empty position description (both coordinates are -1).
            </summary>
            <param name="stringRepresentation">String of the format "{X}@{Y},{W}x{H}" that will be parsed for the result.</param>
            <returns></returns>
            <exception cref="T:System.FormatException">Will be thrown if the argument is from an unsupported format.</exception>
        </member>
        <member name="P:WX.GridCtrl.Renderers.GridCellRectangleRenderer.Format">
            <summary>
            Readonly access to the format string.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellDateTimeMaskRenderer">
            <summary>Renders DateTime data compatbile to wx.GridCtrl.Editors.GridCellDateTimeEditor.</summary>
            <remarks>
            This expand the following format strings using <c>data</c>:
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            </remarks>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.#ctor(System.String)">
            <summary>Creates a renderer showing data in the provided format.
            refer to the class documentation.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.DateTimeToString(System.DateTime)">
            <summary>Creates a string from <c>data</c> using the format string <c>Format</c>.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.Format">
            <summary>returns the format string.
            </summary>
        </member>
        <member name="T:WX.DateTimeValueChangedEvent">
            <summary>A simple event that fires after a value has been changed.
            </summary>
        </member>
        <member name="M:WX.DateTimeValueChangedEvent.#ctor">
            <summary>The value has been set to <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.DateTimeValueChangedEvent.NewValue">
            <summary>Returns the new value that caused this event.
            The result may be <c>null</c> if this indicated the removal of a value.</summary>
        </member>
        <member name="T:WX.DateTimeValueChangedEventHandler">
            <summary>This is the type of the handlers of a DateTimeValueChangedEvent.
            </summary>
        </member>
        <member name="T:WX.DateTimeCtrl">
            <summary>This is a combination if the <c>wx.MaskedEdit.DateTimeEdit</c> and the <c>wx.CalendarCtrl</c>.
            You may use this to put in full time date information with calendar support.
            </summary>
        </member>
        <member name="M:WX.DateTimeCtrl.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.DateTime,System.String,System.DateTime,System.DateTime)">
            <summary>CTor of the control
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of class <c>wx.MaskedEdit.DateTimeEdit</c> for further remarks on this.
            \param minValue is a lower bound or the input.
            \param maxValue is an upper bound of the input.
            All other arguments follow the standard  WX.Net CTors.
            Please note, that this control always has a value. Use <c>wx.MaskedEdit.DateTimeEdit</c> instead if you want
            to allow optional input of data.</summary>
        </member>
        <member name="M:WX.DateTimeCtrl.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.DateTime,System.String,System.DateTime,System.DateTime)">
            <summary>CTor of the control</summary>
            <param name="startValue"> is an optional value that will be displayed on start.</param>
            <param name="textMask"> is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of class <c>wx.MaskedEdit.DateTimeEdit</c> for further remarks on this.</param>
            <param name="minValue"> is a lower bound or the input.</param>
            <param name="maxValue"> is an upper bound of the input.</param>
            <remarks>
            All other arguments follow the standard  WX.Net CTors.
            Please note, that this control always has a value. Use <c>wx.MaskedEdit.DateTimeEdit</c> instead if you want
            to allow optional input of data.
            </remarks>
        </member>
        <member name="F:WX.DateTimeCtrl.OnValueChanged">
            <summary>This will be called after the value of the control changed.</summary>
        </member>
        <member name="M:WX.DateTimeCtrl.SetHolidayColours(WX.Colour,WX.Colour)">
            <summary>This defines the colours to be used in the calendar control on holidays.</summary>
        </member>
        <member name="P:WX.DateTimeCtrl.Value">
            <summary>Read or write the value that will be displayed by this control.</summary>
        </member>
        <member name="P:WX.DateTimeCtrl.SpecialDays">
            <summary>Holidays that will be displayed in the calendar control.</summary>
        </member>
        <member name="T:WX.VisualComponent.SizerWindow">
            <summary>
            A simple serializable class providing the properties of a window
            whose layout is determined by a sizer.
            </summary>
        </member>
        <member name="P:WX.VisualComponent.SizerWindow.Name">
            <summary>
            The name of the window.
            </summary>
        </member>
        <member name="P:WX.VisualComponent.SizerWindow.Id">
            <summary>
            The ID of the window. Will be created automatically but can be set by serialization or the logic of the application.
            </summary>
        </member>
        <member name="T:WX.VisualComponent.TopLevelWindow">
            <summary>
            A simple serializable class representing the properties of a root level window, e.g.
            status line and menu bars.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.VisualComponent.SizerWindowDataObject" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.DataObjectCustom" ignoriert -->
        <member name="T:WX.DataObjectSimple">
            <summary>
            Base class of all simple data objects.
            Inherit from DataObjectCustom to implement new types of simple data objects.
            This class is necessary to specify components of DataObjectComposite.
            </summary>
            <seealso cref="T:WX.DataObjectCustom"/>
        </member>
        <member name="T:WX.DataObject">
            <summary>wx.DataObject represents a piece of data which knows which formats it
             supports and knows how to render itself in each of them - <c>GetDataHere()</c>,
             and how to restore data from the buffer (SetData()).
            
             Although this class may be used directly (i.e. custom classes may be
             derived from it), in many cases it might be simpler to use either
             wx.DataObjectSimple or wx.DataObjectComposite classes.
            
             A data object may be "read only", i.e. support only GetData() functions or
             "read-write", i.e. support both GetData() and SetData() (in principle, it
             might be "write only" too, but this is rare). Moreover, it doesn't have to
             support the same formats in Get() and Set() directions: for example, a data
             object containing JPEG image might accept BMPs in GetData() because JPEG
             image may be easily transformed into BMP but not in SetData(). Accordingly,
             all methods dealing with formats take an additional "direction" argument
             which is either SET or GET and which tells the function if the format needs
             to be supported by SetData() or GetDataHere().</summary>
        </member>
        <member name="M:WX.DataObject.GetPreferredFormat(WX.DataObject.DataDirection)">
            <summary>
            Returns the preferred format for either rendering the data (if <c>dir</c> is <c>Get</c>, its default value)
            or for setting it. Usually this will be the native format of the wx.DataObject.
            </summary>
            <param name="dir">Defines whether the format for rendering or setting is desired.</param>
            <returns></returns>
        </member>
        <member name="M:WX.DataObject.GetPreferredFormat">
            <summary>
            Returns the preferred format for either rendering the data (if <c>dir</c> is <c>Get</c>).
            Usually this will be the native format of the wx.DataObject.
            </summary>
            <param name="dir">Defines whether the format for rendering or setting is desired.</param>
            <returns></returns>
        </member>
        <member name="M:WX.DataObject.GetFormatCount(WX.DataObject.DataDirection)">
            <summary>
            Returns the number of available formats for rendering or setting the data.
            </summary>
            <param name="dir">Defines whether the format for rendering or setting is desired.</param>
            <returns></returns>
        </member>
        <member name="M:WX.DataObject.CopyInto(WX.DataObject)">
            <summary>
            Copies the contained data into the data object in the argument list.
            This method assumes that the received format is the preferred format of the argument.
            If either this method is not able to read data of the argument's preferred format
            or setting the data in the destination fails, the result will be false.
            The result will be true on success.
            </summary>
            <param name="destination">Defines the desired format. This will copy the data of this object
            into this argument.</param>
            <returns>True on success, false on failure.</returns>
        </member>
        <member name="F:WX.DataObject.DataDirection.Get">
            <summary>
            Use this to refer specifications on rendering the data.
            </summary>
        </member>
        <member name="F:WX.DataObject.DataDirection.Set">
            <summary>
            Use this to refer specifications on setting the data.
            </summary>
        </member>
        <member name="P:WX.DataObjectSimple.IsEmpty">
            <summary>
            This is true iff this is empty - does not contain data.
            </summary>
        </member>
        <member name="M:WX.DataObjectCustom.CreateInstance(WX.DataFormat)">
            <summary>
            Creates a native instance - locks Object.DllSync.
            </summary>
            <param name="format"></param>
            <param name="cbGetDataSize"></param>
            <param name="cbSetData"></param>
            <param name="cbGetData"></param>
            <returns></returns>
        </member>
        <member name="M:WX.DataObjectCustom.#ctor(WX.DataFormat)">
            <summary>
            Use this CTor when creating instances of sub-classes.
            </summary>
            <param name="format">The format of the data contained by this object.</param>
        </member>
        <member name="P:WX.DataObjectCustom.ByteData">
            Overload this to define the data that is contained.
        </member>
        <member name="P:WX.DataObjectCustom.Format">
            <summary>
            Get or set the data format of the contained data.
            </summary>
        </member>
        <member name="M:WX.VisualComponent.SizerWindowDataObject.#ctor(WX.DataFormat)">
            <summary>
            Creates an instance containing no data.
            </summary>
            <param name="format">This shall be either <c>SizerWindowFormat</c> or <c>TopLevelWindowFormat</c>.</param>
        </member>
        <member name="F:WX.VisualComponent.SizerWindowDataObject.SizerWindowFormat">
            <summary>
            The data format of data complying with this class of data.
            </summary>
        </member>
        <member name="F:WX.VisualComponent.SizerWindowDataObject.TopLevelWindowFormat">
            <summary>
            The data format of data complying with this class of data.
            </summary>
        </member>
        <member name="M:WX.VisualComponent.SizerWindowDataObject.#ctor(WX.VisualComponent.SizerWindow)">
            <summary>
            Creates an instance encapsulating the provided data.
            </summary>
            <param name="data">The generator expression that forms the data of this object.</param>
        </member>
        <member name="P:WX.VisualComponent.SizerWindowDataObject.Data">
            <summary>
            The encapsulated data.
            </summary>
        </member>
        <member name="P:WX.VisualComponent.SizerWindowDataObject.ByteData">
            <summary>
            This is a serialization of Data.
            </summary>
        </member>
        <member name="T:WX.TreeItemData">
            <summary>Analogously to SystemObjectClientData this holds a reference to an object that represents the client data.
             Use instance of this class to wrapp .NET data that shall be used as client data of a tree node in a wx.TreeCtrl.
            </summary>
        </member>
        <member name="T:WX.ClientData">
            <summary>Base class of all classes encapsulating client data.
             All classes deriving from wx.EvtHandler (such as all controls and App)
             can hold arbitrary data which is here referred to as "client data". This
             is useful e.g. for scripting languages which need to handle shadow objects
             for most of wxWidgets' classes and which store a handle to such a shadow
             class as client data in that class. This data can either be of type void
             - in which case the data container does not take care of freeing the data
             again or it is of type wxClientData or its derivatives. In that case the
             container (e.g. a control) will free the memory itself later. Note that
             you must not assign both void data and data derived from the
             ClientData class to a container.
            
             Some controls can hold various items and these controls can additionally
             hold client data for each item. This is the case for Choice, ComboBox
             and ListBox. TreeCtrl has a specialized class TreeItemData for each item
             in the tree.
             
             Refer to SystemObjectClientData for an opportunity to add .NET objects as client
             as client data.</summary>
        </member>
        <member name="M:WX.TreeItemData.#ctor(System.IntPtr)">
            <summary>
            For internal use only: Creates a registered wrapper of the provided native tree node instance.
            </summary>
            <param name="wxObject">Pointer to the tree node isntance that shall be wrapped.</param>
        </member>
        <member name="M:WX.TreeItemData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            For insternal use only.
            </summary>
            <param name="wxObject">Pointer to a native tree item data instance</param>
            <param name="memOwn">requires with <c>true</c> that the native tree node data instance shall be deleted on finaliation.</param>
        </member>
        <member name="M:WX.TreeItemData.#ctor">
            <summary>
            Creates an instance encapsulating the <c>null</c> reference.
            </summary>
        </member>
        <member name="M:WX.TreeItemData.#ctor(System.Int32)">
            Creates an instance encapsulating the provided index that shall annotate a tree node.
            <param name="clientData">The index that shall be associated with a tree node.</param>
        </member>
        <member name="M:WX.TreeItemData.#ctor(System.Object)">
            Creates an instance encapsulating the provided object as client data.
            <param name="clientData">The data that shall be associated with a tree node.</param>
        </member>
        <member name="P:WX.TreeItemData.Data">
            <summary>Returns or sets the data that has been attached to the node.</summary>
        </member>
        <member name="M:WX.TreeItemId.#ctor(WX.ClientData)">
            <summary>Creates an instance encapsulating the provided client data.
            Please note, that this will take ownership of the C++ instance wrapped by <c>pItem</c>.
            So, do not provide instances for <c>pItem</c> that have already been used.
            This will raise an exception in that case.</summary>
        </member>
        <member name="T:WX.TreeCtrl">
            <summary>This is the wrapper of the tree control <c>wxTreeCtrl</c>.
             </summary>
             <remarks>
             \image html treectrlsmall.png
             
             The tree control displays its items in a tree like structure. Each item has its own (optional) icon and
             a label. An item may be either collapsed (meaning that its children are not visible) or expanded
             (meaning that its children are shown). Each item in the tree is identified by its itemId which is of 
             opaque data type wxTreeItemId. You can test whether an item is valid by calling wx.TreeItemId.IsOk.
            
             The items text and image may be retrieved and changed with GetItemText/SetItemText and GetItemImage/SetItemImage.
             In fact, an item may even have two images associated with it: the normal one and another one for selected state
             which is set/retrieved with SetItemSelectedImage/GetItemSelectedImage functions, but this functionality might be
             unavailable on some platforms.
            
             Tree items have several attributes: an item may be selected or not, visible or not, bold or not. It may also be
             expanded or collapsed. All these attributes may be retrieved with the corresponding functions: IsSelected, IsVisible,
             IsBold and IsExpanded. Only one item at a time may be selected, selecting another one (with SelectItem) automatically
             unselects the previously selected one.
            
             In addition to its icon and label, a user-specific data structure may be associated with all tree items.
             If you wish to do it, you should derive a class from wxTreeItemData which is a very simple class having only one
             function GetId() which returns the id of the item this data is associated with. This data will be freed by the
             control itself when the associated item is deleted (all items are deleted when the control is destroyed), so you
             shouldn't delete it yourself (if you do it, you should call SetItemData(NULL) to prevent the tree from deleting
             the pointer second time). The associated data may be retrieved with GetItemData() function.
            
             Working with trees is relatively straightforward if all the items are added to the tree at the moment of its creation.
             However, for large trees it may be very inefficient. To improve the performance you may want to delay adding the items
             to the tree until the branch containing the items is expanded: so, in the beginning, only the root item is created
             (with AddRoot). Other items are added when EVT_TREE_ITEM_EXPANDING event is received: then all items lying immediately
             under the item being expanded should be added, but, of course, only when this event is received for the first time for
             this item - otherwise, the items would be added twice if the user expands/collapses/re-expands the branch.
             
             The tree control provides functions for enumerating its items. There are 3 groups of enumeration functions: for the
             children of a given item, for the sibling of the given item and for the visible items (those which are currently shown
             to the user: an item may be invisible either because its branch is collapsed or because it is scrolled out of view).
             Child enumeration functions require the caller to give them a cookie parameter: it is a number which is opaque to the
             caller but is used by the tree control itself to allow multiple enumerations to run simultaneously (this is explicitly
             allowed). The only thing to remember is that the cookie passed to GetFirstChild and to GetNextChild should be the same
             variable (and that nothing should be done with it by the user code).
            
             Among other features of the tree control are: item sorting with SortChildren which uses the user-defined comparison
             function OnCompareItems (by default the comparison is the alphabetic comparison of tree labels), hit testing 
             (determining to which portion of the control the given point belongs, useful for implementing drag-and-drop in the tree)
             with HitTest and editing of the tree item labels in place (see EditLabel).
             Finally, the tree control has a keyboard interface: the cursor navigation (arrow) keys may be used to change the current
             selection. "HOME" and "END" are used to go to the first/last sibling of the current item. '+', '-' and '*' expand,
             collapse and toggle the current branch. Note, however, that "DEL" and "INS" keys do nothing by default, but it is
             common to associate them with deleting an item from a tree and inserting a new one into it.
             
             Please note a serious problem with the tree control: The control does not like changes in its layout or selections
             on processing events. In such cases, I sometimes encountered access violations. The reason is unknown.
             Consider, that you want to react on leaving a text in a window in such a way, that a tree control changes the
             selected node or the tree has to be rebuilt. You leave the text control moving the mouse, the desired actions
             are conducted but suddenly the runtime environment reports a severe C++ exception.
             Fortunately, such problems can apparently be avoided using pending events as described in \ref custom_events.
             Use a custom command event type to conduct your actions after processing the mouse events.
             </remarks>
        </member>
        <member name="F:WX.TreeCtrl.DefaultStyle">
            <summary>This is the default style for tree controls.
            </summary>
        </member>
        <member name="M:WX.TreeCtrl.AddRoot(System.String)">
            <summary>
            Adds the root node to the tree, returning the new item.
            </summary>
            <param name="text">The name of the root node</param>
        </member>
        <member name="M:WX.TreeCtrl.AddRoot(System.String,System.Int32)">
            <summary>
            Adds the root node to the tree, returning the new item.
            </summary>
            <param name="text">The name of the root node</param>
            <param name="image">The index of the image that shall be presented with the node.</param>
        </member>
        <member name="M:WX.TreeCtrl.AddRoot(System.String,System.Int32,System.Int32)">
            <summary>
             Adds the root node to the tree, returning the new item.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to
             use for unselected and selected items, respectively. If <c>image > -1</c> and <c>selImage is -1</c>, the same image is
             used for both selected and unselected items.
             </summary>
             <param name="text">The name of the root node</param>
             <param name="image">The index of the image that shall be presented with the node.</param>
             <param name="selImage">The index of the image that shall be presented with the node if the node is selected.</param>
        </member>
        <member name="M:WX.TreeCtrl.AddRoot(System.String,System.Int32,System.Int32,WX.TreeItemData)">
            <summary>
             Adds the root node to the tree, returning the new item.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to
             use for unselected and selected items, respectively. If <c>image > -1</c> and <c>selImage is -1</c>, the same image is
             used for both selected and unselected items.
             
             This method reflects the  wxWidgets 2.6 requirement that <c>data</c> must not be <c>null</c> on hidden roots.
             Do not provide already used instances for <c>data</c>. This method will raise exceptions in that cases.
             </summary>
             <param name="text">The name of the root node</param>
             <param name="image">The index of the image that shall be presented with the node.</param>
             <param name="selImage">The index of the image that shall be presented with the node if the node is selected.</param>
        </member>
        <member name="M:WX.TreeCtrl.AppendItem(WX.TreeItemId,System.String)">
            <summary>
            Appends an item to the end of the branch identified by parent, return a new item id.
            
            Please note, that an appended item may not be visible because the parent is not expanded.
            So, you might want to use <c>EnsureVisible</c> after calling this method.
            </summary>
            <param name="parentId">The parent node that will get a new child.</param>
            <param name="text">The label text of the new node.</param>
            <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:WX.TreeCtrl.AppendItem(WX.TreeItemId,System.String,System.Int32)">
            <summary>
            Appends an item to the end of the branch identified by parent, return a new item id.
            
            The specified image will be used to display the node if selected or unselected.
            
            Please note, that an appended item may not be visible because the parent is not expanded.
            So, you might want to use <c>EnsureVisible</c> after calling this method.
            </summary>
            <param name="parentId">The parent node that will get a new child.</param>
            <param name="text">The label text of the new node.</param>
            <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
            <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:WX.TreeCtrl.AppendItem(WX.TreeItemId,System.String,System.Int32,System.Int32)">
             <summary>
             Appends an item to the end of the branch identified by parent, return a new item id.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to use for
             unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both
             selected and unselected items.
             
             Please note, that an appended item may not be visible because the parent is not expanded.
             So, you might want to use <c>EnsureVisible</c> after calling this method.
             </summary>
             <param name="parentId">The parent node that will get a new child.</param>
             <param name="text">The label text of the new node.</param>
             <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
             <param name="selImage">An index in the image list of the control representing the icon of the node if selected or -1.
             </param>
             <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:WX.TreeCtrl.AppendItem(WX.TreeItemId,System.String,System.Int32,System.Int32,WX.TreeItemData)">
             <summary>
             Appends an item to the end of the branch identified by parent, return a new item id.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to use for
             unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both
             selected and unselected items.
             
             Please note, that an appended item may not be visible because the parent is not expanded.
             So, you might want to use <c>EnsureVisible</c> after calling this method.
             </summary>
             <param name="parentId">The parent node that will get a new child.</param>
             <param name="text">The label text of the new node.</param>
             <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
             <param name="selImage">An index in the image list of the control representing the icon of the node if selected or -1.
             </param>
             <param name="data">Additional data that is associated with the node or <c>null</c>.</param>
             <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:WX.TreeCtrl.AssignImageList(WX.ImageList)">
            <summary>
            Assigns an image list to the control containing the icons of the nodes.
            </summary>
            <param name="imageList">The image list containing the icons.</param>
        </member>
        <member name="M:WX.TreeCtrl.DeleteAllItems">
            <summary>
            Deletes all items in the control.
            Note that this may not generate EVT_TREE_DELETE_ITEM events under some Windows versions although
            normally such event is generated for each removed item.
            </summary>
        </member>
        <member name="M:WX.TreeCtrl.IsSelected(WX.TreeItemId)">
            <summary>
            True if the argument is a selected item.
            </summary>
            <param name="item">The item of interest.</param>
            <returns>True iff the provided item is selected.</returns>
        </member>
        <member name="M:WX.TreeCtrl.SelectItem(WX.TreeItemId)">
            <summary>
            SWets the selected item.
            </summary>
            <param name="item">The item that will be selected.</param>
        </member>
        <member name="M:WX.TreeCtrl.SetItemText(WX.TreeItemId,System.String)">
            <summary>
            Set the text associated with the tree item.
            </summary>
            <param name="item">designator of the tree item.</param>
            <param name="text">Text that will be associated with the tree item.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetItemText(WX.TreeItemId)">
            <summary>
            Returns the text that has been associated with this tree item.
            </summary>
            <param name="item">Designator of the tree item.</param>
        </member>
        <member name="M:WX.TreeCtrl.SetItemData(WX.TreeItemId,WX.TreeItemData)">
            <summary>Sets the client data for the provided item.
            This will raise an exception if <c>data</c> is already in use with other tree items.
            </summary>
            <param name="item">Designates the tree item that will be associated with data.</param>
            <param name="data">Is the data that will be associated with the designated tree item.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetItemData(WX.TreeItemId)">
            <summary>
            Returns the item data that has been stored for the designated tree item.
            </summary>
            <param name="item">Designates  the tree node whose data is requested.</param>
            <returns>The tree item data instance of <c>null</c>.</returns>
        </member>
        <member name="M:WX.TreeCtrl.FindLabels(System.String,WX.TreeCtrl.LabelMatch)">
            <summary>
            Returns an array of tree item identifiers designating those tree items with labels matching the provided string. 
            </summary>
            <param name="requestString">The string that shall be searched in item labels.</param>
            <param name="labelMatch">The method for comparing labels and request string.</param>
        </member>
        <member name="M:WX.TreeCtrl.FindFirstWithLabel(System.String,WX.TreeCtrl.LabelMatch)">
            <summary>
            Finds the first tree item whose label matches the provided request string.
            </summary>
            <param name="requestString">The string that shall be searched in item labels.</param>
            <param name="labelMatch">The method for comparing labels and request string.</param>
            <returns>The id of a matching tree item or <c>null</c> if nothing matches.</returns>
        </member>
        <member name="M:WX.TreeCtrl.GetItemParent(WX.TreeItemId)">
            <summary>
            The parent of the designated tree node. The result may be invalid of the argument is the root.
            </summary>
            <param name="item">The tree node.</param>
            <returns></returns>
        </member>
        <member name="M:WX.TreeCtrl.GetFirstChild(WX.TreeItemId,System.IntPtr@)">
            <summary>
            Returns the first child of the designated tree node. Creates a cookie representing this enumeration.
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <param name="cookie">This designates the enumeration. The cookie represents a state of enumeration.</param>
            <see cref="M:WX.TreeCtrl.GetChildren(WX.TreeItemId)"/>
        </member>
        <member name="M:WX.TreeCtrl.GetNextChild(WX.TreeItemId,System.IntPtr@)">
            <summary>
            Returns the next child of the designated tree node..
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <param name="cookie">This designates the enumeration. The cookie represents a state of enumeration.</param>
            <see cref="M:WX.TreeCtrl.GetChildren(WX.TreeItemId)"/>
        </member>
        <member name="M:WX.TreeCtrl.GetLastChild(WX.TreeItemId)">
            <summary>
            Returns the last child of the designated tree node.
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <see cref="M:WX.TreeCtrl.GetChildren(WX.TreeItemId)"/>
        </member>
        <member name="M:WX.TreeCtrl.GetChildren(WX.TreeItemId)">
            <summary>An array comprising all direct children of the argument or <c>null</c> if argument designates a
            leaf node.</summary>
            <param name="item">This method will collect the children of this tree node.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetNextSibling(WX.TreeItemId)">
             <summary>
             Returns the next sibling of the specified item; call wx.TreeCtrl.GetPrevSibling() for the next sibling.
            
             Returns an invalid tree item if there are no further children.
             </summary>
        </member>
        <member name="M:WX.TreeCtrl.GetPrevSibling(WX.TreeItemId)">
             <summary>
             Returns the previous sibling of the specified item; call wx.TreeCtrl.GetNextSibling() for the next sibling.
            
             Returns an invalid tree item if there are no further children.
             </summary>
        </member>
        <member name="M:WX.TreeCtrl.GetFirstVisibleItem">
            <summary>
            Returns the first visible item.
            </summary>
            <seealso cref="M:WX.TreeCtrl.GetNextVisible(WX.TreeItemId)"/>
            <seealso cref="M:WX.TreeCtrl.GetPrevVisible(WX.TreeItemId)"/>
            <seealso cref="M:WX.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:WX.TreeCtrl.GetNextVisible(WX.TreeItemId)">
            <summary>
            Returns the next visible item following the argument.
            </summary>
            <param name="item">This will return the next item following this one.</param>
            <seealso cref="!:GetFirstVisible"/>
            <seealso cref="M:WX.TreeCtrl.GetPrevVisible(WX.TreeItemId)"/>
            <seealso cref="M:WX.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:WX.TreeCtrl.GetPrevVisible(WX.TreeItemId)">
            <summary>
            Returns the previsous visible item.
            </summary>
            <param name="item">This will return the next item following this one.</param>
            <seealso cref="!:GetFirstVisible"/>
            <seealso cref="M:WX.TreeCtrl.GetNextVisible(WX.TreeItemId)"/>
            <seealso cref="M:WX.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:WX.TreeCtrl.GetVisibleItems">
            <summary>An array comprising all visible tree node items or <c>null</c> if nothing is visible.</summary>
            <param name="item">This method will collect the children of this tree node.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetAllItems">
            <summary>
            Returns the IDs of all nodes that have been added to the control beginning with the root node.
            The result will be <c>null</c> iff this is empty.
            </summary>
        </member>
        <member name="M:WX.TreeCtrl.Expand(WX.TreeItemId)">
            <summary>
            Expands the designated tree node.
            </summary>
            <param name="item">The node to be expanded.</param>
        </member>
        <member name="M:WX.TreeCtrl.Collapse(WX.TreeItemId)">
            <summary>
            Collapses the designated tree node.
            </summary>
            <param name="item">The node to be collapsed.</param>
        </member>
        <member name="M:WX.TreeCtrl.EnsureVisible(WX.TreeItemId)">
            <summary>
            Ensures by node expansion and scrolling that the designated item is visible.
            </summary>
            <param name="item">The item that shall be visible.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetChildrenCount(WX.TreeItemId)">
            <summary>Get number of direct and indirect (recursively found) children.
            </summary>
            <param name="item">Designator of the root node. This method will return 0 if this is not OK.</param>
        </member>
        <member name="M:WX.TreeCtrl.GetChildrenCount(WX.TreeItemId,System.Boolean)">
            <summary>Get the number of direct (<c>recursively</c> is false) or also of children of children etc.
            </summary>
            <param name="item">Designator of the root node. This method will return 0 if this is not OK.</param>
            <param name="recursively">This will also count children of children of <c>item</c> iff true.</param>
        </member>
        <member name="M:WX.TreeCtrl.InsertItem(WX.TreeItemId,WX.TreeItemId,System.String,System.Int32,System.Int32,WX.TreeItemData)">
            <summary>Inserts a new item into the tree.
            Please note, that the tree control will take ownership of the C++ instance wrapped by <c>data</c>.
            So, do not use an instance for <c>data</c> that has already been used.</summary>
        </member>
        <member name="P:WX.TreeCtrl.Selection">
            <summary>Get or set the selection.
            The result will not be OK if nothing is selected.
            </summary>
        </member>
        <member name="P:WX.TreeCtrl.RootItem">
            <summary>
            The root node of the presented tree.
            </summary>
        </member>
        <member name="P:WX.TreeCtrl.Count">
            <summary>
            The number of the contained nodes.
            </summary>
        </member>
        <member name="T:WX.TreeCtrl.HitTestFlags">
            <summary>Flags representing possible classifications of wx.TreeCtrl.HitTest().</summary>
        </member>
        <member name="F:WX.TreeCtrl.HitTestFlags.None">
            <summary>This simply indicates nothing.
            Useful to initialize. This is the 0.
            </summary>
        </member>
        <member name="T:WX.TreeCtrl.LabelMatch">
            <summary>
            Method to detect matching labels in FindLabels().
            </summary>
        </member>
        <member name="F:WX.TreeCtrl.LabelMatch.Exact">
            <summary>
            Exact match. Only equal labels match.
            </summary>
        </member>
        <member name="F:WX.TreeCtrl.LabelMatch.Contains">
            <summary>
            All labels containing the request string match.
            </summary>
        </member>
        <member name="F:WX.TreeCtrl.LabelMatch.EqualsIgnoreCase">
            <summary>
            All labels match that are equal to the request string ignoring the difference between upper and lower case letters.
            </summary>
        </member>
        <member name="F:WX.TreeCtrl.LabelMatch.ContainsIgnoreCase">
            <summary>
            All labels containing the request string ignoring the case match.
            </summary>
        </member>
        <member name="T:WX.ReflectConfig">
            <summary>Class providing some methods to check availability of conditional code and compatiblity of <c>WX.Net.dll</c> and <c>wx-c.dll</c>.
            
            This class provides some static methods but is also an attribute of the assembly.
            So, laoders of this assembly may analyse this before use.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.#ctor">
            <summary>This generates an attribute where the provided text is followed by a description of the conditional compilation.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.AssertWxWinVersion28">
            <summary>Raises an exception of those features introduced with  wxWidgets 2.8.0 are not available.
            Cf. CheckWxWinVersion28().</summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckWxWinVersion28">
            <summary>Tests whether the features introduced with  wxWidgets 2.8.0 are available.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckWxGTK">
            <summary>Test for availability of code particular for <c>__WXGTK__</c>.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckWxMSW">
            <summary>Test for availability of code particular for <c>__WXMSW__</c>.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckWxMAC">
            <summary>Test for availability of code particular for <c>__WXMAC__</c>.
             This is in fact rather a query whether code shall be avoided that cannot be provided
             for Apple Macintosh computers.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckWxNetDisplay">
            <summary>Test for availability of <c>WXNET_DISPLAY</c> code.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckStyledTextCtrl">
            <summary>This tests for the availability of STC ( define <c>WXNET_STYLEDTEXTCTRL</c> ).
             This shows availability of StyledTextCtrl.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckUseTabDialog">
            <summary>Checks for the availability of the TabCtrl class.
            This class is currently only available with CheckWxMSW().
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckUseUnicode">
            <summary>Checks for the availability of Unicode support in the linked  wxWidgets library.
            Currently, native Unicode support in <c>wxString</c> will not be used for conditional
            compilation but might be interest for if-then conditions in some code.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckCompatibility">
            <summary>Runtime-check: Tests whether <c>WX.Net</c> does not require more features than <c>wx-c.dll</c> provides.
             Please note that unfortunately this cannot be tested for defines of <c>WX.Net</c> that do not have
             an equivalent in <c>wxWidgets</c>. These defines have the prefix <c>WXNET_</c> .
             
             If this is <c>false</c> then several classes cannot be used since they
             require functions in the <c>wx-c.dll</c> according to the <c>WX.Net</c> configuration
             that have not been compiled due to the configuration of the used  wxWidgets
             system.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.CheckInternalUseUTF8">
            <summary>This is <c>true</c> iff the  WX.Net is configured for internal use of UTF 8 strings.
            This option is for instance relevant to the PNET implementation of the .NET framework.
            </summary>
        </member>
        <member name="M:WX.ReflectConfig.ConfigurationString">
            <summary>Returns an english string describing the configuration.
            </summary>
        </member>
        <member name="P:WX.ReflectConfig.Version28">
            \name These are the properties that one can read from the attribute.
            Instances of this class provide possibles attributes of this assembly.
            These properties define the information rovided by this attribute.
            Additionally, we have a ToString() method here that returns the
            ConfigurationString().
        </member>
        <member name="T:WX.RadioBox">
            <summary>This control throws exceptions on creating instances without providing choices.
            According to the wxWidgets documentation, this is a control with items but it is not.
            You can neither add items dynamically not associate items with client data.
            </summary>
        </member>
        <member name="P:WX.KeyEvent.KeyCode">
            <summary>The keycode with values from Enumeration KeyCode. Refer also to KeyCodeSymbol.</summary>
        </member>
        <member name="P:WX.KeyEvent.RawKeyCode">
            <summary>Returns the raw, uninterpreted, platform dependent key code.
            </summary>
        </member>
        <member name="P:WX.KeyEvent.RawKeyFlags">
            <summary>Returns the low level key flags for this event.
            The flags are platform-dependent and should only be used in advanced applications.</summary>
        </member>
        <member name="P:WX.KeyEvent.UnicodeChar">
            <summary>Returns the wide character equivalent to the pressed key.
            This only works correctly if either  wxWidgets has been built with Unicode support or if an ASCII key
            has been pressed. Otherwise, the result will be a 0.</summary>
        </member>
        <member name="M:WX.ImageHandler.CanRead(System.Byte[])">
            <summary>Returns true iff this handler can read the provided stream.
            </summary>
        </member>
        <member name="M:WX.ImageHandler.CanRead(System.String)">
            <summary>Returns true iff this handler can read the file of the provided name.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Image" ignoriert -->
        <member name="M:WX.Image.BufferFromZipResource(System.String,System.String)">
            <summary>Helper reading a byte buffer from a zip resource.</summary>
        </member>
        <member name="M:WX.Image.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary>
                     * <remarks>
                     * This will load image <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
                     * \code
                     wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
                     wx.Image img=new wx.Image("archiveName.zrs", "iconname.png");
                     \endcode
                     * </remarks>
        </member>
        <member name="M:WX.Image.RemoveHandler(System.String)">
            <summary>Removes the image handler of the provided name.
             The handler is not deleted. So, please ensure that the designated
             handler has a WX.Net wrapper for instancestoring a reference to
             FindHandler().
            </summary>
        </member>
        <member name="P:WX.Image.MaskColour">
            <summary>
            Get or set the colour defining the mask. The mask colour will be shown transparent.
            This will return <c>null</c> if not <c>this.Mask</c>.
            </summary>
        </member>
        <member name="T:WX.DirDialog">
            <summary>A dialog to ask for either one or many directories.</summary>
            <remarks>
            If appropriate, you may use the DirSelector instead.
            Available styles:
            <list type="table">
            <item><term>wx.WindowStyles.DD_Default_STYLE</term><description>Equivalent to a combination of wxDefault_DIALOG_STYLE and wxResizeBorder (the last one is not used under wxWinCE).</description></item>
            <item><term>wx.WindowStyles.DD_DIR_MUST_EXIST</term><description>The dialog will allow the user to choose only an existing folder. When this style is not given, a "Create new directory" button is added to the dialog (on Windows) or some other way is provided to the user to type the name of a new folder.</description></item>
            <item><term>wx.WindowStyles.DD_CHANGE_DIR</term><description>Change the current working directory to the directory chosen by the user.</description></item>
            </list>
            NB: on Windows the new directory button is only available with recent versions of the common dialogs.
            </remarks>
        </member>
        <member name="P:WX.DirDialog.Path">
            <summary>
            The path that has been selected.
            </summary>
        </member>
        <member name="T:WX.Button">
            <summary>Class of buttons with text labels. Refer also to wx.BitmapButton.
            Style flags (enumeration wx.WindowStyles) applying to this class of control
            in particular start with "Button" as prefix.</summary>
        </member>
        <member name="M:WX.Button.#ctor">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from this list, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
        </member>
        <member name="M:WX.Button.#ctor(WX.Window,System.Int32,System.String)">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from MenuIDs, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
            <param name="id">ID of the button. If you use one of the stock button IDs from class MenuIDs, WX.Net replaces an empty label by a standard value.</param>
            <param name="label">Label of the button. If this is empty and the button id is one of MenuIDs associated with a stock label (and stock image under GTK 2), WX.Net will use this stock data.</param>
            <param name="parent">The parent window.</param>
        </member>
        <member name="M:WX.Button.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point)">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from MenuIDs, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
            <param name="id">ID of the button. If you use one of the stock button IDs from class MenuIDs, WX.Net replaces an empty label by a standard value.</param>
            <param name="label">Label of the button. If this is empty and the button id is one of MenuIDs associated with a stock label (and stock image under GTK 2), WX.Net will use this stock data.</param>
            <param name="pos">Position of the data.</param>
            <param name="parent">The parent window.</param>
        </member>
        <member name="M:WX.Button.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size)">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from MenuIDs, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
            <param name="id">ID of the button. If you use one of the stock button IDs from class MenuIDs, WX.Net replaces an empty label by a standard value.</param>
            <param name="label">Label of the button. If this is empty and the button id is one of MenuIDs associated with a stock label (and stock image under GTK 2), WX.Net will use this stock data.</param>
            <param name="size">Size of the button.</param>
            <param name="pos">Position of the data.</param>
            <param name="parent">The parent window.</param>
        </member>
        <member name="M:WX.Button.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from MenuIDs, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
            <param name="id">ID of the button. If you use one of the stock button IDs from class MenuIDs, WX.Net replaces an empty label by a standard value.</param>
            <param name="label">Label of the button. If this is empty and the button id is one of MenuIDs associated with a stock label (and stock image under GTK 2), WX.Net will use this stock data.</param>
            <param name="size">Size of the button.</param>
            <param name="pos">Position of the data.</param>
            <param name="parent">The parent window.</param>
            <param name="style">Style flags.</param>
        </member>
        <member name="M:WX.Button.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>
            The preferred way to create standard buttons is to use default value of label. If no label is supplied and id is one of standard IDs from MenuIDs, standard label will be used. In addition to that, the button will be decorated with stock icons under GTK+ 2.
            </summary>
            <param name="id">ID of the button. If you use one of the stock button IDs from class MenuIDs, WX.Net replaces an empty label by a standard value.</param>
            <param name="label">Label of the button. If this is empty and the button id is one of MenuIDs associated with a stock label (and stock image under GTK 2), WX.Net will use this stock data.</param>
            <param name="size">Size of the button.</param>
            <param name="pos">Position of the data.</param>
            <param name="parent">The parent window.</param>
            <param name="style">Style flags.</param>
        </member>
        <member name="P:WX.ToolTip.Enabled">
            <summary>Enables or disables tolltips globally.
            May not be supported on all platforms (eg. <c>wxCocoa)</c>.</summary>
        </member>
        <member name="P:WX.ToolTip.Delay">
            <summary>Set the delay after which the tooltip appears in milliseconds.
            May not be supported on all platforms (eg. <c>wxCocoa)</c>.</summary>
        </member>
        <member name="P:WX.ScrollWinEvent.Position">
            <summary>
            This will provide the scrolling position if supported. 
            This is 0 if unsupported. This property is supoorted on EventHandler.EVT_SCROLLWIN_THUMBTRACK()
            and EventHandler.EVT_SCROLLWIN_THUMBRELEASE().
            </summary>
        </member>
        <member name="T:WX.NetMacros.TypeDescriptor">
            <summary>
            Simply a component containing  
            a namespace name, and a type name. The are the properties of a type
            that will be serialized.
            </summary>
        </member>
        <member name="M:WX.NetMacros.TypeDescriptor.#ctor">
            <summary>
            Creates a representation of type System.Object. 
            This ctor is meant to be used on deserialization.
            </summary>
        </member>
        <member name="M:WX.NetMacros.TypeDescriptor.CompareTo(System.Object)">
            <summary>
            Compares Name and Namespace.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.TypeDescriptor.Parse(System.String)">
            <summary>
            Parses a string and creates a type descriptor.
            </summary>
            <param name="str">A string like "M:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.TypeDescriptor.SetFromString(System.String)">
            <summary>
            Parses a string and sets the properties of this instance accordingly.
            </summary>
            <param name="str">A string like "M:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="T:WX.NetMacros.MemberType">
            <summary>
            Used to define in instances of member descriptor whether this is
            a method or a property.
            </summary>
        </member>
        <member name="T:WX.NetMacros.MemberDescriptor">
            <summary>
            Instances of this class combine a TypeDescriptor with an additional
            member name. Instances will be used to designate members of classes,
            properties or methods.
            </summary>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.#ctor">
            <summary>
            Default ctor creating a reference to the member Name of this class.
            This is a dummy that will be used be deserialization.
            </summary>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.#ctor(WX.NetMacros.MemberType,WX.NetMacros.TypeDescriptor,System.String)">
            <summary>
            Creates an instance of the specified properties.
            </summary>
            <param name="membertype">The type of member (method or property)</param>
            <param name="type">The type declaring the member.</param>
            <param name="membername">the name of the member.</param>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.#ctor(System.Reflection.ConstructorInfo)">
            <summary>
            Creates an instance designating the provided constructor.
            </summary>
            <param name="ci">Information on a constructor.</param>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Creates an instance designating the provided property.
            </summary>
            <param name="pi">Information on a property</param>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Creates an instance designating the provided method.
            </summary>
            <param name="mi">Information on a method</param>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.Parse(System.String)">
            <summary>
            This will parse strings of the form <c>"M:Namespace.ClassName.MemberName"</c>.
            </summary>
            <param name="str">The properties of the returned instance as string.</param>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.GetNameInClass">
            <summary>
            Returns a human readable string identifying the member within the class. This is usually the property name or
            method name. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.MemberDescriptor.SetFromString(System.String)">
            <summary>
            Parses a string and sets the properties of this instance accordingly.
            </summary>
            <param name="str">A string like "T:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="T:WX.NetMacros.MethodDescriptor">
            <summary>
            A member descriptor with attached signature - list of types in a parameter list. 
            </summary>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.#ctor">
            <summary>
            Crates empty data. Use this e.g. for serialization.
            </summary>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.#ctor(System.Reflection.ConstructorInfo)">
            <summary>
            Creates an instance describing the provided constructor.
            </summary>
            <param name="ci">The designated constructor</param>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Creates an instance describing the provided method.
            </summary>
            <param name="mi">The designated method</param>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.Parse(System.String)">
            <summary>
            Creates an instance referring to the provided string.
            This will expect a string of the format
            <c>"M:Namespace.Classname.Methodname(Namespace.TypeOfArg0,Namespace.TypeOfArg1)"</c>
            </summary>
            <param name="str"></param>
            <exception cref="T:System.FormatException">Thrown if string is of an unknown format.</exception>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.GetSignatureString(System.String[])">
            <summary>
            A human readable string describing the signature of this method.
            </summary>
            <param name="knownNamespaces">An array of the names of those namespaces that can be considered as imported.
            Add those namespaces here that shall not be printed in order to keep the result compact.</param>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.GetNameInClass">
            <summary>
            Returns a human readable string identifying the member within the class. This is usually the property name or
            method name. 
            </summary>
        </member>
        <member name="M:WX.NetMacros.MethodDescriptor.SetFromString(System.String)">
            <summary>
            Loads the properties of this instance according to the provided string.
            This will expect a string of the format
            <c>"M:Namespace.Classname.Methodname(Namespace.TypeOfArg0,Namespace.TypeOfArg1)"</c>
            </summary>
            <param name="str"></param>
            <exception cref="T:System.FormatException">Thrown if string is of an unknown format.</exception>
        </member>
        <member name="P:WX.NetMacros.MethodDescriptor.Generalized">
            <summary>
            Generalized form without argument list. An unspecific designation of
            all implementations of the method.
            </summary>
        </member>
        <member name="T:WX.NetMacros.MethodCall">
            <summary>
            Represents a call to a method.
            </summary>
        </member>
        <member name="M:WX.NetMacros.MethodCall.#ctor">
            <summary>
            Used for serializaton. Produces a call to System.Object.ToString().
            </summary>
        </member>
        <member name="M:WX.NetMacros.MethodCall.#ctor(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Creates a call of method <c>mi</c> of object <c>self</c> with parameters <c>args</c>.
            This ctor will not test the consistency of hte arguments, i.e. whether this is of the
            declaring type of the method.
            </summary>
            <param name="mi">This is the method that will be called.</param>
            <param name="self">This is the object where the method will be called. This parameter will be ignored on static
            methods.</param>
            <param name="args">These objects will be passed as parameters to the method.</param>
        </member>
        <member name="P:WX.NetMacros.MethodCall.Method">
            <summary>
            Descriptor of the method that will be called.
            </summary>
        </member>
        <member name="P:WX.NetMacros.MethodCall.Self">
            <summary>
            This is the object that implements the method. The method will be called at this object.
            This will be <c>null</c> on static methods.
            </summary>
        </member>
        <member name="P:WX.NetMacros.MethodCall.Args">
            <summary>
            The arguments that will be passed to the method as parameters. this shall be <c>null</c>
            for methods without arguments.
            </summary>
        </member>
        <member name="P:WX.NetMacros.MethodCall.IsStatic">
            <summary>
            True iff the called method is static.
            </summary>
        </member>
        <member name="T:WX.NetMacros.SetterCall">
            <summary>
            Represents the assignment to a property. Properties are: A descriptor of the property and the
            assigned value.
            </summary>
        </member>
        <member name="M:WX.NetMacros.SetterCall.#ctor(System.Reflection.PropertyInfo,System.Object,System.Object)">
            <summary>
            Represents setting the value from the parameters to the property designated by the property info.
            </summary>
            <param name="pi">The property that will be set.</param>
            <param name="self">The object that exhibits this property and that will be changed on setting a value.</param>
            <param name="value">The value that will be set.</param>
        </member>
        <member name="M:WX.NetMacros.SetterCall.#ctor">
            <summary>
            This will be used by the XmlSerializer - a dumy action: Assigning 0 to property Value
            of this class.
            </summary>
        </member>
        <member name="P:WX.NetMacros.SetterCall.Self">
            <summary>
            The object that exhibits this property and that will be changed on setting a value.
            </summary>
        </member>
        <member name="P:WX.NetMacros.SetterCall.Value">
            <summary>
            The value that will be assigned.
            </summary>
        </member>
        <member name="P:WX.NetMacros.SetterCall.Property">
            <summary>
            The property that will get a new value on evaluating this. Only assign members of correct
            member type.
            </summary>
        </member>
        <member name="T:WX.NetMacros.UserInputRequired">
            <summary>
            Instances of this class represent missing arguments in method calls and generators.
            Instances of this class appear in generators and setter calls etc. that cannot be
            executed without replacing these dummy instances by an instance of an appropriate type.
            </summary>
        </member>
        <member name="M:WX.NetMacros.UserInputRequired.#ctor(System.Type)">
            <summary>
            Creates an instance. The argument describes the required user input.
            </summary>
            <param name="typeOfRequiredInput"></param>
        </member>
        <member name="M:WX.NetMacros.UserInputRequired.#ctor">
            <summary>
            Creates an instance that uses System.Object as type of required user input.
            </summary>
        </member>
        <member name="P:WX.NetMacros.UserInputRequired.TypeOfRequiredInput">
            <summary>
            The type of the required user input.
            </summary>
        </member>
        <member name="T:WX.NetMacros.Generator">
            <summary>
            Base class of all visual components. This class simply represents a call to the 
            constructor of a class. You may add a sequence of setter calls to modify the created instance.
            You may add a sequence of method calls to modify the created instance.
            </summary>
        </member>
        <member name="F:WX.NetMacros.Generator._args">
            <summary>
            Arguments that will passed to the method described below.
            </summary>
        </member>
        <member name="F:WX.NetMacros.Generator._mi">
            <summary>
            Describes either a static method producing an instance or a constructor.
            </summary>
        </member>
        <member name="M:WX.NetMacros.Generator.#ctor">
            <summary>
            Default ctor. 
            Is needed for serialization.
            </summary>
        </member>
        <member name="M:WX.NetMacros.Generator.#ctor(System.Type,System.Object[])">
            <summary>
            Creates an instance of this class providing a type and an array of arguments for a constructor.
            </summary>
            <param name="type">This ís a factory that will create instances of this type. This must not be an
            abstract type.</param>
            <param name="ctorArgs">Arguments to the ctor of <c>type</c> that shall be used. Instances of 
            the classes WX.NetMacros.Generator and WX.NetMacros.MethodCall will not be passed as arguments to
            this generator on creating an instance. The runtime environment will rather execute these instances
            and use the result as argument.</param>
        </member>
        <member name="M:WX.NetMacros.Generator.#ctor(System.Reflection.ConstructorInfo,System.Object[])">
            <summary>
            This will create an instance using the provided constructor.
            </summary>
            <param name="ci">Descriptor of the method that creates the instance.</param>
            <param name="methodArgs">Argument list that will be passed to the designated method. This can be <c>null</c>.
            In that case, the argument list will be a tuple of UserInputRequired instances.</param>
        </member>
        <member name="M:WX.NetMacros.Generator.#ctor(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            This will create an instance using the provided method.
            If the method descriptor designates a static method, the arguments will be passed to
            this method as provided to this ctor. If the method descriptor designated a non-static
            method, this method will be called at the first element of the argument list. The rest of
            the argument list will be passed as arguments to the called method.
            </summary>
            <param name="mi">Descriptor of the method that creates the instance.</param>
            <param name="methodArgs">Argument list that will be passed to the designated method. This can be <c>null</c>.
            In that case, the argument list will be a tuple of UserInputRequired instances.</param>
        </member>
        <member name="M:WX.NetMacros.Generator.AddSetter(WX.NetMacros.SetterCall)">
            <summary>
            Adds a new assignment that shall be executed immediately after the new instance has been created.
            The declaring type of the property of the setter shall be if the same class as the instance
            that has been created by this generator. Setters will run in the order in which they have been added
            before the modifiers. The SetterCall.Self member will be ignored. Please note, that side effects on this
            property might happen while executing the generator.
            </summary>
            <param name="sc"></param>
        </member>
        <member name="M:WX.NetMacros.Generator.AddModifier(WX.NetMacros.MethodCall)">
            <summary>
            Adds a method that will be called in <c>Create</c> immediately after creating the instance.
            This makes only sense if this method is a modifier. The added modifiers will be called in the
            order  in which they have been added. Modifiers will be evaluated after the setters have been executed.
            The SetterCall.Self member will be ignored. Please note, that side effects on this
            property might happen while executing the generator.
            </summary>
            <param name="mc"></param>
        </member>
        <member name="P:WX.NetMacros.Generator.Creator">
            <summary>
            The method or CTor that will be run to create the inital instance.
            </summary>
            <seealso cref="!:Create"/>
        </member>
        <member name="P:WX.NetMacros.Generator.DeclaringType">
            <summary>
            This instance will create an instance of this type.
            </summary>
            <seealso cref="!:Create"/>
        </member>
        <member name="P:WX.NetMacros.Generator.Args">
            <summary>
            This will try to create an instance of <c>CreateInstanceOfType</c>
            using these arguments.
            </summary>
        </member>
        <member name="P:WX.NetMacros.Generator.AreArgsUnknown">
            <summary>
            True if the arguments to the encapsulated CTor or method are unknown.
            </summary>
        </member>
        <member name="P:WX.NetMacros.Generator.IsInputRequired">
            <summary>
            True if this contains an argument list but at least on of the arguments is an instance of UserInputRequired.
            </summary>
            <seealso cref="T:WX.NetMacros.UserInputRequired"/>
        </member>
        <member name="P:WX.NetMacros.Generator.Modifiers">
            <summary>
            Modifiers that will be called in <c>Create</c> immediately after the instance has been created.
            </summary>
        </member>
        <member name="T:WX.NetMacros.RuntimeEnv">
            <summary>
            A very simple execution environment for runable components of the .NET macro collection.
            </summary>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.#ctor(System.Reflection.Assembly[])">
            <summary>
            Creates a runtime environment where all public ctors, methods, and properties 
            of the listed assemblies can be called.
            </summary>
            <param name="callableAssembles">A collection of assemblies. All ctors, methods, and properties of these 
            assemblies can be called/executed in this runtime environment.</param>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetType(WX.NetMacros.TypeDescriptor)">
            <summary>
            Finds the type designated by the descriptor in the parameter list.
            </summary>
            <param name="ti">Name and namespace of the type to return.</param>
            <returns>The designated type or <c>null</c> if non of the callable assemblies
            knows a type of the requested name.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetType(WX.NetMacros.TypeDescriptor,System.Boolean)">
            <summary>
            Finds the type designated by the descriptor in the parameter list.
            </summary>
            <param name="ti">Name and namespace of the type to return.</param>
            <param name="considerAllAssembliesOfTheDomain">With <c>true</c>, this method will search all known types. With
            <c>false</c>, only the assemblies of the callable assemblies will be searched.</param>
            <returns>The designated type or <c>null</c> if non of the callable assemblies
            knows a type of the requested name.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetMethod(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns information on the method designated by the argument.
            </summary>
            <param name="mi">A member designator that is expected to designate a method.</param>
            <returns>Information on the designated method or <c>null</c> if hte method has not been found.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetConstructor(WX.NetMacros.MethodDescriptor)">
            <summary>
            Returns the constructor information on the ctor of the signature that is represented
            by the argument.
            </summary>
            <param name="md">A descriptor of teh requested ctor defining a signature,</param>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetParameters(WX.NetMacros.MethodDescriptor)">
            <summary>
            Returns a list of parameters of the method designated by the argument.
            </summary>
            <param name="md">Specifis the method or constructor whose parameters shall be returned.</param>
            <returns></returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetProperty(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns information on the property designated by the argument.
            </summary>
            <param name="mi">A member designator that is expected to designate a property.</param>
            <returns>Information on the designated method or <c>null</c> if hte property has not been found.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.GetDescriptor(System.String)">
            <summary>
            Tries to parse the given string as MethodDescriptor, MemberDescriptor, or TypeDescriptor
            and search for a corresponding code object in the assembles forming this runtime environment.
            </summary>
            <param name="classnameOrMethodOrProperty"></param>
            <returns>A TypeDescriptor, a MethodDescriptor, or a MemberDescriptor. The result is <c>null</c>
            if nothing can be parsed.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.Invoke(WX.NetMacros.MethodCall)">
            <summary>
            Executes a mathod.
            </summary>
            <param name="mc">The method to be executed.</param>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
            <returns>The object that results from the call. This is <c>null</c> for <c>void</c> methods.</returns>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.Invoke(WX.NetMacros.SetterCall)">
            <summary>
            Executes a setter.
            </summary>
            <param name="sc">The setter (assignment to a property) that will be executed.</param>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
        </member>
        <member name="M:WX.NetMacros.RuntimeEnv.CreateInstance(WX.NetMacros.Generator)">
            <summary>
            Creates an instance following the instructions included in the provided generator.
            This method will change MethodCall.Self and SetterCall.Self of all stters and modifiers
            of the generator: Self will be set to the newly created instance.
            </summary>
            <param name="generator">Activator call and subsequent setter and modifier calls that shall be executed to create
            the desired instance.</param>
            <returns>The created instance.</returns>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
        </member>
        <member name="P:WX.NetMacros.RuntimeEnv.CallableAssemblies">
            <summary>
            Returns a read-only collection of those assemblies forming the runtime environment.
            All public ctors, methods, and properties of these assembles my be accessed by actions
            executed by this runtime environment.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.NetMacros.GeneratorDataObject" ignoriert -->
        <member name="M:WX.NetMacros.GeneratorDataObject.#ctor">
            <summary>
            Creates an instance containing no data.
            </summary>
        </member>
        <member name="F:WX.NetMacros.GeneratorDataObject.UsedDataFormat">
            <summary>
            The data format of data complying with this class of data.
            </summary>
        </member>
        <member name="M:WX.NetMacros.GeneratorDataObject.#ctor(WX.NetMacros.Generator)">
            <summary>
            Creates an instance encapsulating the provided data.
            </summary>
            <param name="data">The generator expression that forms the data of this object.</param>
        </member>
        <member name="P:WX.NetMacros.GeneratorDataObject.Data">
            <summary>
            The encapsulated data.
            </summary>
        </member>
        <member name="P:WX.NetMacros.GeneratorDataObject.ByteData">
            <summary>
            This is a serialization of Data.
            </summary>
        </member>
        <member name="T:WX.MessageDialog">
            <summary>This class represents a dialog that shows a single or multi-line message, with a choice of OK, Yes, No and Cancel buttons.</summary>
        </member>
        <member name="M:WX.MessageDialog.#ctor(WX.Window,System.String)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
        </member>
        <member name="M:WX.MessageDialog.#ctor(WX.Window,System.String,System.String)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
        </member>
        <member name="M:WX.MessageDialog.#ctor(WX.Window,System.String,System.String,WX.WindowStyles)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
        </member>
        <member name="M:WX.MessageDialog.#ctor(WX.Window,System.String,System.String,WX.WindowStyles,System.Drawing.Point)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
        </member>
        <member name="M:WX.MessageDialog.#ctor(WX.Window,WX.wxString,WX.wxString,WX.WindowStyles,System.Drawing.Point)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
        </member>
        <member name="M:WX.MessageDialog.ShowModal">
            <summary>Shows the dialog, returning one of wx.ShowModalResult.</summary>
        </member>
        <member name="M:WX.MessageDialog.ShowModal(System.String,System.String,WX.WindowStyles)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.ShowModal(WX.Window,System.String,System.String,WX.WindowStyles)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.ShowModal(WX.Window,System.String,System.String,WX.WindowStyles,System.Drawing.Point)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.ShowModal(WX.Window,WX.wxString,WX.wxString,WX.WindowStyles,System.Drawing.Point)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.MessageBox(System.String)">
            <summary>
            Displays a dialog with cation "Message" (or a translation of "Message") and style wx.WindowStyles.DlgOk.
            </summary>
            <param name="msg">The text to be desplayed.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.MessageBox(System.String,System.String)">
            <summary>
            Displays a message dialog.
            </summary>
            <param name="msg">The text to be desplayed.</param>
            <param name="caption">The caption that will be display in the dialog's window decorator.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.MessageBox(System.String,System.String,WX.WindowStyles)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DlgOk.
            </summary>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.MessageBox(System.String,System.String,WX.WindowStyles,WX.Window)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DlgOk.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:WX.MessageDialog.MessageBox(System.String,System.String,WX.WindowStyles,WX.Window,System.Drawing.Point)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DlgOk.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DlgOk | WindowStyles.IconInformation</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellDateTimeRenderer">
            <summary>
            Wrapper of the <c>wxGridCellDateTimeRenderer</c>.
            This editor uses format strings according to wxWidgets convention for output - that is in fact
            the convention of the standard C/C++ function \c strftime. Refer to GridCellDateTimeMaskRenderer
            for a more .NET like implementation.
            </summary>
            <remarks>
            These are the elements of \c strftime format strings:
            <list type="table">
            <item><term>&amp;a</term>
            <description>Abbreviated weekday name </description></item>
            <item><term>&amp;A</term>
            <description>Full weekday name </description></item>
            <item><term>&amp;b</term>
            <description>Abbreviated month name </description></item>
            <item><term>&amp;B</term>
            <description>Full month name </description></item>
            <item><term>&amp;c</term>
            <description>Date and time representation appropriate for locale </description></item>
            <item><term>&amp;d</term>
            <description>Day of month as decimal number (01 – 31) </description></item>
            <item><term>&amp;H</term>
            <description>Hour in 24-hour format (00 – 23) </description></item>
            <item><term>&amp;I</term>
            <description>Hour in 12-hour format (01 – 12) </description></item>
            <item><term>&amp;j</term>
            <description>Day of year as decimal number (001 – 366) </description></item>
            <item><term>&amp;m</term>
            <description>Month as decimal number (01 – 12) </description></item>
            <item><term>&amp;M</term>
            <description>Minute as decimal number (00 – 59) </description></item>
            <item><term>&amp;p</term>
            <description>Current locale's A.M./P.M. indicator for 12-hour clock </description></item>
            <item><term>&amp;S</term>
            <description>Second as decimal number (00 – 59) </description></item>
            <item><term>&amp;U</term>
            <description>Week of year as decimal number, with Sunday as first day of week (00 – 53) </description></item>
            <item><term>&amp;w</term>
            <description>Weekday as decimal number (0 – 6; Sunday is 0) </description></item>
            <item><term>&amp;W</term>
            <description>Week of year as decimal number, with Monday as first day of week (00 – 53) </description></item>
            <item><term>&amp;x</term>
            <description>Date representation for current locale </description></item>
            <item><term>&amp;X</term>
            <description>Time representation for current locale </description></item>
            <item><term>&amp;y</term>
            <description>Year without century, as decimal number (00 – 99) </description></item>
            <item><term>&amp;Y</term>
            <description>Year with century, as decimal number </description></item>
            <item><term>&amp;z, &amp;Z</term>
            <description>Either the time-zone name or time zone abbreviation, depending on registry settings; no characters if time zone is unknown </description></item>
            <item><term>&amp;&amp;</term>
            <description>Percent sign </description></item>
            <item><term>&amp;#a, &amp;#A, &amp;#b, &amp;#B, &amp;#p, &amp;#X, &amp;#z, &amp;#Z, &amp;#&amp; </term>
            <description> # flag is ignored.</description></item>
            <item><term>&amp;#c</term><description>Long date and time representation, appropriate for current locale.
            For example: "Sunday, October 3, 2010, 11:32:22".</description></item>
            <item> <term>&amp;#x</term>
            <description>Long date representation, appropriate to current locale. For example: "Sunday, October 3, 2010".</description> </item>
            <item><term>&amp;#d, &amp;#H, &amp;#I, &amp;#j, &amp;#m, &amp;#M, &amp;#S, &amp;#U, &amp;#w, &amp;#W, &amp;#y, &amp;#Y </term>
            <description>Remove leading zeros (if any).</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellStringRenderer">
            <summary>This renderer draws strings.
            You may overload some methods to change the appearance.
            Overridung is supported.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellStringRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellDateTimeRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellEnumRenderer">
            <summary>Renders an enumeration.
            Enumerations are specified either as comma separated list or as an array of strings.
            However, also this array will be passed to the renderer as comma separated list so avoid
            comma in items.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellEnumRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellEnumRenderer.#ctor(System.String)">
            <summary>Argument is a comma separated list.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellEnumRenderer.#ctor(WX.wxString)">
            <summary>Argument is a comma separated list.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellEnumRenderer.SetParameters(System.String)">
            <summary>The <c>parameter</c> is a comma separated list of the items to be rendered.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellEnumEditor">
            <summary>Editor for an enumeration.
            Enumerations are specified either as comma separated list or as an array of strings.
            However, also this array will be passed to the renderer as comma separated list so avoid
            comma in items.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellChoiceEditor">
            <summary>
            The editor for string data allowing to choose from a list of strings.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellChoiceEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellChoiceEditor.PaintBackground(System.Drawing.Rectangle,WX.GridCtrl.GridCellAttr)">
            <summary>
            Draws the part of the cell not occupied by the control: the base class version just fills it with background colour from the attribute.
            </summary>
            <param name="rectCell"></param>
            <param name="attr"></param>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEnumEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEnumEditor.#ctor(System.String)">
            <summary>Argument is a comma separated list of items.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellEnumEditor.#ctor(WX.wxString)">
            <summary>Argument is a comma separated list of items.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellAutoWrapStringEditor">
            <summary>String editor for potentially longer strings containing blanks.
            You may input explicit line breaks using the CTRL key in conjunctions
            with the return or enter key.</summary>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellTextEditor">
            <summary>Editor for string.
            You may use the wx.GridCellAutoWrapStringEditor alternatively.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellTextEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellAutoWrapStringEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellAutoWrapStringRenderer">
            <summary>String renderer for potentially longer strings containing blanks.
            Texts rendered by instances of this class will not overlap into empty cells
            in the neighbourhood. Longer strings will be displayed wrapped instead.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellAutoWrapStringRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.FlexGridSizer">
             <summary>
             A flex grid sizer is a sizer which lays out its children in a two-dimensional table
             with all table fields in one row having the same height and all fields in one column having the same width,
             but all rows or all columns are not necessarily the same height or width as in the wx.GridSizer.
            
             Since wxWidgets 2.5.0, wxFlexGridSizer can also size items equally in one direction but unequally ("flexibly")
             in the other. If the sizer is only flexible in one direction (this can be changed using SetFlexibleDirection()),
             it needs to be decided how the sizer should grow in the other ("non-flexible") direction in order to fill the
             available space. The SetNonFlexibleGrowMode method serves this purpose.
             </summary>
        </member>
        <member name="T:WX.Doc.TagCHandler">
            <summary>
            Tag handler for tag &lt;c&gt;, the inlined code tag in .NET documentation.
            </summary>
        </member>
        <member name="T:WX.Doc.BaseDoc">
            <summary>
            Base class of source documentations. Contains common elements of the documentation.
            Subclasses typically add a member field describing the documented code element plus
            some extra elements of the documentation.
            </summary>
        </member>
        <member name="P:WX.Doc.BaseDoc.Summary">
            <summary>
            The content of the summary tag.
            </summary>
        </member>
        <member name="P:WX.Doc.BaseDoc.SeeAlso">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="P:WX.Doc.BaseDoc.See">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="T:WX.Doc.TypeDoc">
            <summary>
            Instances are document entries for types.
            </summary>
        </member>
        <member name="M:WX.Doc.TypeDoc.#ctor(WX.NetMacros.TypeDescriptor,System.String)">
            <summary>
            Creates a document entry.
            </summary>
            <param name="t">The documented type.</param>
            <param name="summary">The summary description of the type (XML).</param>
        </member>
        <member name="P:WX.Doc.TypeDoc.Type">
            <summary>
            The documented type.
            </summary>
        </member>
        <member name="T:WX.Doc.PropertyDoc">
            <summary>
            Instances are document entries for properties of classes.
            </summary>
        </member>
        <member name="M:WX.Doc.PropertyDoc.#ctor(WX.NetMacros.MemberDescriptor,System.String)">
            <summary>
            Creates a document entry.
            </summary>
            <param name="pi">The documented property.</param>
            <param name="summary">The summary description of the property (XML).</param>
        </member>
        <member name="P:WX.Doc.PropertyDoc.Property">
            <summary>
            The documented type.
            </summary>
        </member>
        <member name="T:WX.Doc.MethodDoc">
            <summary>
            Class to represent document entries on methods.
            </summary>
        </member>
        <member name="M:WX.Doc.MethodDoc.#ctor(WX.NetMacros.MemberDescriptor,System.String)">
            <summary>
            Creates a dosumentation entry describing a method.
            </summary>
            <param name="methodName">Designator of the documented method.</param>
            <param name="summary">Summary text.</param>
        </member>
        <member name="M:WX.Doc.MethodDoc.AddParameter(System.String,System.String)">
            <summary>
            Adds documentation for a parameter.
            </summary>
            <param name="parametername">The name of the parameter.</param>
            <param name="parameterdoc">The documentation of the parameter (content of PARAM tag).</param>
        </member>
        <member name="M:WX.Doc.MethodDoc.GetDocOnParameter(System.String)">
            <summary>
            Returns documentation of the method parameter of the provided name.
            </summary>
            <param name="name">Name of the parameter whose documentation has been requested.</param>
            <returns>A non-null string that may be empty.</returns>
        </member>
        <member name="P:WX.Doc.MethodDoc.MethodName">
            <summary>
            The name of the documented method. This is an instance of MethodDescriptor if the documentation
            shall be used for a particular implementation of the method (depending on the types of the parameters).
            </summary>
        </member>
        <member name="P:WX.Doc.MethodDoc.DocOnParameters">
            <summary>
            Returns a collection of pairs of parameter names and documentation on the parameter.
            </summary>
        </member>
        <member name="P:WX.Doc.MethodDoc.Returns">
            <summary>
            The content of the RETURNS tag.
            </summary>
        </member>
        <member name="T:WX.Doc.AssemblyDocBase">
            <summary>
            Includes the documentation entries for one assembly.
            </summary>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.NormalizeStringContent(System.String)">
            <summary>
            Normalization of string content. Remove line breaks and multible blanks.
            Remove * if preceeded by line break and blanks.S
            </summary>
            <param name="original"></param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.Load(System.Uri)">
            <summary>
            Starts loading of a documentation in a new thread.
            </summary>
            <param name="filename">The filename of the documentation.</param>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.LoadIntern(System.Uri)">
            <summary>
            Loads a documentation.
            </summary>
            <param name="filename">The filename of the documentation.</param>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.GetTypeDoc(WX.NetMacros.TypeDescriptor)">
            <summary>
            Returns the documentation of the designated type if one has been loaded.
            </summary>
            <param name="t">The type whose documentation is requested</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.GetMethodDoc(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns the documentation of the designated method if one has been loaded.
            </summary>
            <param name="m">Designates the method whose documentation is requested. If this is a MethodDescriptor,
            then this will also search for a documentation to MethodDescriptor.Generalized.</param>
            <returns></returns>
            <seealso cref="T:WX.NetMacros.MethodDescriptor"/>
        </member>
        <member name="M:WX.Doc.AssemblyDocBase.GetPropertyDoc(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns the documentation of the designated property if one has been loaded.
            </summary>
            <param name="p">Designates the property whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="P:WX.Doc.AssemblyDocBase.Error">
            <summary>
            This is an error message if something went wrong on loading.
            This is <c>null</c> if everything is OK.
            </summary>
        </member>
        <member name="P:WX.Doc.AssemblyDocBase.Filename">
            <summary>
            The source of the documentation.
            </summary>
        </member>
        <member name="P:WX.Doc.AssemblyDocBase.AssemblyName">
            <summary>
            The name of the assembly as read from the documentation file. This may be <c>null</c> on read errors.
            </summary>
        </member>
        <member name="T:WX.Doc.DocBases">
            <summary>
            A collection of assembly doc bases.
            </summary>
        </member>
        <member name="M:WX.Doc.DocBases.Load(System.Reflection.Assembly)">
            <summary>
            This method will try to load documentation on the provided assembly if this documentation has not
            already been loaded. This method will load file only once. 
            </summary>
            <param name="ass">The assembly, whose documentation shall be loaded.</param>
            <returns>True if the documentation has been loaded. False, if the documentation has already
            been a part of the document base.</returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetTypeDoc(System.Type)">
            <summary>
            Returns the first non-empty documentation of the designated type in one of the loaded assembly documentations.
            </summary>
            <param name="t">The type whose documentation is requested</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetTypeDoc(WX.NetMacros.TypeDescriptor)">
            <summary>
            Returns the first non-empty documentation of the designated type in one of the loaded assembly documentations.
            </summary>
            <param name="t">The type whose documentation is requested</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetMethodDoc(System.Reflection.ConstructorInfo)">
            <summary>
            Returns the first non-empty documentation of the designated constructor in one of the loaded assembly documentations.
            </summary>
            <param name="m">Designates the method whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetMethodDoc(System.Reflection.MethodInfo)">
            <summary>
            Returns the first non-empty documentation of the designated method in one of the loaded assembly documentations.
            </summary>
            <param name="m">Designates the method whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetMethodDoc(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns the first non-empty documentation of the designated method in one of the loaded assembly documentations.
            </summary>
            <param name="m">Designates the method whose documentation is requested. If this is a MethodDescriptor,
            then this will also search for a documentation to MethodDescriptor.Generalized.</param>
            <returns></returns>
            <seealso cref="T:WX.NetMacros.MethodDescriptor"/>
        </member>
        <member name="M:WX.Doc.DocBases.GetPropertyDoc(System.Reflection.PropertyInfo)">
            <summary>
            Returns the first non-empty documentation of the designated type in one of the loaded assembly documentations.
            </summary>
            <param name="p">Designates the property whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.GetPropertyDoc(WX.NetMacros.MemberDescriptor)">
            <summary>
            Returns the first non-empty documentation of the designated type in one of the loaded assembly documentations.
            </summary>
            <param name="p">Designates the property whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.DoxygenHyperlink(WX.NetMacros.RuntimeEnv,WX.NetMacros.TypeDescriptor)">
            <summary>
            Returns a doxygen style hyperlink to the documentation of the specified type.
            </summary>
            <param name="t">The type whose documentation shall be linked.</param>
            <param name="env">Runtime environment </param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.ConvertToHTML(WX.Doc.DocBases.HtmlMode,WX.NetMacros.RuntimeEnv,WX.NetMacros.MemberDescriptor)">
            <summary>
            Converts the member descriptor into a HTML string.
            </summary>
            <param name="mode">Specifies how to convert.</param>
            <param name="env">This will produce hyperlinks for those members that can be found in this environment</param>
            <param name="md">The descriptor that shall be converted.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.ConvertToHTML(WX.Doc.DocBases.HtmlMode,WX.NetMacros.RuntimeEnv,WX.NetMacros.TypeDescriptor)">
            <summary>
            Converts the type descriptor into a HTML string.
            </summary>
            <param name="mode">Specifies how to convert.</param>
            <param name="env">This will produce hyperlinks for those members that can be found in this environment</param>
            <param name="td">The descriptor that shall be converted.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Doc.DocBases.ConvertToHTML(WX.Doc.DocBases.HtmlMode,WX.NetMacros.RuntimeEnv,System.String,WX.NetMacros.TypeDescriptor)">
            <summary>
            A small converter from .NET help sources into HTML.
            </summary>
            <param name="netHelpSource">The original .NET help text</param>
            <param name="env">Thie will be used to identify code elements like class names.</param>
            <param name="mode">desired mode of the output.</param>
            <param name="context">The context for the interpretation of contained symbols. This is optional and may be <c>null</c>.</param>
            <returns>The argument as HTML</returns>
        </member>
        <member name="M:WX.Doc.DocBases.WriteHTML(System.IO.TextWriter,WX.Doc.DocBases.HtmlMode,WX.NetMacros.RuntimeEnv,System.Object)">
            <summary>
            Writes an HTML text on a code element that has been documented here,
            </summary>
            <param name="destination">The generated HTML will be appended to this stream.</param>
            <param name="env">Runtime environment. This will be used to dereference method descriptors.
            This is optional.</param>
            <param name="codeElementDescriptor">A TypeDescriptor, MemberDescriptor, System.Type,
            System.Reflection.MethodInfo, System.Reflection.ConstructorInfo, orSystem.Reflection.PropertyInfo
            designating either a type, a method, a proeperty, or a cosntructor whose documentation
            shall be printed.</param>
            <param name="mode">Specifies the desired mode.</param>
        </member>
        <member name="T:WX.Doc.DocBases.HtmlMode">
            <summary>
            Modes for WriteHTML().
            </summary>
        </member>
        <member name="F:WX.Doc.DocBases.HtmlMode.NoHyperlinks">
            <summary>
            Do not produce hyperlinks.
            </summary>
        </member>
        <member name="F:WX.Doc.DocBases.HtmlMode.HelpProtocolWithDoxygenReferences">
            <summary>
            Produce hyperlinks to classes in doxygen convention.
            Identify words referring to code fragments by
            Example: <c>wx.Window</c> or <c>Window()</c> both will be
            identified as references to the class wx.Window. This will
            produce a hyperlink of the form 
            <c>&lt;a href="help:classwx_1_1Window.html"&gt;wx.Window&lt;/a&gt;</c>
            </summary>
        </member>
        <member name="P:WX.Brush.Transparent">
            <summary>
            A fully transparent brush. This is read only. Do not dispose.
            </summary>
        </member>
        <member name="P:WX.Brush.Null">
            <summary>
            The <c>Null</c> brush. This is read only. Do not dispose.
            </summary>
        </member>
        <member name="P:WX.Brush.TheBrushList">
            <summary>This is synonym to wx.BrushList.TheBrushList.</summary>
        </member>
        <member name="P:WX.Brush.Colour">
            <summary>
            The colour of the brush. This will return exactly the instance that will be used
            in the brush.
            </summary>
        </member>
        <member name="T:WX.Brush.Styles">
            <summary>Styles for brushes.</summary>
        </member>
        <member name="T:WX.TipWindow">
             <summary>
             Shows simple text in a popup tip window on creation. This is used by wx.SimpleHelpProvider to show popup help.
             The window automatically destroys itself when the user clicks on it or it loses the focus.
            
             You may also use this class to emulate the tooltips when you need finer control over them than what the standard
             tooltips provide.
             </summary>
        </member>
        <member name="T:WX.StaticBox">
            <summary>A static box is a rectangle drawn around other panel items to denote a logical grouping of items.
            
             Please note that a static box should not be used as the parent for the controls it contains,
             instead they should be siblings of each other. Although using a static box as a parent might
             work in some versions of wxWidgets, it results in a crash under, for example, <c>wxGTK</c>. 
            
             Also, please note that because of this, the order in which you create new controls is important.
             Create your <c>wx.StaticBox</c> control before any siblings that are to appear inside the <c>wx.StaticBox</c> in order
             to preserve the correct Z-Order of controls.</summary>
        </member>
        <member name="T:WX.SpinCtrl">
            <summary>wx.SpinCtrl combines wx.TextCtrl and wx.SpinButton in one control.</summary>
        </member>
        <member name="P:WX.PrintData.PrintMode">
            <summary>Setting this property requires compatibility mode with  wxWidgets 2.4.</summary>
        </member>
        <member name="T:WX.GridCtrl.GridSelectionMode">
            <summary>This will defines what cell will be selected when pointing with the mouse at the grid.
            You may alternatively use the wx.WindowStyles wx.WindowStyles.GRID_SELECT_CELLS,
            wx.WindowStyles.GridSelectRows, or wx.WindowStyles.GRID_SELECT_COLUMNS.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellNumberEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellFloatEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Editors.GridCellBoolEditor">
            <summary>This editor displays a check box producing string values according to wx.GridCtrl.Editors.GridCellBoolEditor.UseStringValues.</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellBoolEditor.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellBoolEditor.UseStringValues(System.String,System.String)">
            <summary>Defines the string representation of the <c>true</c> and the <c>false</c> value that can be used by editors of this class.
            Default values are "1" for <c>true</c> and the empty string "" for <c>false</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellBoolEditor.UseStringValues(WX.wxString,WX.wxString)">
            <summary>Defines the string representation of the <c>true</c> and the <c>false</c> value that can be used by editors of this class.
            Default values are "1" for <c>true</c> and the empty string "" for <c>false</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue(System.String)">
            <summary>Returns <c>true</c> iff <c>value</c> is the string representation of <c>true</c> according to UseStringValues().</summary>
        </member>
        <member name="M:WX.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue(WX.wxString)">
            <summary>Returns <c>true</c> iff <c>value</c> is the string representation of <c>true</c> 
            according to UseStringValues().
            </summary>
        </member>
        <member name="T:WX.GridCtrl.GridEditorCreatedEvent">
            <summary>
            This event will be raised by the grid control if a new editor has been created.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridEditorCreatedEvent.#ctor(System.Int32,System.Int32,WX.Object,System.Int32,System.Int32,WX.Control)">
            <summary>
            Creates a new event of the properties as provided by the arguments.
            </summary>
            <param name="id">The ID of the dialog that raised the event.</param>
            <param name="type">The type of the event. Typically wx.Event.wxEVT_GRID_EDITOR_CREATED</param>
            <param name="obj">The object that raised the event.</param>
            <param name="row">The row of  the cell with new grid cell editor.</param>
            <param name="col">The column of the cell with new grid cell editor.</param>
            <param name="ctrl">The control that has been created by the editor to read new values.</param>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.GridTableRequest">
            <summary>IDs for messages sent from grid table to view.
             Refer to class GridTableMessage.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.GridTableRequest.RequestViewGetValues">
            <summary>
            Asks the grid for an update since new values have to be displayed.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.GridTableRequest.RequestViewSendValues">
            <summary>
            Asks the table to set its values in the table model.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.GridTableMessage">
            <summary>Class to inform displaying Grid controls of any changes in the displayed GridTableBase.</summary>
                 * <remarks>
                 * This method implements an often vital directions of passing information in data binding that
                 * is often missing: The data model can use this method to inform displaying controls of changes.
                 * Refer to Grid.ProcessTableMessage().
                 * 
                 * Instances of this class combine a request for an action or message ID with two integer
                 * arguments. The best waay to exemplify the effect of such messages is to list their use
                 * in the standard  wxWidgets table model as given by class <c>wxStringTable</c>.
                 * The following items list modifying methods of this table model followed by the
                 * table message that is used to communicate the effect to the grid.
                 * 
                 * \code wxGridStringTable::InsertRows( size_t pos, size_t numRows ) \endcode generates
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NotifyRowsInserted,
                                            pos,
                                            numRows );
                 \endcode
                 *
                 * \code wxGridStringTable::AppendRows( size_t numRows ) \endcode
                 * posts
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NOTIFY_ROWS_APPENDED,
                                            numRows );
                 \endcode
                 * 
                 * Finally, \code wxGridStringTable::DeleteRows( size_t pos, size_t numRows ) \endcode
                 * demands processing of
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NotifyRowsDeleted,
                                            pos,
                                            numRows );
                 \endcode
                 * Get message IDs from enumeration <c>wx.GridTableRequest</c>.
                 * </remarks>
        </member>
        <member name="T:WX.GridCtrl.Grid">
             <summary>wxGrid and its related classes are used for displaying and editing tabular data.
             </summary>
             <remarks>
             \image html grid.png
             Getting started: a simple example
             For simple applications you need only refer to the wxGrid class in your code. This example shows how you might
             create a grid in a frame or dialog constructor and illustrates some of the formatting functions. 
            
             Create a wx.Grid object
             <code>
             grid = new wx.Grid( this,
                                 -1,
                                 wxPoint( 0, 0 ),
                                 wxSize( 400, 300 ) );
             
              // Then we call CreateGrid to set the dimensions of the grid
              // (100 rows and 10 columns in this example)
             grid.CreateGrid( 100, 10 );
              
              // We can set the sizes of individual rows and columns
              // in pixels
             grid.SetRowSize( 0, 60 );
             grid.SetColSize( 0, 120 );
             
              // And set grid cell contents as strings
             grid.SetCellValue( 0, 0, "wxGrid is good" );
             
              // We can specify that some cells are read-only
             grid.SetCellValue( 0, 3, "This is read-only" );
             grid.SetReadOnly( 0, 3 );
             
              // Colours can be specified for grid cell contents
             grid.SetCellValue(3, 3, "green on grey");
             grid.SetCellTextColour(3, 3, wx.Colour.wxGREEN);
             grid.SetCellBackgroundColour(3, 3, wx.Colour.wxLIGHT_GREY);
             
              // We can specify the some cells will store numeric 
              // values rather than strings. Here we set grid column 5 
              // to hold floating point values displayed with width of 6 
              // and precision of 2
             grid.SetColFormatFloat(5, 6, 2);
             grid.SetCellValue(0, 6, "3.1415");
             </code>
             </remarks>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor">
            <summary>
            Creates a new grid control.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32,System.Drawing.Point)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
            <param name="style">The style of the window.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
            <param name="style">The style of the window.</param>
            <param name="name">A name for the window. This name may be useful to search for particular subwindows.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,WX.WindowStyles,WX.wxString)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="style">The style of the window.</param>
            <param name="name">A name for the window. This name may be useful to search for particular subwindows.</param>
            <param name="id">ID of the new control. This ID may be useful for searching subwindows with <c>wx.Window.FindWindow()</c>.
            Use -1 as an undefined value.</param>
            <param name="height">height of teh new control.</param>
            <param name="posX">X-position of the new control.</param>
            <param name="posY">Y-position of the new control.</param>
            <param name="width">Width of the new control.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.OnGridEditorShown(System.Object,WX.Event)">
            <summary>Work around a  wxWidgets error (reported on 2.8.9).
            Ensure that grid editors will loose focus before they will be closed.</summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.OnClose(System.Object,WX.Event)">
            <summary>Work around a  wxWidgets bug: Close an eventually shown editor before closing the grid.
            Closing a grid with an open editor causes Access Violations in  wxWidgets.</summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Drawing.Point)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
            <param name="style">The style of the window.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>
            Creates a new grid control.
            </summary>
            <param name="parent">The parent window. This may be <c>null</c>.</param>
            <param name="pos">The position of the window. Use <c>wxDefaultProsition</c> (-1,-1) as an undefined value.</param>
            <param name="size">The size of the window. Use <c>wxDefaultSize</c> (-1, -1) as an undefined value.</param>
            <param name="style">The style of the window.</param>
            <param name="name">A name for the window. This name may be useful to search for particular subwindows.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.CreateGrid(System.Int32,System.Int32)">
             <summary>
             Creates a grid with the specified initial number of rows and columns.
             Call this directly after the grid constructor. When you use this function wx.Grid will create and manage a 
             simple table of string values for you. All of the grid data will be stored in memory.
            
             For applications with more complex data types or relationships, or for dealing with very large datasets,
             you should derive your own grid table class and pass a table object to the grid with wx.Grid.SetTable.
             </summary>
             <param name="numRows">Number of rows</param>
             <param name="numCols">Number of columns</param>
             <seealso cref="M:WX.GridCtrl.Grid.SetTable(WX.GridCtrl.GridTableBase)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.CreateGrid(System.Int32,System.Int32,WX.GridCtrl.GridSelectionMode)">
             <summary>
             Creates a grid with the specified initial number of rows and columns.
             Call this directly after the grid constructor. When you use this function wx.Grid will create and manage a 
             simple table of string values for you. All of the grid data will be stored in memory.
            
             For applications with more complex data types or relationships, or for dealing with very large datasets,
             you should derive your own grid table class and pass a table object to the grid with wx.Grid.SetTable.
             </summary>
             <param name="numRows">Number of rows</param>
             <param name="selmode">Choice between cell or row selection.</param>
             <param name="numCols">Number of columns</param>
             <seealso cref="M:WX.GridCtrl.Grid.SetTable(WX.GridCtrl.GridTableBase)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetTable(WX.GridCtrl.GridTableBase)">
            <summary>
            Set the provided <c>table</c> as table model in cell selection mode without taking ownership.
            </summary>
            <param name="table">The table model</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetTable(WX.GridCtrl.GridTableBase,System.Boolean)">
            <summary>
            Set the provided <c>table</c> as table model in cell selection mode without taking ownership.
            </summary>
            <param name="table">The table model</param>
            <param name="takeOwnerShip">If true then this grid will take ownership of the grid model</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetTable(WX.GridCtrl.GridTableBase,System.Boolean,WX.GridCtrl.GridSelectionMode)">
            <summary>
            Set the provided <c>table</c> as table model in cell selection mode without taking ownership.
            </summary>
            <param name="table">The table model</param>
            <param name="takeOwnerShip">If true then this grid will take ownership of the grid model</param>
            <param name="select">Defines the selection mode.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.ProcessTableMessage(WX.GridCtrl.GridTableMessage)">
            <summary>Method for instances of GridTableBase to inform displaying grid controls of any changes.
             This method implements an often vital directions of passing information in data binding that
             is often missing: The data model can use this method to inform displaying controls of changes.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertRows">
             <summary>
             Use this to insert new rows at position 0 when using the standard grid model.
             </summary>
             <seealso cref="M:wx.GridCtrl.Grid.SetTable()"/>
             <seealso cref="M:wx.GridCtrl.Grid.CreateGrid()"/>
             <remarks>
             Inserts one or more new rows into a grid with the first new row at the specified position and returns
             true if successful. The updateLabels argument is not used at present.
            
             The sequence of actions begins with the grid object requesting the underlying grid table to insert
             new rows. If this is successful the table notifies the grid and the grid updates the display.
             For a default grid (one where you have called <c>CreateGrid</c>) this process is automatic.
             If you are using a custom grid table (specified with <c>SetTable</c>) then you must override
             wx.GridCtrl.GridTableBase.InsertRows() in your derived table class.
             </remarks>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertRows(System.Int32)">
             <summary>
             Use this to insert new rows at position 0 when using the standard grid model.
             </summary>
             <param name="pos">The row position where to insert. Use -1 to refer to the last row and -2
             to denote the row before the last one etc.</param>
             <seealso cref="M:wx.GridCtrl.Grid.SetTable()"/>
             <seealso cref="M:wx.GridCtrl.Grid.CreateGrid()"/>
             <remarks>
             Inserts one or more new rows into a grid with the first new row at the specified position and returns
             true if successful. The updateLabels argument is not used at present.
            
             The sequence of actions begins with the grid object requesting the underlying grid table to insert
             new rows. If this is successful the table notifies the grid and the grid updates the display.
             For a default grid (one where you have called <c>CreateGrid</c>) this process is automatic.
             If you are using a custom grid table (specified with <c>SetTable</c>) then you must override
             wx.GridCtrl.GridTableBase.InsertRows() in your derived table class.
             </remarks>
             <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertRows(System.Int32,System.Int32)">
             <summary>
             Use this to insert new rows at position 0 when using the standard grid model.
             </summary>
             <param name="pos">The row position where to insert. Use -1 to insert after the last row and -2
             to insert before the last row and so on.</param>
             <param name="numRows">The number of rows to insert.</param>
             <seealso cref="M:wx.GridCtrl.Grid.SetTable()"/>
             <seealso cref="M:wx.GridCtrl.Grid.CreateGrid()"/>
             <remarks>
             Inserts one or more new rows into a grid with the first new row at the specified position and returns
             true if successful. The updateLabels argument is not used at present.
            
             The sequence of actions begins with the grid object requesting the underlying grid table to insert
             new rows. If this is successful the table notifies the grid and the grid updates the display.
             For a default grid (one where you have called <c>CreateGrid</c>) this process is automatic.
             If you are using a custom grid table (specified with <c>SetTable</c>) then you must override
             wx.GridCtrl.GridTableBase.InsertRows() in your derived table class.
             </remarks>
             <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertRows(System.Int32,System.Int32,System.Boolean)">
             <summary>
             Use this to insert new rows at position 0 when using the standard grid model.
             </summary>
             <param name="pos">The row position where to insert. Use -1 to insert after the last row and -2
             to insert before the last row and so on.</param>
             <param name="numRows">The number of rows to insert.</param>
             <param name="updateLabels">Not used at present.</param>
             <seealso cref="M:wx.GridCtrl.Grid.SetTable()"/>
             <seealso cref="M:wx.GridCtrl.Grid.CreateGrid()"/>
             <remarks>
             Inserts one or more new rows into a grid with the first new row at the specified position and returns
             true if successful. The updateLabels argument is not used at present.
            
             The sequence of actions begins with the grid object requesting the underlying grid table to insert
             new rows. If this is successful the table notifies the grid and the grid updates the display.
             For a default grid (one where you have called <c>CreateGrid</c>) this process is automatic.
             If you are using a custom grid table (specified with <c>SetTable</c>) then you must override
             wx.GridCtrl.GridTableBase.InsertRows() in your derived table class.
             </remarks>
             <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendRows">
            <summary>
            Appends one or more new rows to the bottom of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendRows.
            See <c>InsertRows</c> for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertRows"/>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendRows(System.Int32)">
            <summary>
            Appends one or more new rows to the bottom of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendRows.
            See <c>InsertRows</c> for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertRows"/>
            <param name="numRows">Number of Rows to insert.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendRows(System.Int32,System.Boolean)">
            <summary>
            Appends one or more new rows to the bottom of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendRows.
            See <c>InsertRows</c> for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertRows"/>
            <returns></returns>
            <param name="numRows">Number of Rows to insert.</param>
            <param name="updateLabels">Not used at present.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.DeleteAllRows">
            <summary>Deletes all rows.</summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.DeleteRows">
            <summary>Deletes row 0.</summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.DeleteRows(System.Int32)">
            <summary>Deletes row at pos <c>pos</c>.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertCols">
            <summary>
            Inserts one or more new columns into a grid with the first new column at the specified position and returns
            true if successful.
            </summary>
            <remarks>
            The sequence of actions begins with the grid object requesting the underlying grid table to insert new columns.
            If this is successful the table notifies the grid and the grid updates the display. For a default grid
            (one where you have called wxGrid::CreateGrid) this process is automatic. If you are using a custom grid table
            (specified with wxGrid::SetTable) then you must override wx.GridCtrl.GridTableBase.InsertCols in your derived
            table class.
            </remarks>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertCols(System.Int32)">
            <summary>
            Inserts one or more new columns into a grid with the first new column at the specified position and returns
            true if successful.
            </summary>
            <remarks>
            The sequence of actions begins with the grid object requesting the underlying grid table to insert new columns.
            If this is successful the table notifies the grid and the grid updates the display. For a default grid
            (one where you have called wxGrid::CreateGrid) this process is automatic. If you are using a custom grid table
            (specified with wxGrid::SetTable) then you must override wx.GridCtrl.GridTableBase.InsertCols in your derived
            table class.
            </remarks>
            <param name="pos">Columns index where to insert the new columns.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertCols(System.Int32,System.Int32)">
            <summary>
            Inserts one or more new columns into a grid with the first new column at the specified position and returns
            true if successful.
            </summary>
            <remarks>
            The sequence of actions begins with the grid object requesting the underlying grid table to insert new columns.
            If this is successful the table notifies the grid and the grid updates the display. For a default grid
            (one where you have called wxGrid::CreateGrid) this process is automatic. If you are using a custom grid table
            (specified with wxGrid::SetTable) then you must override wx.GridCtrl.GridTableBase.InsertCols in your derived
            table class.
            </remarks>
            <param name="pos">Columns index where to insert the new columns.</param>
            <param name="numCols">Number of columns to add.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.InsertCols(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Inserts one or more new columns into a grid with the first new column at the specified position and returns
            true if successful.
            </summary>
            <remarks>
            The sequence of actions begins with the grid object requesting the underlying grid table to insert new columns.
            If this is successful the table notifies the grid and the grid updates the display. For a default grid
            (one where you have called wxGrid::CreateGrid) this process is automatic. If you are using a custom grid table
            (specified with wxGrid::SetTable) then you must override wx.GridCtrl.GridTableBase.InsertCols in your derived
            table class.
            </remarks>
            <param name="pos">Columns index where to insert the new columns.</param>
            <param name="numCols">Number of columns to add.</param>
            <param name="updateLabels">Currently not used.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendCols">
            <summary>
            Appends one or more new columns to the right of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendCols.
            See wx.GridCtrl.Grid.InsertCols for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertCols"/>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendCols(System.Int32)">
            <summary>
            Appends one or more new columns to the right of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendCols.
            See wx.GridCtrl.Grid.InsertCols for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertCols"/>
            <param name="numCols">Number of columns to add.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.AppendCols(System.Int32,System.Boolean)">
            <summary>
            Appends one or more new columns to the right of the grid and returns true if successful.
            </summary>
            <remarks>
            If you are using a derived grid table class you will need to override wx.GridCtrl.GridTableBase.AppendCols.
            See wx.GridCtrl.Grid.InsertCols for further information.
            </remarks>
            <see cref="M:WX.GridCtrl.Grid.InsertCols"/>
            <param name="numCols">Number of columns to add.</param>
            <param name="updateLabels">Currently not used.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetRowLabelAlignment">
            <summary>
            Returns the alignment information on row labels as an array of flags.
            The first element of the array will be on the horizontal alignment,
            the second on the vertical alignment.
            </summary>
            <returns>An array containing 2 alignment flags</returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetColLabelAlignment">
            <summary>
            Returns the alignment information on column labels as an array of flags.
            The first element of the array will be on the horizontal alignment,
            the second on the vertical alignment.
            </summary>
            <returns>An array containing 2 alignment flags</returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetRowLabelAlignment(WX.Alignment,WX.Alignment)">
            <summary>
            Sets the horizontal and vertical alignment of column label text.
            </summary>
            <param name="horiz">Horizontal alignment should be one of Left, Centre or Right.</param>
            <param name="vert">Vertical alignment should be one of Top, Centre or Bottom.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetColLabelAlignment(WX.Alignment,WX.Alignment)">
            <summary>
            Sets the horizontal and vertical alignment of column label text.
            </summary>
            <param name="horiz">Horizontal alignment should be one of Left, Centre or Right.</param>
            <param name="vert">Vertical alignment should be one of Top, Centre or Bottom.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetAttr(System.Int32,System.Int32,WX.GridCtrl.GridCellAttr)">
            <summary>
            Assigns display attributes to a cell.
            </summary>
            <param name="row">Row of the cell whose appearance will be defined by this method</param>
            <param name="col">Row of the row whose appearance will be defined by this method</param>
            <param name="attr">Defines the appearance of the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetRowAttr(System.Int32,WX.GridCtrl.GridCellAttr)">
            <summary>
            Assigns display attributes to a cell. 
            </summary>
            <param name="row">Row of the cell whose appearance will be defined by this method</param>
            <param name="col">Row of the row whose appearance will be defined by this method</param>
            <param name="attr">Defines the appearance of the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetColAttr(System.Int32,WX.GridCtrl.GridCellAttr)">
            <summary>
            Assigns display attributes to a cell.
            </summary>
            <param name="row">Row of the cell whose appearance will be defined by this method</param>
            <param name="col">Row of the row whose appearance will be defined by this method</param>
            <param name="attr">Defines the appearance of the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.AutoSizeColumns">
             <summary>
             Automatically sizes all columns to fit their contents. The computed column widths will also be
             saved as minimal column widths.
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.AutoSizeColumns(System.Boolean)">
             <summary>
             Automatically sizes all columns to fit their contents. 
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
             <param name="setAsMin">If this argument is true the calculated widths will also be set as the minimal widths for the columns.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.AutoSizeRows">
             <summary>
             Automatically sizes all rows to fit their contents. If setAsMin is true the calculated heights will also be set as the minimal heights for the rows.
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.AutoSizeRows(System.Boolean)">
             <summary>
             Automatically sizes the row to fit its contents. If setAsMin is true the calculated height will also be set as the minimal height for the row.
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
             <param name="setAsMin"></param>
        </member>
        <member name="M:WX.GridCtrl.Grid.AutoSize">
             <summary>
             Automatically sets the height and width of all rows and columns to fit their contents.
            
             Note::
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellAlignment(System.Int32,System.Int32,WX.Alignment,WX.Alignment)">
            <summary>
            Defines the alignment of text in the cell.
            </summary>
            <param name="row">The row index of the cell.</param>
            <param name="col">The columns index of the cell.</param>
            <param name="horiz">Specifies the horizontal alignment</param>
            <param name="vert">Specified the vertical alignment</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellOverflow(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Defines whether the content of a cell might span over neighbours if it is too large
            for the size of ots own cell.
            </summary>
            <param name="row">The row index of the cell.</param>
            <param name="col">The columns index of the cell.</param>
            <param name="allow">Parameter that defines whether to allow or forbid cell overflow.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellSize(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Call this to make a cell span over other cells in the neighbourhood.
            Use this method before setting attributes like alignment or colour of the 
            cells. Do not use wx.Grid.SetColAttr() if this defines a column range larger
            1 and avoid wx.GridSetRowAttr() if this defines a row range larger 1.
            </summary>
            <param name="row">The row index of the cell to be expanded.</param>
            <param name="col">The columns index of the cell to be expanded.</param>
            <param name="num_rows">The number of rows that will be hidden behind this cell.</param>
            <param name="num_cols">The number of cells that will be hidden behind this cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellRenderer(System.Int32,System.Int32,WX.GridCtrl.Renderers.GridCellRenderer)">
            <summary>This will set the editor for a particular cell.
            Alternatively, you may set the editor to be used by a wx.GridCellAttr or
            you may assign a value to property wx.Grid.DefaultEditor.</summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellEditor(System.Int32,System.Int32,WX.GridCtrl.Editors.GridCellEditor)">
            <summary>
            Sets the editor of a particular cell. If the editor os <c>null</c>, this will call
            <c>SetReadOnly</c>.
            </summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <param name="editor">The editor that will be opened to edit the designated cell.</param>
            <see cref="M:WX.GridCtrl.Grid.SetReadOnly(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetCellEditor(System.Int32,System.Int32)">
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetCellValue(System.Int32,System.Int32)">
            <summary>Returns the string value of the designated cell.</summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <seealso cref="M:WX.GridCtrl.Grid.SetCellValue(System.Int32,System.Int32,System.String)"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellData(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellValue(System.Int32,System.Int32,System.String)">
            <summary>Sets the string value of the designated cell.</summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellValue(System.Int32,System.Int32)"/>
            <seealso cref="M:WX.GridCtrl.Grid.SetCellData(System.Int32,System.Int32,System.Object)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetCellData(System.Int32,System.Int32)">
            <summary>
            This will deserialize the result of GetCellValue() according to
            the data type that has been associated with this cell.
            </summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <returns></returns>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellValue(System.Int32,System.Int32)"/>
            <seealso cref="M:WX.GridCtrl.Grid.SetCellData(System.Int32,System.Int32,System.Object)"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellDataType(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellData(System.Int32,System.Int32,System.Object)">
            <summary>The provided object will be serialized and written into
            the designated grid cell. This method will use the serialization as provided
            by the data type that has been associated with this cell.</summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <param name="o">The object that will be serialized and written into the grid cell.</param>
            <seealso cref="M:WX.GridCtrl.Grid.SetCellValue(System.Int32,System.Int32,System.String)"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellData(System.Int32,System.Int32)"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetCellDataType(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.IsReadOnly(System.Int32,System.Int32)">
            <summary> Returns true iff the designated cell is in readonly mode.
            </summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetReadOnly(System.Int32,System.Int32)">
            <summary>
            Use this to turn a particular cell into readonly mode (editors
            will not open).
            </summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <seealso cref="M:WX.GridCtrl.Grid.IsReadOnly(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetReadOnly(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Use this to turn a particular cell into readonly mode (editors
            will not open) or to make them editable again.
            </summary>
            <param name="row">Row index of the cell.</param>
            <param name="col">Columns index of the cell.</param>
            <param name="isReadOnly">Turns with <c>true</c> the cell into readonly mode. Makes with <c>false</c> the cell editable again.</param>
            <seealso cref="M:WX.GridCtrl.Grid.IsReadOnly(System.Int32,System.Int32)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.RegisterDataType(System.String,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor)">
            <summary>
            Defines a new data type. A data type has a name and is associated with a renderer (to render the data)
            and an editor (to put in or remove data). Data types may be used by GridTableBase to assign renderers and
            editors to cells. You can register data types to create a base of reuseable renderers and editors.
            The system predefines "string", "bool", "long", "double", and "choice". These predefined types may be referred
            by instances of GridTableBase. They cannot be used by SetValue() and GetRegisteredDataType().
            </summary>
            <param name="typeName">The name of the data type.</param>
            <param name="renderer">The renderer that shall be used to render cells of this type.</param>
            <param name="editor">The editor that shall be used to change values of this type.</param>
            <seealso cref="T:WX.GridCtrl.GridTableBase"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.RegisterDataType(System.String,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor,WX.GridCtrl.Grid.DataType.ToStringConverter,WX.GridCtrl.Grid.DataType.FromStringConverter)">
            <summary>
            Defines a new data type. A data type has a name and is associated with a renderer (to render the data)
            and an editor (to put in or remove data). Data types may be used by GridTableBase to assign renderers and
            editors to cells. You can register data types to create a base of reuseable renderers and editors.
            The system predefines "string", "bool", "long", "double", and "choice". These predefined types may be referred
            by instances of GridTableBase. They cannot be used by SetValue() and GetRegisteredDataType().
            </summary>
            <param name="typeName">The name of the data type.</param>
            <param name="renderer">The renderer that shall be used to render cells of this type.</param>
            <param name="editor">The editor that shall be used to change values of this type.</param>
            <param name="fromString">Create an object of this type from a string.</param>
            <param name="toString">Create a string serializing an object of this type.</param>
            <seealso cref="T:WX.GridCtrl.GridTableBase"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.RegisterDataType(System.Type,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor,WX.GridCtrl.Grid.DataType.ToStringConverter,WX.GridCtrl.Grid.DataType.FromStringConverter)">
            <summary>
            Defines a new data type. A data type has a name and is associated with a renderer (to render the data)
            and an editor (to put in or remove data). Data types may be used by GridTableBase to assign renderers and
            editors to cells. You can register data types to create a base of reuseable renderers and editors.
            The system predefines "string", "bool", "long", "double", and "choice". These predefined types may be referred
            by instances of GridTableBase. They cannot be used by SetValue() and GetRegisteredDataType().
            </summary>
            <param name="type">The name of the data type will be derived from the namespace and the name of this type.</param>
            <param name="renderer">The renderer that shall be used to render cells of this type.</param>
            <param name="editor">The editor that shall be used to change values of this type.</param>
            <param name="fromString">Create an object of this type from a string.</param>
            <param name="toString">Create a string serializing an object of this type.</param>
            <seealso cref="T:WX.GridCtrl.GridTableBase"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.RegisterDataType(WX.GridCtrl.Grid.DataType)">
            <summary>
            Defines a new data type. A data type has a name and is associated with a renderer (to render the data)
            and an editor (to put in or remove data). Data types may be used by GridTableBase to assign renderers and
            editors to cells. You can register data types to create a base of reuseable renderers and editors.
            The system predefines "string", "bool", "long", "double", and "choice". These predefined types may be referred
            by instances of GridTableBase. They cannot be used by SetValue() and GetRegisteredDataType().
            </summary>
            <param name="dataType">The properties of the new data type.</param>
            <seealso cref="T:WX.GridCtrl.GridTableBase"/>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)">
            <summary>
            Returns the data type registered under the provided name if such a type has been defined using <c>RegisterDataType</c>.
            Otherwise, the result will be <c>null</c>. This method will not return the properties of the predefined types
            "string", "bool", "long", "double", and "choice", but, "System.Boolean", "System.Int32", "System.Double",
            "System.DateTime", "System.Drawing.Point", and "System.String" will be returned.
            </summary>
            <param name="typeName">Name of the desired registered type.</param>
            <returns>The properties of the registered type or <c>null</c> if nothing has been registered under the provided type name.</returns>
            <see cref="M:WX.GridCtrl.Grid.RegisterDataType(System.String,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.Type)">
            <summary>
            Returns the data type registered under the provided name if such a type has been defined using <c>RegisterDataType</c>.
            Otherwise, the result will be <c>null</c>. If this method cannot find a registered type for the argument, it will
            look for a registration of the base type.
            This method will not return the properties of the predefined types
            "string", "bool", "long", "double", and "choice", but, "System.Boolean", "System.Int32", "System.Double",
            "System.DateTime", "System.Drawing.Point", and "System.String" will be returned.
            </summary>
            <param name="typeName">Name of the desired registered type.</param>
            <returns>The properties of the registered type or <c>null</c> if nothing has been registered under the provided type name.</returns>
            <see cref="M:WX.GridCtrl.Grid.RegisterDataType(System.String,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellDataType(System.Int32,System.Int32,WX.GridCtrl.Grid.DataType)">
            <summary>
            This will set the data type that is associated with the designated cell.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="t">The data type that will be set. If this is <c>null</c>, this method will do nothing. </param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellDataType(System.Int32,System.Int32,System.String)">
            <summary>
            This will set the data type that is associated with the designated cell.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="typename">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetCellDataType(System.Int32,System.Int32,System.Type)">
            <summary>
            This will set the data type that is associated with the designated cell.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="type">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetRowDataType(System.Int32,WX.GridCtrl.Grid.DataType)">
            <summary>
            This will set the data type that is associated with the designated row.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="t">The data type that will be set.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetRowDataType(System.Int32,System.String)">
            <summary>
            This will set the data type that is associated with the designated row.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="typename">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetRowDataType(System.Int32,System.Type)">
            <summary>
            This will set the data type that is associated with the designated cell.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="row">Index of the row containing the cell whose data type will be set.</param>
            <param name="type">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetColDataType(System.Int32,WX.GridCtrl.Grid.DataType)">
            <summary>
            This will set the data type that is associated with the designated column.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="t">The data type that will be set.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetColDataType(System.Int32,System.Int32,System.String)">
            <summary>
            This will set the data type that is associated with the designated column.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="typename">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.SetColDataType(System.Int32,System.Type)">
            <summary>
            This will set the data type that is associated with the designated column.
            editor and renderer will be set according to the data type. Additionally, this
            </summary>
            <param name="col">Index of the column containing the cell whose data type will be set.</param>
            <param name="type">The data type that will be set. <c>GetregisteredDataType()</c>
            will be used to read the data type to set.</param>
            <seealso cref="M:WX.GridCtrl.Grid.GetRegisteredDataType(System.String)"/>
        </member>
        <member name="M:WX.GridCtrl.Grid.GetCellDataType(System.Int32,System.Int32)">
            <summary>
            Returns the data type that have been associated with the designated cell.
            If the cell has not been associated with a type, this method will search for a
            type associated with the column. If the search for a column type also fails, this
            will search for a type associated with the row. If nothing can be found,
            the result will be <c>null</c>.
            </summary>
            <param name="row">The row index.</param>
            <param name="col">The column index.</param>
            <returns></returns>
            <seealso cref="M:WX.GridCtrl.Grid.SetCellDataType(System.Int32,System.Int32,WX.GridCtrl.Grid.DataType)"/>
            <seealso cref="M:WX.GridCtrl.Grid.SetRowDataType(System.Int32,WX.GridCtrl.Grid.DataType)"/>
            <seealso cref="M:WX.GridCtrl.Grid.SetColDataType(System.Int32,WX.GridCtrl.Grid.DataType)"/>
        </member>
        <member name="P:WX.GridCtrl.Grid.SelectionMode">
            <summary>
            Gets the selection mode, whether cells, or rows, or columns will be selected.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.NumberRows">
            <summary>
            Gets the number of rows.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.NumberCols">
            <summary>
            Gets the number of columns.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.Table">
            <summary>Get or set the table.
            This will use <c>SetTable(value)</c> for setting the table model, i.e. this operations does not
            take ownership of the table model and the selection mode will be cell selection.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultRowLabelSize">
            <summary>
            The default size of row labels. Assign this value to <c>RowLabelSize</c> in order to
            re-enable row labels.
            </summary>
            <seealso cref="P:WX.GridCtrl.Grid.RowLabelSize"/>
        </member>
        <member name="P:WX.GridCtrl.Grid.RowLabelSize">
            <summary>
            Defines the size of the row labels. Set this to 0 to disable row labels.
            </summary>
            <seealso cref="P:WX.GridCtrl.Grid.DefaultRowLabelSize"/>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultColLabelSize">
            <summary>
            The default size of column labels. Assign this value to <c>ColLabelSize</c> in order to
            re-enable column labels.
            </summary>
            <seealso cref="P:WX.GridCtrl.Grid.ColLabelSize"/>
        </member>
        <member name="P:WX.GridCtrl.Grid.ColLabelSize">
            <summary>
            Defines the size of the column labels. Set this to 0 to disable column labels.
            </summary>
            <seealso cref="P:WX.GridCtrl.Grid.DefaultColLabelSize"/>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultRowSize">
            <summary>Gets or sets the default row size.
            Setting a value to this property always disables resizing (also
            the default in wxWidgets). Use SetDefaultRowSize() to enable resizing
            of rows.</summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultColSize">
            <summary>Gets or sets the default column size.
            Setting a value to this property always disables resizing (also
            the default in wxWidgets). Use SetDefaultColSize() to enable resizing
            of rows.</summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultRenderer">
            <summary>Get or set the default renderer.
            Please note, that the grid will gain ownership of the wrapped C++ instance of the editor.
            This will raise an exception, if you try to set an editor that is already in use.</summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.DefaultEditor">
            <summary>Get or set the default editor.
            Please note, that the grid will gain ownership of the wrapped C++ instance of the editor.
            This will raise an exception, if you try to set an editor that is already in use.</summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.Rows">
            <summary>
            Use this to read the number of rows.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.Cols">
            <summary>
            Use this to read the number of columns.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.CursorRow">
            <summary>
            The row comprising the cell that can be edited.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.CursorColumn">
            <summary>
            The column index of the cell that can be edited.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.ViewHeight">
            <summary>
            Returned number of whole rows visible.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Grid.ViewWidth">
            <summary>
            Returned number of whole cols visible.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Grid.DataType">
            <summary>
            Defines a data type in a grid. A data type is a named structure comprising a renderer
            to display a grid cell and an editor to edit the value of the grid cell.
            Data types may be used by instances of GridTableBase to define the renderer and the editor
            of a cell. Use data types as logical presentation guidelines whereas grid cell attributes
            can be considered as most concrete presentation guidelines.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Grid.DataType.#ctor(System.String,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor,WX.GridCtrl.Grid.DataType.ToStringConverter,WX.GridCtrl.Grid.DataType.FromStringConverter)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">The name of the data type.</param>
            <param name="renderer">The renderer that shall be used to render cells of this type.</param>
            <param name="editor">The editor that shall be used to change values of this type.</param>
            <param name="fromString">Create an object of this type from a string.</param>
            <param name="toString">Create a string serializing an object of this type.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.DataType.#ctor(System.Type,WX.GridCtrl.Renderers.GridCellRenderer,WX.GridCtrl.Editors.GridCellEditor,WX.GridCtrl.Grid.DataType.ToStringConverter,WX.GridCtrl.Grid.DataType.FromStringConverter)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">The name of the data type will be derived from this type.</param>
            <param name="renderer">The renderer that shall be used to render cells of this type.</param>
            <param name="editor">The editor that shall be used to change values of this type.</param>
            <param name="fromString">Create an object of this type from a string.</param>
            <param name="toString">Create a string serializing an object of this type.</param>
        </member>
        <member name="M:WX.GridCtrl.Grid.DataType.Serialize(System.Object)">
            <summary>
            Serializes the provided object using the serializer - the <c>toString</c>-conversion of
            this data type.
            </summary>
            <param name="o">The original object.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Grid.DataType.Deserialize(System.String)">
            <summary>
            Deserialization of an object that has been serialized with Serialize().
            </summary>
            <param name="serializedObject">the serialized object</param>
            <returns>the deserialized object.</returns>
        </member>
        <member name="T:WX.GridCtrl.Grid.DataType.ToStringConverter">
            <summary>
            The grid stores values typically in form of strings.
            Use this to define a convertion from the original object into 
            a string object that will be used to store the value in table
            models that only can deal with strings.
            </summary>
            <param name="value">the original value.</param>
            <returns>A string serialization of the argument.</returns>
        </member>
        <member name="T:WX.GridCtrl.Grid.DataType.FromStringConverter">
            <summary>
            The grid stores values typically in form of strings.
            Use this to define a convertion from the srialized string into the
            original.
            </summary>
            <param name="strValue">A string serialization.</param>
            <returns>The serialized object.</returns>
        </member>
        <member name="T:WX.GridCtrl.GridCellCoordsArray">
            <summary>This is an array of GridCellCoords.</summary>
        </member>
        <member name="M:WX.GridCtrl.GridCellCoordsArray.SafeNew(System.IntPtr)">
            <summary>Creates a new ArrayInt. However, if <c>ptr</c> is <c>IntPtr.Zer</c>, then the result is <c>null</c>.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.GridCellAttr">
            <summary>
            Represents a set of attributes to display grid cells including (optional) special renderers and editors.
            Please note, that this class wrapps native code using reference counting. 
            </summary>
            <seealso cref="M:WX.GridCtrl.GridCellAttr.IncRef"/>
            <seealso cref="M:WX.GridCtrl.GridCellAttr.DecRef"/>
        </member>
        <member name="M:WX.GridCtrl.GridCellAttr.#ctor(WX.Colour,WX.Colour,WX.Font,WX.Alignment,WX.Alignment)">
            <summary>
            In contrast to the correlated C++ CTor, this one accepts partially defined arguments.
            </summary>
            <param name="colText">Text colour to use in the cell or <c>null</c>.</param>
            <param name="colBack">Background colour to use in the cell or <c>null</c>.</param>
            <param name="font">font to use in the cell or <c>null</c>.</param>
            <param name="hAlign">Horizontal alignment of the text in the cell.</param>
            <param name="vAlign">Vertical alignment of the text in the cell.</param>
        </member>
        <member name="M:WX.GridCtrl.GridCellAttr.IncRef">
            <summary>
            This class is ref counted: it is created with ref count of 1, so calling DecRef() once will delete it.
            Calling IncRef() allows to lock it until the matching DecRef() is called
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridCellAttr.DecRef">
            <summary>
            Unlock an instance that has been locked with IncRef()
            </summary>
            <seealso cref="M:WX.GridCtrl.GridCellAttr.IncRef"/>
        </member>
        <member name="M:WX.GridCtrl.GridCellAttr.GetAlignment">
            <summary>
            Returns information on the defined alignment of text. First entry of the result
            will specify the horizintal alignment. The second entry will provide the vertical
            alignment.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellNumberRenderer">
            <summary>Renderer for numbers.
            Overriding is supported.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellNumberRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellFloatRenderer">
            <summary>Renderer for numbers.
            Overriding is supported.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellFloatRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellFloatRenderer.#ctor">
            <summary>A renderer of default precision and width.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellFloatRenderer.#ctor(System.Int32)">
            <summary>A renderer of default precision.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellFloatRenderer.#ctor(System.Int32,System.Int32)">
            <summary>Creates a renderer using the provided precision and width to display floating point numbers.</summary>
        </member>
        <member name="T:WX.GridCtrl.Renderers.GridCellBoolRenderer">
            <summary>This renderer shows a check box interpreting string according to wx.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue.
            Overriding s not supported.</summary>
        </member>
        <member name="M:WX.GridCtrl.Renderers.GridCellBoolRenderer.GetWxClassInfo">
            <summary>
            Returns the class info associated with this type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.GridTableBase">
            <summary>Abstract data model for grids.
            Refer also to class GridTableMessage.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.GetNumberRows">
            <summary>
            Defines the number of rows in the table.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.GetNumberCols">
            <summary>
            Defines the number of columns in the table.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.IsEmptyCell(System.Int32,System.Int32)">
            <summary>
            Defines whether a cell can contain dat or not.
            </summary>
            <param name="row">The row of the requested cell</param>
            <param name="col">The column index of the requested cell</param>
            <returns>True iff the cell is empty.</returns>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.GetTypeName(System.Int32,System.Int32)">
            <summary>
            Defines the data type associated with this cell.
            </summary>
            <param name="row">The row of the described cell.</param>
            <param name="col">The column of the described cell.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.CanGetValueAs(System.Int32,System.Int32,System.String)">
            <summary>
            Defines whether the value of the designated cell can be read as a daty of this type.
            </summary>
            <param name="row">The row of the described cell.</param>
            <param name="col">The column of the described cell.</param>
            <param name="typeName">The name of the data type.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.CanSetValueAs(System.Int32,System.Int32,System.String)">
            <summary>
            Defines whether a value of the type can be assigned to the cell.
            </summary>
            <param name="row">The row of the described cell.</param>
            <param name="col">The column of the described cell.</param>
            <param name="typeName">The name of the data type.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.CanHaveAttributes">
            <summary>
            Does this table allow attributes? Default implementation creates a wxGridCellAttrProvider if necessary.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.GetAttr(System.Int32,System.Int32,WX.GridCtrl.GridCellAttr.AttrKind)">
            <summary>
            Returns grid cell attributes relevant to the cell as specified by the provided row
            and column index.
            
            Note:
            Grid cell attributs contain elements like fonts that often have a reduced address space
            (like handles in Windows). So, it is usually not a good idea to create grid cell attributes
            when they are needed. A better practice stores all required grid cell attributes in member
            variables. However, grid cell attributes wrapp C++ instances using reference counting. 
            So, you will have to increment the reference counter by GridCellAttr.IncRef().
            </summary>
            <param name="row">The row index.</param>
            <param name="col">The column index.</param>
            <param name="kind">A value indicating the intended use of the attributes.</param>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.SetRowAttr(WX.GridCtrl.GridCellAttr,System.Int32)">
            <summary>The standard implementation simply calls the  wxWidgets implementation and passes memory ownership to  wxWidgets.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridTableBase.SetColAttr(WX.GridCtrl.GridCellAttr,System.Int32)">
            <summary>The standard implementation simply calls the  wxWidgets implementation and passes memory ownership to  wxWidgets.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.GridStringTable">
            <summary>Simplest type of data table for a grid for small tables of strings that are stored in memory:
            This is the default model of grids.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.GridCellAttrProvider.GetAttr(System.Int32,System.Int32,WX.GridCtrl.GridCellAttr.AttrKind)">
            <summary>
            Returns grid cell attributes relevant to the cell as specified by the provided row
            and column index.
            
            Note:
            Grid cell attributs contain elements like fonts that often have a reduced address space
            (like handles in Windows). So, it is usually not a good idea to create grid cell attributes
            when they are needed. A better practice stores all required grid cell attributes in member
            variables. However, grid cell attributes wrapp C++ instances using reference counting. 
            So, you will have to increment the reference counter by GridCellAttr.IncRef().
            </summary>
            <param name="row">The row index.</param>
            <param name="col">The column index.</param>
            <param name="kind">A value indicating the intended use of the attributes.</param>
        </member>
        <member name="T:WX.MappingMode">
            <summary>
            The mapping mode of the device context defines the unit of measurement used to convert logical units to device units.
            Note that in X, text drawing isn't handled consistently with the mapping mode; a font is always specified in point size.
            However, setting the user scale (see wxDC::SetUserScale) scales the text appropriately.
            In Windows, scalable TrueType fonts are always used; in X, results depend on availability of fonts, but
            usually a reasonable match is found.
            
            The coordinate origin is always at the top left of the screen/printer.
            
            Drawing to a Windows printer device context uses the current mapping mode, but mapping mode is currently
            ignored for PostScript output.
            </summary>
        </member>
        <member name="F:WX.MappingMode.TEXT">
            <summary>
            Each logical unit is 1 pixel.
            </summary>
        </member>
        <member name="F:WX.MappingMode.LOMETRIC">
            <summary>
            Each logical unit is 1/10 of a mm.  
            </summary>
        </member>
        <member name="F:WX.MappingMode.TWIPS">
            <summary>
            Each logical unit is 1/20 of a point, or 1/1440 of an inch.  
            </summary>
        </member>
        <member name="F:WX.MappingMode.POINTS">
            <summary>
            Each logical unit is a point, or 1/72 of an inch.  
            </summary>
        </member>
        <member name="F:WX.MappingMode.METRIC">
            <summary>
            Each logical unit is 1 mm.  
            </summary>
        </member>
        <member name="T:WX.DC">
            <summary>A device context for painting.
            Please note, that you have to dispose this context as soon as you
            stop drawing explicitely. In C++  wxWidgets this is done explicitely
            when creating objects of this class in a local scope. The object will
            be deleted when leaving this scope implicitely. However, .NET implements
            an implicit destruction of objects using a garbage collector. So, 
            you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
            to delete a DC immediately after using it.</summary>
        </member>
        <member name="M:WX.DC.DrawBitmap(WX.Bitmap,System.Int32,System.Int32,System.Boolean)">
             <summary>
             Draw a bitmap on the device context at the specified point.
             If <c>transparent</c> is true and the bitmap has a transparency mask, the bitmap will be drawn transparently.
            
             When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
             of the bitmap (all bits set to 1), and the current text background colour to draw the background
             (all bits set to 0). See also <c>SetTextForeground</c>, <c>SetTextBackground</c> and wx.MemoryDC.
             </summary>
             <param name="bmp">the bitmap that will be drawn</param>
             <param name="x">the x position of the upper left corner of the bitmap in the DC.</param>
             <param name="y">the y position of the upper left corner of the bitmap in the DC.</param>
             <param name="transparent">If <c>true</c> draw with transparent background (if available)</param>
        </member>
        <member name="M:WX.DC.DrawBitmap(WX.Bitmap,System.Int32,System.Int32)">
             <summary>
             Draw a bitmap on the device context at the specified point.
             This will draw even transparent regions in the bitmap opaque.
            
             When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
             of the bitmap (all bits set to 1), and the current text background colour to draw the background
             (all bits set to 0). See also <c>SetTextForeground</c>, <c>SetTextBackground</c> and wx.MemoryDC.
             </summary>
             <param name="bmp">the bitmap that will be drawn</param>
             <param name="x">the x position of the upper left corner of the bitmap in the DC.</param>
             <param name="y">the y position of the upper left corner of the bitmap in the DC.</param>
        </member>
        <member name="M:WX.DC.DrawBitmap(WX.Bitmap,System.Drawing.Point,System.Boolean)">
             <summary>
             Draw a bitmap on the device context at the specified point.
             If <c>transparent</c> is true and the bitmap has a transparency mask, the bitmap will be drawn transparently.
            
             When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
             of the bitmap (all bits set to 1), and the current text background colour to draw the background
             (all bits set to 0). See also <c>SetTextForeground</c>, <c>SetTextBackground</c> and wx.MemoryDC.
             </summary>
             <param name="bmp">the bitmap that will be drawn</param>
             <param name="pt">the position of the upper left corner of the bitmap in the DC.</param>
             <param name="transparent">If <c>true</c> draw with transparent background (if available)</param>
        </member>
        <member name="M:WX.DC.DrawBitmap(WX.Bitmap,System.Drawing.Point)">
             <summary>
             Draw a bitmap on the device context at the specified point.
             This will draw even transparent regions in the bitmap opaque.
            
             When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground
             of the bitmap (all bits set to 1), and the current text background colour to draw the background
             (all bits set to 0). See also <c>SetTextForeground</c>, <c>SetTextBackground</c> and wx.MemoryDC.
             </summary>
             <param name="bmp">the bitmap that will be drawn</param>
             <param name="pt">the position of the upper left corner of the bitmap in the DC.</param>
        </member>
        <member name="M:WX.DC.DrawText(System.String,System.Int32,System.Int32)">
             <summary>
             Draws a text string at the specified point, using the current text font, and the current text foreground
             and background colours.
            
             The coordinates refer to the top-left corner of the rectangle bounding the string. See <c>GetTextExtent</c>
             for how to get the dimensions of a text string, which can be used to position the text more precisely.
            
             NB: under wxGTK the current logical function is used by this function but it is ignored by wxMSW.
             Thus, you should avoid using logical functions with this function in portable programs.
             </summary>
             <param name="text">Text that will be drawn.</param>
             <param name="x">X position of the upper left corner of the text in the DC.</param>
             <param name="y">Y position of the upper left corner of teh text in the DC.</param>
        </member>
        <member name="M:WX.DC.DrawText(System.String,System.Drawing.Point)">
             <summary>
             Draws a text string at the specified point, using the current text font, and the current text foreground
             and background colours.
            
             The coordinates refer to the top-left corner of the rectangle bounding the string. See <c>GetTextExtent</c>
             for how to get the dimensions of a text string, which can be used to position the text more precisely.
            
             NB: under wxGTK the current logical function is used by this function but it is ignored by wxMSW.
             Thus, you should avoid using logical functions with this function in portable programs.
             </summary>
             <param name="text">Text that will be drawn.</param>
             <param name="pos">Position of the upper left corner of the text in the DC.</param>
        </member>
        <member name="M:WX.DC.GetTextExtent(System.String,System.Int32@,System.Int32@)">
            <summary>
            Gets the dimensions of the string using the currently selected font.
            </summary>
            <param name="str"><c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height respectively.</param>
            <param name="w"></param>
            <param name="h"></param>
        </member>
        <member name="M:WX.DC.GetTextExtent(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,WX.Font)">
            <summary>
            Gets the dimensions of the string using the currently selected font.
            </summary>
            <param name="str"><c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height respectively.</param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="descent"><c>descent</c> is the dimension from the baseline of the font to the bottom of the descender.</param>
            <param name="externalLeading"><c>externalLeading</c> is any extra vertical space added to the font by the font designer (usually is zero).</param>
            <param name="theFont">The parameter font specifies an alternative to the currently selected font:
            but note that this does not yet work under Windows, so you need to set a font for the device context first.</param>
        </member>
        <member name="M:WX.DC.GetTextExtent(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Gets the dimensions of the string using the currently selected font.
            </summary>
            <param name="str"><c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height respectively.</param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="descent"><c>descent</c> is the dimension from the baseline of the font to the bottom of the descender.</param>
            <param name="externalLeading"><c>externalLeading</c> is any extra vertical space added to the font by the font designer (usually is zero).</param>
        </member>
        <member name="M:WX.DC.GetTextExtent(System.String)">
            <summary>Returns width and height of string <c>str</c> using the font of the <c>this</c>.</summary>
            <param name="str"><c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height respectively.</param>
            <param name="font">The parameter font specifies an alternative to the currently selected font:
            but note that this does not yet work under Windows, so you need to set a font for the device context first.</param>
        </member>
        <member name="M:WX.DC.GetTextExtent(System.String,WX.Font)">
            <summary>Returns width and height of string <c>str</c> using the designated font. </summary>
            <param name="str"><c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height respectively.</param>
            <param name="font">The parameter font specifies an alternative to the currently selected font:
            but note that this does not yet work under Windows, so you need to set a font for the device context first.</param>
        </member>
        <member name="M:WX.DC.DestroyClippingRegion">
            <summary>
            Destroys the current clipping region so that none of the DC is clipped. See also <c>SetClippingRegion</c>.
            </summary>
        </member>
        <member name="M:WX.DC.SetClippingRegion(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Sets the clipping region for this device context to the intersection of the given region described by 
             the parameters of this method and the previously set clipping region. You should call
             <c>DestroyClippingRegion</c> if you want to set the clipping region exactly to the region specified.
            
             The clipping region is an area to which drawing is restricted.
             Possible uses for the clipping region are for clipping text or for speeding up window redraws when
             only a known area of the screen is damaged.
             </summary>
        </member>
        <member name="M:WX.DC.SetClippingRegion(System.Drawing.Point,System.Drawing.Size)">
             <summary>
             Sets the clipping region for this device context to the intersection of the given region described by 
             the parameters of this method and the previously set clipping region. You should call
             <c>DestroyClippingRegion</c> if you want to set the clipping region exactly to the region specified.
            
             The clipping region is an area to which drawing is restricted.
             Possible uses for the clipping region are for clipping text or for speeding up window redraws when
             only a known area of the screen is damaged.
             </summary>
        </member>
        <member name="M:WX.DC.SetClippingRegion(System.Drawing.Rectangle)">
             <summary>
             Sets the clipping region for this device context to the intersection of the given region described by 
             the parameters of this method and the previously set clipping region. You should call
             <c>DestroyClippingRegion</c> if you want to set the clipping region exactly to the region specified.
            
             The clipping region is an area to which drawing is restricted.
             Possible uses for the clipping region are for clipping text or for speeding up window redraws when
             only a known area of the screen is damaged.
             </summary>
        </member>
        <member name="M:WX.DC.SetClippingRegion(WX.Region)">
             <summary>
             Sets the clipping region for this device context to the intersection of the given region described by 
             the parameters of this method and the previously set clipping region. You should call
             <c>DestroyClippingRegion</c> if you want to set the clipping region exactly to the region specified.
            
             The clipping region is an area to which drawing is restricted.
             Possible uses for the clipping region are for clipping text or for speeding up window redraws when
             only a known area of the screen is damaged.
             </summary>
        </member>
        <member name="M:WX.DC.DrawLines(System.Drawing.Point[],System.Int32,System.Int32)">
            <summary>
            Draws lines using an array of points of size n, or list of pointers to points, adding the optional offset coordinate. The current pen is used for drawing the lines. The programmer is responsible for deleting the list of points.
            </summary>
            <param name="points">Array of points</param>
            <param name="xoffset">Optional offset in X direction</param>
            <param name="yoffset">Optional offset in Y direction</param>
        </member>
        <member name="M:WX.DC.DrawLines(System.Drawing.Point[])">
            <summary>
            Draws lines using an array of points of size n, or list of pointers to points, adding the optional offset coordinate. The current pen is used for drawing the lines. The programmer is responsible for deleting the list of points.
            </summary>
            <param name="points">Array of points</param>
        </member>
        <member name="M:WX.DC.DrawLines(System.Drawing.Point[],System.Int32)">
            <summary>
            Draws lines using an array of points of size n, or list of pointers to points, adding the optional offset coordinate. The current pen is used for drawing the lines. The programmer is responsible for deleting the list of points.
            </summary>
            <param name="points">Array of points</param>
            <param name="xoffset">Optional offset in X direction</param>
        </member>
        <member name="M:WX.DC.GetSizeMM(System.Int32@,System.Int32@)">
            <summary>
            Returns the horizontal and vertical resolution in millimetres.
            </summary>
            <param name="width">Variable that will be loaded with the width.</param>
            <param name="height">Variable that will be loaded with the height.</param>
        </member>
        <member name="M:WX.DC.SetUserScale(System.Double,System.Double)">
            <summary>
            Sets the user scaling factor, useful for applications which require 'zooming'.
            </summary>
            <param name="x">Scaling factor in X direction</param>
            <param name="y">scaling factor in Y direction.</param>
        </member>
        <member name="P:WX.DC.BackgroundMode">
            <summary>Returns or defines the background mode of the window.</summary>
        </member>
        <member name="P:WX.DC.Brush">
            <summary>
            The brush that will be used to draw squares and elipses. This gets exactly
            the instance that will be used for drawing. Thus, beware of side effects.
            </summary>
        </member>
        <member name="P:WX.DC.Background">
            <summary>
            The brush that will be used to draw the background. This gets exactly
            the instance that will be used for drawing. Thus, beware of side effects.
            </summary>
        </member>
        <member name="P:WX.DC.Font">
            <summary>
            Get or set the current font. 
            Notice that even although each device context object has some default font after creation,
            this method would return a wx.Font.NullFont initially and only after assigning to wx.DC.Font a valid font is returned.
            
            Assignments of <c>null</c> to this property will be ignored.
            </summary>
        </member>
        <member name="P:WX.DC.CharHeight">
            <summary>
            Gets the character height of the currently set font.
            </summary>
        </member>
        <member name="P:WX.DC.CharWidth">
            <summary>
            Gets the average character width of the currently set font.
            </summary>
        </member>
        <member name="P:WX.DC.LogicalFunction">
            <summary>
            Sets the current logical function for the device context. 
            This determines how a source pixel (from a pen or brush colour, or source device context if
            using wx.DC.Blit) combines with a destination pixel in the current device context.
            </summary>
            <remarks>
            The possible values and their meaning in terms of source and destination pixel values are as follows:
            \verbatim
            And                 src AND dst
            AndInvert          (NOT src) AND dst
            Reverse         src AND (NOT dst)
            Clear               0
            Copy                src
            Equiv               (NOT src) XOR dst
            Invert              NOT dst
            NAnd                (NOT src) OR (NOT dst)
            NOr                 (NOT src) AND (NOT dst)
            NoOp               dst
            Or                  src OR dst
            OrInvert           (NOT src) OR dst
            OrReverse          src OR (NOT dst)
            Set                 1
            SrcInvert          NOT src
            Xor                 src XOR dst
            \endverbatim
            The default is Copy, which simply draws with the current colour. The others combine the current colour and the background using a logical operation. Invert is commonly used for drawing rubber bands or moving outlines, since drawing twice reverts to the original colour.
            </remarks>
        </member>
        <member name="P:WX.DC.ClippingBox">
            <summary>
            Gets the rectangle surrounding the current clipping region.
            </summary>
        </member>
        <member name="P:WX.DC.Size">
            <summary>
            This gets the horizontal and vertical resolution in device units.
            It can be used to scale graphics to fit the page. For example, if maxX and maxY represent the maximum
            horizontal and vertical 'pixel' values used in your application, the following code will scale the
            graphic to fit on the printer page:
            <code>
              Size s=dc.Size;
              double scaleX=(double)maxX/s.Width;
              double scaleY=(double)maxY/s.Height;
              dc.SetUserScale(min(scaleX,scaleY),min(scaleX,scaleY));
            </code>
            </summary>
        </member>
        <member name="P:WX.DC.SizeMM">
            <summary>
            Returns the horizontal and vertical resolution in millimetres.
            </summary>
        </member>
        <member name="P:WX.DC.MapMode">
            <summary>
            The mapping mode of the device context defines the unit of measurement used to convert logical units to device units.
            Note that in X, text drawing isn't handled consistently with the mapping mode; a font is always specified in point size.
            However, setting the user scale (see wxDC::SetUserScale) scales the text appropriately.
            In Windows, scalable TrueType fonts are always used; in X, results depend on availability of fonts, but
            usually a reasonable match is found.
            
            The coordinate origin is always at the top left of the screen/printer.
            
            Drawing to a Windows printer device context uses the current mapping mode, but mapping mode is currently
            ignored for PostScript output.
            </summary>
        </member>
        <member name="T:WX.WindowDC">
             <summary>
             A wxWindowDC must be constructed if an application wishes to paint on the whole area of a window 
             (client and decorations). This should normally be constructed as a temporary stack object; don't
             store a wx.WindowDC object.
            
             To draw on a window from inside OnPaint, construct a wx.PaintDC object.
            
             To draw on the client area of a window from outside OnPaint, construct a wx.ClientDC object.
            
             To draw on the whole window including decorations, construct a wxWindowDC object (Windows only).
             </summary>
        </member>
        <member name="T:WX.ClientDC">
            <summary>A device context for the region of a window.
             
             A ClientDC must be constructed if an application wishes to paint on the client
             area of a window from outside an OnPaint event. This should normally be constructed
             as a temporary stack object; don't store a ClientDC object.
            
             To draw on a window from within OnPaint, construct a PaintDC object.
            
             To draw on the whole window including decorations, construct a WindowDC object (Windows only).
             
             Please note, that you have to dispose this context as soon as you
             stop drawing explicitely. In C++  wxWidgets this is done explicitely
             when creating objects of this class in a local scope. The object will
             be deleted when leaving this scope implicitely. However, .NET implements
             an implicit destruction of objects using a garbage collector. So, 
             you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
             to delete a DC immediately after using it.</summary>
        </member>
        <member name="T:WX.PaintDC">
            <summary>A device context for painting.
            Please note, that you have to dispose this context as soon as you
            stop drawing explicitely. In C++  wxWidgets this is done explicitely
            when creating objects of this class in a local scope. The object will
            be deleted when leaving this scope implicitely. However, .NET implements
            an implicit destruction of objects using a garbage collector. So, 
            you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
            to delete a DC immediately after using it.</summary>
        </member>
        <member name="T:WX.ComponentModel.ValueChangedEvent">
            <summary>Event class to indicate a value change.
            This event is used by all data models to indicate a value change.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.ValueChangedEvent.NewValue">
            <summary>Gets the new value whose assignment raised this event.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.ValueChangedEvent.OldValue">
            <summary>Get the old value that has been replaced by <c>NewValue</c>.
            Both are equal iff either a data model ends initialization or a data model has been
            told to propagate its value.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.ValueChangedHandler">
            <summary>Handler of the ValueChangedEvent.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.PropertyChangedEvent">
            <summary>
            This event indicates the change of a property. this is a specialization of
            ValueChangedEvent. The new and the old value property of the instances of this class
            are the old and the new value of the changed property.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyChangedEvent.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Creates an instance.
            </summary>
            <param name="propertyName">The property that changed.</param>
            <param name="newValue">The new value of the property.</param>
            <param name="oldValue">The old value of the property.</param>
        </member>
        <member name="P:WX.ComponentModel.PropertyChangedEvent.PropertyName">
            <summary>
            The name of the property that changed.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.PropertyChangedHandler">
            <summary>
            Handles a PropertyChangedEvent. A property of the sender has been changed.
            </summary>
            <param name="sender">The object where a property changed.</param>
            <param name="evt">The event data</param>
        </member>
        <member name="T:WX.ComponentModel.RaisesChangeEventAttribute">
            <summary>Use this to annotate a property that raises an event on changing its value.
            Use this in combination with a PropertyModel to declare that the annotated property
            raises a particular event on changing its value (of type ValueChangedHandler). If you create a property model for
            such a property, this property model will install itself as a handler of this event.
            
            Usually, property models like field models cannot guarantee to propagate all changes
            of the managed property or field since they simply will not be informed of a changed value.
            However, the  WX.Net component model allows for programmers to specify some events that will
            be fired in case of value change.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.RaisesChangeEventAttribute.#ctor(System.String)">
            <summary>Indicates that the annotated property raises an event named <c>eventName</c> on changing its value.</summary>
        </member>
        <member name="P:WX.ComponentModel.RaisesChangeEventAttribute.EventName">
            <summary>Name of the event that will be raised on changing the annotated property.</summary>
        </member>
        <member name="T:WX.ComponentModel.FormItemAttribute">
            <summary>This attribute indicates that a property or field shall be visible in a GenericFormPanel.
            You may declare a neutral name and comment and, if you like, translations of these into specific cultures.
            These names and remarks will be displayed in the generic field if appropriate. Additionally, you may declare
            the property as  read  only. You may also assign a criterion for sorting the items in the form.</summary>
        </member>
        <member name="M:WX.ComponentModel.FormItemAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>Creates an attribute defining a string that shall be used as a title on presenting the field.</summary><remarks>
                     * \param name is the neutral name of the property to be shown in the form if this has not been translated into the current culture.
                     * \param comment is the neutral comment of the property to be displayed if a better translation is not available.
                     * \param triplesCanonicalNamePlusPropNamePlusComment is a sequence of triples canonical culture name (like "de-DE"), translated
                     *        name, translated comment.
                     * 
                     * Example: Use this to declare a property of a form
                     * \code
                     class FormData
                     {
                     [FormItemAttribute("Valuation", "A value to be used for valuation.",
                                        "de", "Bewertung", "Ein Wert zur Bewertung.")]
                     int _valuation;
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:WX.ComponentModel.FormItemAttribute.Name">
            <summary>Name of this property in the dialog.</summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemAttribute.Comment">
            <summary>This is a text that describes the meaning of this form field.
            Usually this will be displayed as tool tip.</summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemAttribute.IsReadOnly">
            <summary>True iff this shall be presented read-only.</summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemAttribute.Sort">
            <summary>If possible, items will be sorted according to this parameter.</summary>
        </member>
        <member name="T:WX.ComponentModel.FormItemGroupAttribute">
            <summary>Use this attribute to define groups of form items.
            Use this attributes to define item groups to be displayed together. Users may hide item groups and make them
            visible again as long as the group is not declared to be statically visible.
            Groups have a name/label and optionally a comment. You may provide additional translations of names and comments.
            
            The neutral (not translated) name of the group serves as a key. Usually, you will provide one instance of this
            attribute with full data and additional instances only comprising a neutral name to designate additional items
            that shall join the group. The form will choose one definition of the group to provide all the data.</summary>
        </member>
        <member name="M:WX.ComponentModel.FormItemGroupAttribute.#ctor(System.String)">
            <summary>Creates an instance without data.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.FormItemGroupAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>Creates an instance including data.
                     * </summary>
                     * <remarks>
                     * This attribute makes only sence if used together with FormItemAttribute.
                     * 
                     * Even if you provide <c>null</c> as comment, this instance will be considered as a definition of
                     * the item group providing full data.
                     * 
                     * \param name is the neutral name of the property to be shown in the form if this has not been translated into the current culture.
                     * \param comment is the neutral comment of the property to be displayed if a better translation is not available.
                     * \param triplesCanonicalNamePlusPropNamePlusComment is a sequence of triples canonical culture name (like "de-DE"), translated
                     *        name, translated comment.
                     * 
                     * Example: Use this to declare a property of a form
                     * \code
                     class FormData
                     {
                     [FormItemGroupAttribute("Valuation Factors", "Some factors for valuation.",
                                             "de", "Bewertungsangaben", "Angaben zur Bewertung.")]
                     [FormItemAttribute("Factor 1", "A value to be used for valuation.",
                                        "de", "Faktor 1", "Bewertungsfaktor 1.", Sort=1)]
                     int _factor1;
            
                     [FormItemGroupAttribute("Valuation Factors")]
                     [FormItemAttribute("Factor 2", "Another value to be used for valuation.",
                                        "de", "Faktor 1", "Bewertungsfaktor 2.", Sort=2)]
                     int _factor2;
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:WX.ComponentModel.FormItemGroupAttribute.Id">
            <summary>The untranslated name of this group that also serves as a key to designate the group.</summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemGroupAttribute.Name">
            <summary>The name of the item group and its translations.</summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemGroupAttribute.Comment">
            <summary>The comment on this item group and its translations.
            This may be <c>null</c> if this instance does not contain data.
            The form will choose one of the instances of this attribute on the same group where this property
            is not <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemGroupAttribute.IsStatic">
            <summary>True to require this attribute to be statically visible in the form (without scrolling).
            Please do not use this too often, because this might cause large and ugly looking forms.
            This is meant for fields like Name, affected year etc., that are something like a headline
            for the rest of the form.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.FormItemGroupAttribute.Sort">
            <summary>If possible, item groups will be sorted according to this parameter.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.ItemRowDesignatorAttribute">
            <summary>This attribute declares a particular form item to join the designated row in the form.
             This attribute makes only sence if used together with FormItemAttribute.
             
             Use instances of this attribtue to declare that two or more form items shall join the same 
             row. The sort criterion of the form items will be used to determine the order in which the items appear
             in the row. The sort criterion of this designator will be used to determine the place that
             the designated row occupies in the form.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.ItemRowDesignatorAttribute.#ctor(System.Int32)">
            <summary>The provided integer is the designator of the row as well as the criterion for sorting.</summary>
        </member>
        <member name="P:WX.ComponentModel.ItemRowDesignatorAttribute.Id">
            <summary>Returns the designator if the form row.</summary>
        </member>
        <member name="P:WX.ComponentModel.ItemRowDesignatorAttribute.Sort">
            <summary>Returns or sets the sorting index.</summary>
        </member>
        <member name="T:WX.ComponentModel.MessageClass">
            <summary>Classification of messages.</summary>
        </member>
        <member name="F:WX.ComponentModel.MessageClass.Error">
            <summary>The message is an error.
            The latest input cannot be accepted by the system and will be rejected.</summary>
        </member>
        <member name="F:WX.ComponentModel.MessageClass.Warning">
            <summary>This is a warning message.
            The latest input will be accepted but another the system recommends to
            think this over.</summary>
        </member>
        <member name="F:WX.ComponentModel.MessageClass.Info">
            <summary>This is a message simply for information.</summary>
        </member>
        <member name="T:WX.ComponentModel.IErrorHandler">
            <summary>Interface of means to display errors, warnings, or messages in response to value changes.
            Refer also to ErrorMessageException.</summary>
        </member>
        <member name="M:WX.ComponentModel.IErrorHandler.ShowMessage(WX.ComponentModel.MessageClass,System.String,System.Object[])">
            <summary>This tells the error handler to show the message of the provided properties.
            \param msgClass is the message class, typically wx.MessageClass.Error.
            \param msgFormat is a messge string that may contain wild cards like "{0}" or "{1}" that will be
                             replaced by the string form of the designated object. Typically, a translation
                             of <c>msgFormat</c> into the current culture or locale will be shown. However, this is left
                             to the error handler.
            \param objects is a sequence of objects that either occur in <c>msgFormat</c> or may serve as a structured information
                           on the error. The interpretation of such objects are left to the error handler. For instance, a
                           handler using the calendar control may use a <c>System.DateTime</c> object to determine the day
                           that is affected by the error.</summary>
        </member>
        <member name="T:WX.ComponentModel.ErrorMessageException">
            <summary>This exception represents an error message that shall be caught and passed to an error handler.
            All built in data models will catch this and pass it to an error handler.</summary>
        </member>
        <member name="M:WX.ComponentModel.ErrorMessageException.Show(WX.ComponentModel.IErrorHandler)">
            <summary>Display this on the provided error handler.
            If the argument is <c>null</c>, this will use a standard error handler (message dialog).</summary>
        </member>
        <member name="T:WX.ComponentModel.ErrorMessageDialog">
            <summary>Shows an error using the wx.MessageDialog.
            Opens at most one dialog non-modal.</summary>
        </member>
        <member name="M:WX.ComponentModel.ErrorMessageDialog.#ctor">
            <summary>Creates an instance without parent.</summary>
        </member>
        <member name="M:WX.ComponentModel.ErrorMessageDialog.#ctor(WX.Window)">
            <summary>Creates an instance with parent that will be used to determine the position of the dialog.</summary>
        </member>
        <member name="M:WX.ComponentModel.ErrorMessageDialog.ShowMessage(WX.ComponentModel.MessageClass,System.String,System.Object[])">
            <summary>Closing and destroying the old message box if one exists and open a new one.</summary>
        </member>
        <member name="P:WX.ComponentModel.ErrorMessageDialog.Parent">
            <summary>Returns the parent.
            The result may be <c>null</c>.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.IDataModel">
            <summary>Interface of nodes in the dependency network.</summary>
        </member>
        <member name="M:WX.ComponentModel.IDataModel.BeginSetValue(System.Object)">
            <summary>This will assign <c>newValue</c> and assign value propagation.
            Call EndSetValue() to end this transaction.
            
            Please note, that this will raise a <c>System.ApplicationException</c> if BeginSetValue() has been run without
            a following EndSetValue() and both values differ. This is to avoid non-terminating recursions.
            Please note, that dependency networks shall have the form of acyclic graphs. In acyclic graphs, propagation
            of dependencies is known to terminate.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.IDataModel.EndSetValue(System.Boolean)">
            <summary>Ends transaction safe setting of a value that has been initialized by BeginSetValue().</summary>
            <param name="commitOrRollback"> is <c>true</c> if the changes shall be committed and <c>false</c> if this shall rollback all changes since the
                   last BeginSetValue().</param>
            
        </member>
        <member name="M:WX.ComponentModel.IDataModel.BeginInit">
            <summary>All events will be deferred until EndInit() is called.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.IDataModel.EndInit">
            <summary>Fires events that have been deferred by BeginnInit().
            However, redundant events will not fire. Example: If this changes its value twice
            after BeginInit(), only the final assignment will be communicated by events.
            
            This is usually the same as PropagateValue() but additionally ends BeginnInit().
            </summary>
        </member>
        <member name="M:WX.ComponentModel.IDataModel.PropagateValue">
            <summary>Create events as if the current value has been set.
            The corresponding change event will have the current value as old value as well as 
            new value.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.IDataModel.Value">
            <summary>Read or change the encapsulated model.</summary><remarks>
                     * Writing this value is always equivalent to
                     * \code
                     IDataModel m=...;
                     m.Value=value; // this is equivalent to the following
                     
                     if (this._referenceType.IsInstanceOfType(value))
                     {
                         try
                         {
                            m.BeginSetValue(value);
                            m.EndSetValue(true);
                         }
                         catch (ErrorMessageException exc)
                         {
                            exc.Show(m.ErrorHandler);
                            m.EndSetValue(false);
                         }
                         catch (Exception exc)
                         {
                            m.EndSetValue(false);
                            throw exc;
                         }
                     }
                     else
                       throw new ArgumentException();
                     \endcode
                     * 
                     * The compatibility with the reference type is often tested in <c>BeginSetValue()</c> instead.
                     * 
                     * Please note, that this property is required to return the new value while propagating a change.</remarks>
        </member>
        <member name="P:WX.ComponentModel.IDataModel.ReferenceType">
            <summary>This is the reference type.
            This contraints assignments to <c>Value</c>.
            If reflection is used to define labale texts or visible parts of the model,
            then this type will be used.
            </summary>
        </member>
        <member name="E:WX.ComponentModel.IDataModel.OnValueChange">
            <summary>This will be called on any change to <c>Value</c>.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.IDataModel.PropagatesChanges">
            <summary>True iff all models, that this depends on, fire an event for changing a value.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.IDataModel.ErrorHandler">
            <summary>This is the used error handler. 
            This may be <c>null</c>.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.DataModelBase">
            <summary>Base class that helps to implement data models.
            This basically implements propagation of changes over depending models.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.#ctor(System.Type)">
            <summary>Create an instance of the provided reference type.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.#ctor">
            <summary>Create an instance of reference type <c>System.Object</c>.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.SetValue(System.Object)">
            <summary>Override this to change the represented value without propagation of dependencies.
            This MUST work without exceptions of IsConsistentValue() returns true.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.IsConsistentValue(System.Object)">
            <summary>True iff <c>value</c> may be assigned by <c>SetValue()</c> without error.
            This is also allowed to throw an <c>ErrorMessageException</c> in order to provide full
            information for an error handler.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.GetValue">
            <summary>Override this to read the represented value.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.PropagateChange(System.Object,System.Object)">
            <summary>This will raise <c>OnValueChange</c>.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.BeginSetValue(System.Object)">
            <summary>Initializes value changing transaction.
            This will change the value and</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.EndSetValue(System.Boolean)">
            <summary>Ends the transaction for setting a new value.
            This throws a <c>System.ApplitionException()</c>, if <c>BeginSetValue()</c> has not been called before.
            
            If <c>commitOrRollback</c> is <c>true</c>, then assign the new value. Otherwise, reset to the original value.</summary>
        </member>
        <member name="M:WX.ComponentModel.DataModelBase.PropagateValue">
            <summary>Propagate the current value raising <c>OnValueChange</c> as if the current value replaces the current value.</summary>
        </member>
        <member name="P:WX.ComponentModel.DataModelBase.Value">
            <summary>Get or set the encapsulated value.</summary>
        </member>
        <member name="P:WX.ComponentModel.DataModelBase.ReferenceType">
            <summary>The configured reference type of the value.</summary>
        </member>
        <member name="E:WX.ComponentModel.DataModelBase.OnValueChange">
            <summary>This event will be called on changing the value.</summary>
        </member>
        <member name="P:WX.ComponentModel.DataModelBase.PropagatesChanges">
            <summary>Overload this to declare whether this model is really able to detect and propagate all changes of the value.</summary>
        </member>
        <member name="P:WX.ComponentModel.DataModelBase.ErrorHandler">
            <summary>Get or set the error handler.</summary>
        </member>
        <member name="T:WX.ComponentModel.ValueModel">
            <summary>A Value model encapsulates an object. This object will be the value.</summary>
        </member>
        <member name="M:WX.ComponentModel.ValueModel.#ctor(System.Object,System.Type)">
            <summary>Creates a model of the provided value using type information from <c>referenceType</c>.
            Ths will raise an System.ArgumentException, if <c>value</c> is not an instance of <c>referenceType</c>.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.ValueModel.Value">
            <summary>
            Get or set the value.
            </summary>
        </member>
        <member name="P:WX.ComponentModel.ValueModel.PropagatesChanges">
            <summary>True, if this safely detects all changes of the encapsulated value.
            Unfortunately, this is not able to notice any change within the value if this is a class.
            However, on value types, the only way to change this is to call <c>SetValue</c>. Of course, this
            will be noticed and this change will be propagated.
            </summary>
        </member>
        <member name="T:WX.ComponentModel.PropertyModel">
            <summary>A data model observing a certain property of a structured value of a data model.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.#ctor(System.String,WX.ComponentModel.IDataModel)">
            <summary>Creates an instance encapsulating property <c>propertyName</c> of the value of <c>data</c>.
            If <c>data</c> does not have this property, this will be <c>null</c>.
            
            This will look for an <c>RaisesChangeEventAttribute</c> of the property in the reference
            type if <c>data</c> to determine, whether this propagates all changes. So, this will fail
            to keep track of changes if the property or the <c>RaisesChangeEventAttribute</c> is not declared
            in the reference type of the data source.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.OnChangingProperty(System.Object,WX.ComponentModel.ValueChangedEvent)">
            <summary>Propagate the change.</summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.AddChangeEventHandlerToObject(System.Object)">
            <summary>Adds this as listener to the event named <c>_propagatorEventName</c> in value.</summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.OnChangingDataSource(System.Object,WX.ComponentModel.ValueChangedEvent)">
            <summary>Makes sure that this listens to changes in the new value (if possible) and propagates <c>OnValueChange</c> events.</summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.ReadPropertyFromValue(System.Object)">
            <summary>Reads the property of interest of the provided value.
            If the property does not exist, return <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.ComponentModel.PropertyModel.GetValue">
            <summary>Reads property from the current data source value.</summary>
        </member>
        <member name="P:WX.ComponentModel.PropertyModel.PropagatesChanges">
            <summary>True if the data source propagates changes and this listens to an event that indicates changes of the encapsulated property of the current value that can be read from the data source.</summary>
        </member>
        <member name="T:WX.CloseEvent">
            <summary>
            This event class contains information about window and session close events.
            
            The handler function for EVT_CLOSE is called when the user has tried to close a a frame or dialog box using the
            window manager (X) or system menu (Windows). It can also be invoked by the application itself programmatically,
            for example by calling the wx.Window.Close() function.
            
            You should check whether the application is forcing the deletion of the window using wx.CloseEvent.CanVeto.
            If this is false, you must destroy the window using wx.Window.Destroy. If the return value is true, it is up to
            you whether you respond by destroying the window.
            
            If you don't destroy the window, you should call wx.CloseEvent.Veto to let the calling code know that you did
            not destroy the window. This allows the wx.Window.Close() function to return true or false depending on whether the
            close instruction was honoured or not.
            
            Please do not forget to skip the event after processing. wxWidgets may stop closig down the application
            if the event has not been skipped.
            </summary>
        </member>
        <member name="M:WX.CloseEvent.Veto">
            <summary>Listeners of this event may veto the closing sequence if they are not ready for closing.
            Do not forget to skip of not vetoed.
            </summary>
        </member>
        <member name="M:WX.CloseEvent.Veto(System.Boolean)">
            <summary>Listeners of this event may veto the closing sequence if they are not ready for closing.
            Do not forget to skip of not vetoed.
            </summary>
            <param name="veto">True if you want to vetoe, false otherwise.</param>
        </member>
        <member name="P:WX.CloseEvent.LoggingOff">
            <summary>
            Returns true if the user is just logging off or false if the system is shutting down.
            This method can only be called for end session and query end session events, it doesn't make sense for
            close window event.
            </summary>
        </member>
        <member name="P:WX.CloseEvent.CanVeto">
            <summary>
            Returns true if you can veto a system shutdown or a window close event. Vetoing a window close event is not possible
            if the calling code wishes to force the application to exit, and so this function must be called to check this.
            </summary>
        </member>
        <member name="T:WX.Xml.XmlSerialization">
            <summary>
            
            
            Instances are used to describe a deserialized object.
            This is a collection of member values associated to member names.
            Member values must be either <c>int</c>, <c>double</c>, <c>bool</c>,
            <c>string</c>, or instances of System.Xml.Serialization.IXmlSerializable
            implementing a standard CTor.
            </summary>
        </member>
        <member name="M:WX.Xml.XmlSerialization.Add(System.String,System.Object)">
            <summary>
            Adds a new member.
            </summary>
            <param name="membername">The name of the new member.</param>
            <param name="value">The value of the new member.</param>
            <exception cref="T:System.ArgumentException">If member is already defined.</exception>
        </member>
        <member name="M:WX.Xml.XmlSerialization.WriteInto(System.Object)">
            <summary>
            This will assign all members to public properties of the same name of object <c>o</c>.
            Prerequisite: Object <c>o</c> has a public property for each member name stored in this
            implementing a setter. If the setter is not implemented, the member will be ignored (in the
            hope that this property depends functionally from the other properties).
            </summary>
            <param name="o">the object whose properties will be set.</param>
            <exception cref="T:System.Exception">Member is not known.</exception>
        </member>
        <member name="M:WX.Xml.XmlSerialization.Serialize(System.Xml.XmlWriter,System.Object)">
            <summary>
            This method will serialize object <c>o</c> and  store the result
            using <c>w</c>. Object <c>o</c> can be <c>int</c>, <c>double</c>,
            <c>bool</c>, a <c>string</c>, or an object implementing a default constructor
            and <c>System.Xml.Serialization.IXmlSerializable</c>. This method can also serialize
            all public properties of objects implementing a default constructor can also be serialized
            if they implement getter and setter.
            
            This will use System.Xml.Serialization.WriteXml() if implemented by <c>o</c>.
            If you want to use this class to implement this method, you have to avoid this.
            Otherwise, you will implement an non-terminating recursion. Use the form of this 
            method providing an additional Boolean parameter to avoid the call to
            System.Xml.Serialization.WriteXml().
            </summary>
            <param name="writer">The serialization will be written into this stream.</param>
            <param name="o">This object will be serialized.</param>
        </member>
        <member name="M:WX.Xml.XmlSerialization.Serialize(System.Xml.XmlWriter,System.Object,System.Boolean)">
            <summary>
            This method will serialize object <c>o</c> and  store the result
            using <c>w</c>. Object <c>o</c> can be <c>int</c>, <c>double</c>,
            <c>bool</c>, a <c>string</c>, or an object implementing a default constructor
            and <c>System.Xml.Serialization.IXmlSerializable</c>. This method can also serialize
            all public properties of objects implementing a default constructor can also be serialized
            if they implement getter and setter. Additionally, this mehtod can serialze arrays.
            </summary>
            <param name="writer">The serialization will be written into this stream.</param>
            <param name="o">This object will be serialized.</param>
            <param name="useNativeSerializationIfAvailable">If <c>true</c>, this method will use
            System.Xml.Serialization.WriteXml() if implemented by <c>o</c>. Use <c>false</c> here if
            you use this mehtod to implement System.Xml.Serialization.WriteXml().
            </param>
        </member>
        <member name="M:WX.Xml.XmlSerialization.Deserialize(System.Xml.XmlReader,System.Object)">
            <summary>
            Use this method to implement ReadXml() with objects that have been serialized with
            Serialize(). All serialized members must be a name of a public property implementing a
            setter for this to work.
            </summary>
            <param name="reader">The source providing the serialized data.</param>
            <param name="value">The value whise properties will be set according to the serialized members.</param>
        </member>
        <member name="M:WX.Xml.XmlSerialization.Deserialize(System.Xml.XmlReader)">
            <summary>
            This will deserialize objects that have been serialized with serialize().
            If possible, this method will replace deserialized instances of XmlSerialization by
            instances of the original type. Prerequisites: The original type has been serialized and
            all public properties implement setters. 
            </summary>
            <param name="reader">The source providing the serialized data.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Xml.XmlSerialization.GetEnumerator">
            <summary>
            This enumerator iterates instances of <c>KeyValuePair&lt;string, object&gt;</c>
            containing the name of a member and its value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.Xml.XmlSerialization.SerializedType">
            <summary>
            The type of the object that has been serialized.
            Deserialization will restore this type and use public setters to assign the deserialized
            attributes. If this is not possible, deserialization will use an instance of XmlSerialization
            to store everything that has been read from the XML reader.
            </summary>
        </member>
        <member name="P:WX.Xml.XmlSerialization.Item(System.String)">
            <summary>
            Returns the value associated with the membername.
            </summary>
            <param name="membername">The name of the member whose value is desired.</param>
            <returns></returns>
        </member>
        <member name="P:WX.Xml.XmlSerialization.Membernames">
            <summary>
            Returns a collection of all member names that can be dereferenced by the indexer.
            </summary>
        </member>
        <member name="T:WX.NotebookEvent">
            <summary>This event will be raised on selecting tabs in notebooks.</summary>
        </member>
        <member name="P:WX.NotebookEvent.Selection">
            <summary>Returns the currently selected page, or -1 if none was selected.
            NB: under Windows, <c>Selection</c> will return the same value as <c>OldSelection</c> when called from
            <c>EVT_NOTEBOOK_PAGE_CHANGING</c> handler and not the page which is going to be selected.
            Also note that the values of selection and old selection returned for an event generated in
            response to a call to wx.Notebook.SetSelection shouldn't be trusted as they are currently inconsistent
            under different platforms (but in this case you presumably don't need them anyhow as you already
            have the corresponding information).</summary>
        </member>
        <member name="T:WX.Notebook">
             <summary>
             This class represents a notebook control, which manages multiple windows with associated tabs.
            
             To use the class, create a wx.Notebook object and call AddPage or InsertPage, passing a window to be
             used as the page. Do not explicitly delete the window for a page that is currently managed by wx.Notebook.
             </summary>
             <remarks>
             \image html notebooksmall.png
             </remarks>
        </member>
        <member name="M:WX.Notebook.GetPage(System.Int32)">
            <summary>
            The window representing the page.
            </summary>
            <param name="page">Zero-based index</param>
        </member>
        <member name="P:WX.Notebook.Selection">
            <summary>
            The zero-based index of the currently selected page. Use this property
            to read or set the currently selected note.
            </summary>
        </member>
        <member name="F:WX.wxImageList.wxIMAGE_LIST_NORMAL">
            <summary>Normal size icons.</summary>
        </member>
        <member name="F:WX.wxImageList.wxIMAGE_LIST_SMALL">
            <summary>Small size icons</summary>
        </member>
        <member name="F:WX.wxImageList.wxIMAGE_LIST_STATE">
            <summary>Not yet implemented.
            Refer to  wxWidgets documentation.</summary>
        </member>
        <member name="F:WX.wxImageList.Normal">
            <summary>Normal size icons
            Same as wxIMAGE_LIST_NORMAL().</summary>
        </member>
        <member name="F:WX.wxImageList.Small">
            <summary>Small size icons
            Same as wxIMAGE_LIST_SMALL().</summary>
        </member>
        <member name="T:WX.ImageList">
            <summary>
            An image list is a list of images that may have transparent areas.
            The class helps an application organise a collection of images so that they can be
            referenced by integer index instead of by pointer.
            </summary>
        </member>
        <member name="M:WX.ImageList.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            The mask will be created for all images.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
        </member>
        <member name="M:WX.ImageList.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
            <param name="mask">true if masks should be created for all images (default).</param>
        </member>
        <member name="M:WX.ImageList.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
            <param name="mask">true if masks should be created for all images.</param>
            <param name="initialCount">The initial size of the list.</param>
        </member>
        <member name="M:WX.ImageList.Add(WX.Bitmap)">
            <summary>
            Adds a new image or images using a bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:WX.ImageList.Add(WX.Bitmap,WX.Bitmap)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <param name="mask">Monochrome mask bitmap, representing the transparent areas of the image. </param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:WX.ImageList.Add(WX.Icon)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="icon">Icon to use as the image.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:WX.ImageList.Add(WX.Bitmap,WX.Colour)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <param name="maskColour">Colour indicating which parts of the image are transparent.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:WX.ImageList.GetBitmap(System.Int32)">
            <summary>
            Returns the bitmap of the provided zero-based index.
            </summary>
            <param name="index">The index of the bitmap to be returned</param>
        </member>
        <member name="P:WX.ImageList.Count">
            <summary>
            Number of images.
            </summary>
        </member>
        <member name="P:WX.ImageList.ImageCount">
            <summary>
            Number of images
            </summary>
        </member>
        <member name="P:WX.ImageList.Item(System.Int32)">
            <summary>
            Synonym for GetBitmap().
            </summary>
            <param name="index">The zero-based index of the bitmap to return.</param>
        </member>
        <member name="P:WX.ImageList.Item(System.Enum)">
            <summary>
            Synonym for <c>GetBitmap((int) index)</c>. This is a convenience functions for those
            using enumerations as image indices.
            </summary>
            <param name="index">The enumeration instance designating the image.</param>
            <returns>The designated bitmap.</returns>
        </member>
        <member name="T:WX.Html.Help.HtmlHelpController">
            <summary>
            The help controller.
            </summary>
            <remarks>
            \image html htmlhelpsmall.png
            </remarks>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.GetSingleton">
            <summary>
            Returns the singleton. If you call this for the first time,
            this will create a singleton of default style.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.SetInstance(WX.Html.Help.HtmlHelpController)">
            <summary>
            Sets the singleton. If a singleton already exists, this will be replaced.
            </summary>
            <param name="newSingleton">The instance that shall become the new singleton.</param>
            <returns>If this call replaces an existing singleton, the old singleton
            will be returned. This is <c>null</c> otherwise.</returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.SetInstance(WX.Html.Help.HtmlHelpController.Style)">
            <summary>
            Sets the singleton. If a singleton already exists, this will be replaced.
            </summary>
            <param name="newSingleton">The new singleton will be an instance of this style.</param>
            <returns>If this call replaces an existing singleton, the old singleton
            will be returned. This is <c>null</c> otherwise.</returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.AddBook(System.String)">
            <summary>Adds the book at the provided file name.
            In contrast to the  wxWidgets version, this method
            silently installs the  wx file handler for zip file
            entries. The file system is currently not wrapped since
            the .NET framework implements most of the provided functions.
            However, handling of zip-archives is required to deal with
            hyper text books (HTB), so this ability will be installed on
            using it.</summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.AddBook(WX.wxString)">
            <summary>Adds the book at the provided file name.
            In contrast to the  wxWidgets version, this method
            silently installs the  wx file handler for zip file
            entries. The file system is currently not wrapped since
            the .NET framework implements most of the provided functions.
            However, handling of zip-archives is required to deal with
            hyper text books (HTB), so this ability will be installed on
            using it.</summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.Display(System.String)">
            <summary>
            Displays page x. This is THE important function - it is used 
            to display the help in application.
            </summary>
            <remarks>
            You can specify the page in many ways:
            \li as direct filename of HTML document 
            \li as chapter name (from contents) or as a book name 
            \li as some word from index 
            \li even as any word (will be searched) 
            
            Looking for the page runs in these steps:
            \li try to locate file named x (if x is for example "doc/howto.htm") 
            \li try to open starting page of book named x 
            \li try to find x in contents (if x is for example "How To ...") 
            \li try to find x in index (if x is for example "How To ...") 
            \li switch to Search panel and start searching 
            </remarks>>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.Display(WX.wxString)">
            <summary>
            Displays page x. This is THE important function - it is used 
            to display the help in application.
            </summary>
            <remarks>
            You can specify the page in many ways:
            \li as direct filename of HTML document 
            \li as chapter name (from contents) or as a book name 
            \li as some word from index 
            \li even as any word (will be searched) 
            
            Looking for the page runs in these steps:
            \li try to locate file named x (if x is for example "doc/howto.htm") 
            \li try to open starting page of book named x 
            \li try to find x in contents (if x is for example "How To ...") 
            \li try to find x in index (if x is for example "How To ...") 
            \li switch to Search panel and start searching 
            </remarks>>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.Display(System.Int32)">
            <summary>
            This alternative form is used to search help contents by numeric IDs.
            </summary>
            <param name="id">ID of a help context</param>
            <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.DisplayContents">
            <summary>
            Display the table of contents.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.DisplayIndex">
            <summary>
            Display the "Index" page.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.KeywordSearch(System.String)">
             <summary>
             Displays help window, focuses search panel and starts searching.
             Returns true if the keyword was found. This will search for occurances
             of the keyword in the content if help pages.
            
             Important: KeywordSearch searches only pages listed in .hhc file(s).
             You should list all pages in the contents file.
             </summary>
             <param name="keyword">The keyword that this method will search for.</param>
             <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.KeywordSearch(System.String,WX.Html.Help.HelpSearchMode)">
             <summary>
             Displays help window, focuses search panel and starts searching.
             Returns true if the keyword was found. Optionally it searches
             through the index (mode = wxHELP_SEARCH_INDEX), default the
             content (mode = wxHELP_SEARCH_ALL).
            
             Important: KeywordSearch searches only pages listed in .hhc file(s).
             You should list all pages in the contents file.
             </summary>
             <param name="keyword">The keyword that this method will search for.</param>
             <returns></returns>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpController.KeywordSearch(WX.wxString,WX.Html.Help.HelpSearchMode)">
             <summary>
             Displays help window, focuses search panel and starts searching.
             Returns true if the keyword was found. Optionally it searches
             through the index (mode = wxHELP_SEARCH_INDEX), default the
             content (mode = wxHELP_SEARCH_ALL).
            
             Important: KeywordSearch searches only pages listed in .hhc file(s).
             You should list all pages in the contents file.
             </summary>
             <param name="keyword">The keyword that this method will search for.</param>
             <returns></returns>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpController.TitleFormat">
            <summary>This property is for writing only and set the title format.</summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpController.TempDir">
            <summary>Write-only property to set the directory for temporary files (option for better performance).</summary>
        </member>
        <member name="T:WX.Html.Help.HtmlHelpController.Style">
            <summary>Some style flags for the HtmlHelpController.</summary>
        </member>
        <member name="T:WX.CannotChangeReadonly">
            <summary>
            This exception will be thrown if modifiers of readonly (ICanBeMadeReadonly) objects are used.
            </summary>
        </member>
        <member name="T:WX.ColourDatabase">
            <summary>The database of colours.
            Use whenever possible a database of colours.
            Property <c>TheColourDatabase</c> provides access to  wxWidget's standard colour database.</summary>
        </member>
        <member name="P:WX.ColourDatabase.TheColourDatabase">
            <summary>The standard database.
            The standard database contains at least the following colours:
            AQUAMARINE, BLACK, BLUE, BLUE VIOLET, BROWN, CADET BLUE, CORAL, CORNFLOWER BLUE, CYAN, DARK GREY,
            DARK GREEN, DARK OLIVE GREEN, DARK ORCHID, DARK SLATE BLUE, DARK SLATE GREY DARK TURQUOISE,
            DIM GREY, FIREBRICK, FOREST GREEN, GOLD, GOLDENROD, GREY, GREEN, GREEN YELLOW, INDIAN RED, KHAKI,
            LIGHT BLUE, LIGHT GREY, LIGHT STEEL BLUE, LIME GREEN, MAGENTA, MAROON, MEDIUM AQUAMARINE, MEDIUM BLUE,
            MEDIUM FOREST GREEN, MEDIUM GOLDENROD, MEDIUM ORCHID, MEDIUM SEA GREEN, MEDIUM SLATE BLUE,
            MEDIUM SPRING GREEN, MEDIUM TURQUOISE, MEDIUM VIOLET RED, MIDNIGHT BLUE, NAVY, ORANGE, ORANGE RED,
            ORCHID, PALE GREEN, PINK, PLUM, PURPLE, RED, SALMON, SEA GREEN, SIENNA, SKY BLUE, SLATE BLUE,
            SPRING GREEN, STEEL BLUE, TAN, THISTLE, TURQUOISE, VIOLET, VIOLET RED, WHEAT, WHITE, YELLOW,
            YELLOW GREEN.</summary>
        </member>
        <member name="T:WX.PenList">
            <summary>Wrapper for <c>wxPenList</c>.
            Whenever possible use static property <c>ThePenList() </c>.
            </summary>
        </member>
        <member name="M:WX.PenList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="M:WX.PenList.FindOrCreatePen(WX.Colour,System.Int32,WX.Pen.Styles)">
            <summary>
            Find a pen of the provided properties or create one.
            </summary>
            <param name="colour">The colour of the desired pen.</param>
            <param name="width">The width of the desired pen.</param>
            <param name="style">The style of the desired pen.</param>
            <returns></returns>
        </member>
        <member name="P:WX.PenList.ThePenList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:WX.BrushList">
            <summary>Wrapper for <c>wxBrushList</c>.
            Whenever possible use static property <c>TheBrushList()</c>.
            </summary>
        </member>
        <member name="M:WX.BrushList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="M:WX.BrushList.FindOrCreateBrush(WX.Colour,WX.Brush.Styles)">
            <summary>
            Find or create a brush of the provided properties. This methods allows independent
            parts of the application to share the same instances for brushes. This is important,
            because some OS like windows assign special identifiers (handles) to each living instance
            of a brush - and these identifiers can be a rare resource.
            </summary>
            <param name="colour">The colour of the brush.</param>
            <param name="style">The style of the brush.</param>
            <returns></returns>
        </member>
        <member name="P:WX.BrushList.TheBrushList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:WX.FontList">
            <summary>Wrapper for <c>wxFontList</c>.
            Whenever possible use property TheFontList() to retrieve fonts.
            </summary>
        </member>
        <member name="M:WX.FontList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="M:WX.FontList.FindOrCreateWithFamily(WX.Font,WX.FontFamily)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>family</c>.
            </summary>
        </member>
        <member name="M:WX.FontList.FindOrCreateWithWeight(WX.Font,WX.FontWeight)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>weight</c>.
            </summary>
        </member>
        <member name="M:WX.FontList.FindOrCreateWithStyle(WX.Font,WX.FontStyle)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>style</c>.
            </summary>
        </member>
        <member name="M:WX.FontList.FindOrCreateWithSize(WX.Font,System.Int32)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>size</c>.
            </summary>
        </member>
        <member name="M:WX.FontList.FindOrCreateUnderlined(WX.Font,System.Boolean)">
            <summary>Get a font with all properties from <c>prototype</c> but underlined according to <c>isUnderlined</c>.
            </summary>
        </member>
        <member name="P:WX.FontList.TheFontList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:WX.BitmapList">
            <summary>
            List of bitmaps that can be used in controls (ListCtrl) to associate data with icons.
            </summary>
        </member>
        <member name="M:WX.BitmapList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="T:WX.StockCursors">
            <summary>
            A class providing instances of some builtin cursors.
            </summary>
        </member>
        <member name="T:WX.DataObjectGeneric">
            <summary>
            A generic wrapper of .NET data (that can be serialized by the Xml serialize - default constructor
            is required and all properties to be serialized need to have getters and setters).
            This will use the full class name of the object as format identifier.
            </summary>
            <example>
            Simply create an instance of this wrapping a serializable object and pass it to a drop source
            or hte clipboard.
            <code>
            public class SerializableObject
            {
               ...
               // serializable objects must have a public standard ctor
               public SerializableObject()
               {
                  ...
               }
               
               // the standard Xml serializer will be used. this serializer
               // exclusively reads public properties on properties and sets them
               // on deserialization. thus, all properties must have public getter 
               // and setter.
               int ASampleProperty
               {
                   get { ... }
                   set { ... }
               }
            }
            ....
            class ...
            {
               ...
               void CopyToClipboard(SerializableObject obj)
               {
                    wx.Clipboard.TheClipboard.Open();
                    try
                    {
                        wx.Clipboard.TheClipboard.Open();
                        wx.Clipboard.TheClipboard.SetData(new DataObjectGeneric(obj));
                    }
                    finally
                    {
                        wx.Clipboard.TheClipboard.Close();
                    }
               }
               
               SerializableObject CopyFromClipboard()
               {
                    wx.Clipboard.TheClipboard.Open();
                    try
                    {
                        wx.Clipboard.TheClipboard.Open();
                        DataObjectGeneric result=new DataObjectGeneric(new SerializableObject());
                        
                        if (wx.Clipboard.TheClipboard.GetData(result))
                            return result.Data as SerializableObject;
                        else
                            return null;
                    }
                    finally
                    {
                        wx.Clipboard.TheClipboard.Close();
                    }
               }
            }
            </code>
            </example>
        </member>
        <member name="M:WX.DataObjectGeneric.#ctor(System.Object)">
            <summary>
            Creates a new instance wrapping the provided data. The data
            MUST be non-null and serializable.
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:WX.DataObjectGeneric.ByteData">
            <summary>Get or set the serialization of the contained data.</summary>
        </member>
        <member name="T:WX.TextDataObject">
             <summary>
             wx.TextDataObject is a specialization of wx.DataObject for text data.
             It can be used without change to paste data into the wx.Clipboard or a wx.DropSource.
             A user may wish to derive a new class from this class for providing text on-demand in order to minimize
             memory consumption when offering data in several formats, such as plain text and RTF because by default
             the text is stored in a string in this class, but it might as well be generated when requested.
            
             Note that if you already have the text inside a string, you will not achieve any efficiency gain by
             overriding these functions because copying wxStrings is already a very efficient operation (data is not
             actually copied because wxStrings are reference counted).
             </summary>
        </member>
        <member name="T:WX.FileDataObject">
             <summary>
             wx.FileDataObject is a specialization of wx.DataObject for file names.
             The program works with it just as if it were a list of absolute file names,
             but internally it uses the same format as Explorer and other compatible programs
             under Windows or GNOME/KDE filemanager under Unix which makes it possible to receive
             files from them using this class.
            
             Warning: Under all non-Windows platforms this class is currently "input-only", i.e.
             you can receive the files from another application, but copying (or dragging) file(s)
             from a wxWidgets application is not currently supported. PS: GTK2 should work as well.
             </summary>
        </member>
        <member name="T:WX.BitmapDataObject">
            <summary>
            wx.BitmapDataObject is a specialization of wx.DataObject for bitmap data.
            It can be used without change to paste data into the wx.Clipboard or a wx.DropSource.
            A user may wish to derive a new class from this class for providing a bitmap on-demand in order to minimize
            memory consumption when offering data in several formats, such as a bitmap and GIF.
            
            This is a simple data object and can, thus, occur in composite data objects (wx.DataObjectComposite).
            </summary>
        </member>
        <member name="T:WX.DataObjectComposite">
            <summary>wx.DataObjectComposite is the simplest way to implement wx.DataObject supporting multiple formats.
             It contains several wx.DataObjectSimple and
             supports all formats supported by any of them.
            
             This class shouldn't be (normally) derived from, but may be used directly.
             If you need more flexibility than what it provides, you should probably use
             wx.DataObject directly.
             </summary>
        </member>
        <member name="M:WX.DataObjectComposite.#ctor">
            <summary>
            Creates an instance that shall be extended with Add().
            </summary>
            <seealso cref="M:WX.DataObjectComposite.Add(WX.DataObjectSimple,System.Boolean)"/>
        </member>
        <member name="M:WX.DataObjectComposite.#ctor(WX.DataObjectSimple,WX.DataObjectSimple[])">
            <summary>
            Creates an instance that can directly be used.
            </summary>
            <param name="preferredObject">A data object - that shall not be another composite - that will be added
            to the possible contents of this composite. The preferred format of this object will become the preferred
            format of this object.</param>
            <param name="additionalParts">Additional data objects defining additional possible formats of
            this object.</param>
        </member>
        <member name="M:WX.DataObjectComposite.Add(WX.DataObjectSimple,System.Boolean)">
            <summary>Add data object (it will be deleted by wx.DataObjectComposite).
            </summary>
            <param name="preferred"> specifies with <c>true</c>, that the format of <c>newPart</c> will become the preferred one.
            </param>
            <param name="newPart">New part of this composite. Do not add another compposite here.</param>
        </member>
        <member name="M:WX.DataObjectComposite.Add(WX.DataObjectSimple)">
            <summary>Add data object (it will be deleted by wx.DataObjectComposite).
            The format of <c>newPart</c> will become the preferred one.</summary>
        </member>
        <member name="M:WX.DataObjectComposite.GetNonEmptyObjects">
            <summary>
            Returns a collection of those data objects that are not empty - that contain data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.DataObjectComposite.GetOneNoneEmptyObject">
            <summary>
            This method returns one of those contained simple objects that contain some data.
            If all contained simple objects are empty, the result is <c>null</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.DataObjectComposite.AllObjects">
            <summary>
            Returns all contained simple objects.
            </summary>
        </member>
        <member name="T:WX.FontCtrl">
            <summary>This is a control to put in fonts that may be used within forms or tables.
            This is a panel composed of a masked edit control allowing for the input of plattform indpendent font attributes and
            a button, that will rise a font dialog if pressed. 
            
            Use the styles wx.WindowStyles.FONTCTRL_EDIT_POINT_SIZE, wx.WindowStyles.FONTCTRL_EDIT_FONT_FAMILY,
            wx.WindowStyles.FONTCTRL_EDIT_FONT_WEIGHT, wx.WindowStyles.FONTCTRL_EDIT_FONT_STYLE, and wx.WindowStyles.FONTCTRL_EDIT_FONT_COLOUR
            to customize the input fields</summary>
        </member>
        <member name="E:WX.FontCtrl.OnChanged">
            <summary>This will be called immediately after a value has been changed.</summary>
        </member>
        <member name="T:WX.FontCtrl.OnChangedEvent">
            <summary>Argument of change event handlers.</summary>
        </member>
        <member name="T:WX.FontCtrl.OnChangedHandler">
            <summary>Handler of the "value changed" event.</summary>
        </member>
        <member name="T:WX.ColourCtrl">
            <summary>This is a control to put in colours that may be used within forms or tables.
            This is a panel composed of a masked edit control allowing for the input of RGB and Alpha values and
            a button, that will rise a colour dialog if pressed. The button will be coloured in the specified
            colour.</summary>
        </member>
        <member name="E:WX.ColourCtrl.OnChanged">
            <summary>This will be called immediately after a value has been changed.</summary>
        </member>
        <member name="P:WX.ColourCtrl.Colour">
            <summary>This is for reading the colour input.</summary>
        </member>
        <member name="T:WX.ColourCtrl.OnChangedEvent">
            <summary>Argument of change event handlers.</summary>
        </member>
        <member name="T:WX.ColourCtrl.OnChangedHandler">
            <summary>Handler of the "value changed" event.</summary>
        </member>
        <member name="T:WX.BitmapButton">
            <summary>Button showing a bitmap.
            Special style flag: wx.WindowStyles.ButtonAutoDraw.</summary>
        </member>
        <member name="T:WX.Mask">
            <summary>
            This class encapsulates a monochrome mask bitmap, where the masked area is black and the unmasked area is white.
            When associated with a bitmap and drawn in a device context, the unmasked area of the bitmap will be drawn,
            and the masked area will not be drawn.
            </summary>
            <remarks>
            A mask may be associated with a wx.Bitmap. It is used in wx.DC.Blit when the source device context is a wx.MemoryDC
            with wx.Bitmap selected into it that contains a mask.
            </remarks>
        </member>
        <member name="M:WX.Mask.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:WX.Mask.#ctor(WX.Bitmap,WX.Colour)">
            <summary>
            Constructs a mask from a bitmap and a colour that indicates the background.
            </summary>
            <param name="bitmap">The bitmap that this ctor will create a mask for.</param>
            <param name="colour">The colour that indicates the background of the bitmap.</param>
        </member>
        <member name="M:WX.Mask.#ctor(WX.Bitmap,System.Int32)">
            <summary>
            Constructs a mask from a bitmap and a colour that indicates the background.
            </summary>
            <param name="bitmap">The bitmap that this ctor will create a mask for.</param>
            <param name="paletteIndex">The colour that indicates the background of the bitmap
            specified as an index in the palette used by the bitmap.</param>
        </member>
        <member name="M:WX.Mask.#ctor(WX.Bitmap)">
            <summary>
            Constructs the mask from a monochrome bitmap.
            </summary>
            <param name="bitmap">A bitmap that shall be monochrome.</param>
        </member>
        <member name="M:WX.Mask.Create(WX.Bitmap,System.Int32)">
            <summary>
            Creates a mask from a bitmap and a colour that indicates the background.
            </summary>
            <param name="bitmap">The bitmap that this ctor will create a mask for.</param>
            <param name="paletteIndex">The colour that indicates the background of the bitmap
            specified as an index in the palette used by the bitmap.</param>
        </member>
        <member name="M:WX.Mask.Create(WX.Bitmap)">
            <summary>
            Creates a mask from a bitmap and a colour that indicates the background.
            </summary>
            <param name="bitmap">The bitmap that this ctor will create a mask for.</param>
            <param name="colour">The colour that indicates the background of the bitmap.</param>
        </member>
        <member name="T:WX.SashWindow">
            <summary>
            SashWindow allows any of its edges to have a sash which can be dragged to resize the window.
            The actual content window will be created by the application as a child of SashWindow. The window
            (or an ancestor) will be notified of a drag via a wxSashEvent notification.
            </summary>
            <remarks>
            \image html sashwindow.png
            </remarks>
        </member>
        <member name="M:WX.SashWindow.SetSashVisible(WX.SashEdgePosition,System.Boolean)">
            <summary>
            Call this function to make a sash visible or invisible on a particular edge.
            </summary>
            <param name="edge">The sash that shall be set or reset.</param>
            <param name="sash">true to make the sash visible, false to make it invisible.</param>
        </member>
        <member name="M:WX.SashWindow.GetSashVisible(WX.SashEdgePosition)">
            <summary>
            Returns true if a sash is visible on the given edge, false otherwise.
            </summary>
            <param name="edge">The edge that shall be reported</param>
        </member>
        <member name="T:WX.EventListener">
            <summary>A delegate calling handlers for instances of wx.Event.</summary>
        </member>
        <member name="T:WX.ErrorEvent">
            <summary>
            Data on an error that has been encountered by an event handler during the
            processign of an event.
            Handlers of these events typically open a message box or display an error mark
            somewhere in the GUI.
            </summary>
        </member>
        <member name="M:WX.ErrorEvent.SkipDefaultErrorHandler">
            <summary>
            The default error handler - raising a message box - will be skipped 
            after calling this method.
            </summary>
        </member>
        <member name="P:WX.ErrorEvent.ShallTheDefaultErrorHandlerBeSkipped">
            <summary>
            True iff a handler of the error event told the sender of the event to skip
            the default error handler.
            </summary>
        </member>
        <member name="P:WX.ErrorEvent.InnerException">
            <summary>
            If this error event has been cause by an exception - the normal case - this
            property provides you access to this exception.
            </summary>
        </member>
        <member name="T:WX.ErrorEventHandler">
            <summary>
            Type of error event handlers that shall react on exceptions caught by a EvtHandler while
            executing an event.
            </summary>
            <param name="sender">This is the (virtual) sender of the event - the event handler that has been called.</param>
            <param name="evt">This contains data on the error.</param>
        </member>
        <member name="T:WX.Drag">
            <summary> Flags to define the drag operation in wx.DragSource.DoDragDrop().</summary>
            <remarks>Cf. \ref drag-and-drop.</remarks>
        </member>
        <member name="T:WX.DropSource">
            <summary>
            This class represents a source for a drag and drop operation.
            </summary>
            <remarks>Cf. \ref drag-and-drop</remarks>
        </member>
        <member name="M:WX.DropSource.#ctor(System.IntPtr)">
            <summary>
            For internal use only
            </summary>
            <param name="wxObject">Pointer to a native C++ instance</param>
        </member>
        <member name="M:WX.DropSource.#ctor(WX.Window)">
            <summary>
            Creates a drop source referring to the provided window as data source.
            </summary>
            <param name="win">The source of the dropped data.</param>
        </member>
        <member name="M:WX.DropSource.#ctor(WX.DataObject,WX.Window)">
            <summary>
            Creates a drop source referring to a window provising the data and the dragged data.
            </summary>
            <param name="dataObject">The dragged data.</param>
            <param name="win">The source of the dropped data.</param>
        </member>
        <member name="M:WX.DropSource.DoDragDrop(WX.Drag)">
            <summary>
            Do it (call this in response to a mouse button press, for example).
            This starts the drag-and-drop operation which will terminate when the user releases the mouse.
            </summary>
            <param name="flags">Describes the drag operation.
            If wx.Drag.wxDrag_AllowMove is included in the flags, data may be moved and not only copied (default).
            If wx.Drag.wxDrag_DefaultMove is specified (which includes the previous flag), this is even the default 
            operation.</param>
            <returns>Returns the operation requested by the user, may be wx.Drag.wxDragCopy, wx.Drag.wxDragMove,
            wx.Drag.wxDragLink, wx.Drag.wxDragCancel, or wx.Drag.wxDragNone if an error occurred.</returns>
        </member>
        <member name="T:WX.DropTarget">
             <summary>
             This class represents a target for a drag and drop operation. A wx.DataObject can be associated with it and by default,
             this object will be filled with the data from the drag source, if the data formats supported by the data object match
             the drag source data format.
             
             YOU HAVE TO SET A DATA OBJECT (PREFERABLY IN THE CTOR) BEFORE USING THIS INSTANCE. Otherwise, access violations
             may result.
            
             There are various virtual handler functions defined in this class which may be overridden to give visual feedback or
             react in a more fine-tuned way, e.g. by not accepting data on the whole window area, but only a small portion of it.
             The normal sequence of calls is OnEnter(), possibly many times OnDragOver(), OnDrop() and finally OnData().
             </summary>
             <remarks>
             Cf. \ref drag-and-drop.
             </remarks>
        </member>
        <member name="M:WX.DropTarget.OnDragOver(System.Int32,System.Int32,WX.DragResult)">
            <summary>
            Called when the mouse is being dragged over the drop target.
            By default, this calls functions return the suggested return value "def".
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
        </member>
        <member name="M:WX.DropTarget.OnDrop(System.Int32,System.Int32)">
            <summary>
            Called when the user drops a data object on the target. Return false to veto the operation.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="M:WX.DropTarget.GetData">
            <summary>
            This method may only be called from within <c>OnData</c>.
            By default, this method copies the data from the drop source to the wxDataObject associated with this
            drop target, calling its wx.DataObject.SetData method.
            </summary>
            <seealso cref="M:WX.DropTarget.OnData(System.Int32,System.Int32,WX.DragResult)"/>
        </member>
        <member name="M:WX.DropTarget.OnData(System.Int32,System.Int32,WX.DragResult)">
            <summary>
            Called after OnDrop() returns true. By default this will usually GetData() and will return the suggested default
            value def.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
            <seealso cref="M:WX.DropTarget.GetData"/>
        </member>
        <member name="M:WX.DropTarget.RunErrorHandler(System.Exception)">
            <summary>
            Runs the defined error handlers to display the error as given by the argument.
            This will run the default error handler if not skipped by one of the handlers
            of the error event.
            </summary>
            <param name="exc">The error to be displayed.</param>
        </member>
        <member name="M:WX.DropTarget.OnEnter(System.Int32,System.Int32,WX.DragResult)">
            <summary>
            Called when the mouse enters the drop target. By default, this calls OnDragOver().
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
            <returns>Returns the desired operation or wxDragNone. This is used for optical feedback from the
            side of the drop source, typically in form of changing the icon.</returns>
        </member>
        <member name="M:WX.DropTarget.OnLeave">
            <summary>
            Called when the mouse leaves the drop target.
            </summary>
        </member>
        <member name="E:WX.DropTarget.OnError">
            <summary>
            This event will be raised on exceptions.
            </summary>
        </member>
        <member name="P:WX.DropTarget.DataObject">
            <summary>
            Getter: Return the data object that is associated with this drop process.
            Available after OnDrop() for instance OnData().
            
            Setter:
            Sets the data wxDataObject associated with the drop target and deletes any previously associated data object.
            Please note, that you must set a data object before this target can be activated.
            </summary>
        </member>
        <member name="T:WX.TextDropTarget">
            <summary>
            A predefined drop target for dealing with text data.
            </summary>
            <remarks>
            Cf. \ref drag-and-drop.
            </remarks>
        </member>
        <member name="M:WX.TextDropTarget.OnDropText(System.Int32,System.Int32,System.String)">
            <summary>
            Override this function to receive dropped text.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="text">The data being dropped: a string.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="T:WX.FileDropTarget">
            <summary>
            This is a drop target which accepts files e.g. dragged from File Manager or Explorer
            (\ref drag-and-drop).
            </summary>
        </member>
        <member name="M:WX.FileDropTarget.OnDropFiles(System.Int32,System.Int32,System.String[])">
            <summary>Called if files are dropped on this target.</summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="filenames">Names of the files to be dropped</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="M:WX.FileDropTarget.OnDrop(System.Int32,System.Int32)">
            <summary>
            See wx.DropTarget.OnDrop. This function is implemented appropriately for files, and calls wx.FileDropTarget.OnDropFiles().
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridSelectionMode">
            <summary>
            Flags describing the selection mode in extended grids. Refer to ExtendedGrid.SelectionMode.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ToString">
            <summary>
            This is to represent an option to convert an object into a string.
            </summary>
            <param name="o">The object that shall be converted to a string.</param>
            <param name="ci">The culture that shall be used for output.</param>
            <returns></returns>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColourSet3D">
            <summary>
            This is a colour set intended for renderers drawing a 3D button effect.
            Selected cells can for instance drawn sunken, unselected cells as raised
            buttons.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet3D.#ctor">
            <summary>
            A ctor setting the colours accourding to the system colours
            SystemColour.COLOUR_BTNFACE, SystemColour.COLOUR_BTNHIGHLIGHT,
            SystemColour.COLOUR_BTNSHADOW, SystemColour.COLOUR_3DDKSHADOW, and SystemColour.COLOUR_BTNTEXT.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet3D.#ctor(WX.GridCtrl.Extended.ColourSet3D)">
            <summary>
            Creates a shallow copy of the argument assigning the colour instances
            contained by the source also to this. The new instance is guaranteed
            to be not readonly.
            </summary>
            <param name="src">The source of the copied data.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet3D.MakeReadOnly">
            <summary>
            Makes this and all property instances of colours readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet3D.Clone">
            <summary>
            Creates a shallow copy of this instance referring to the same instances
            of class wx.Colour that are contained by this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.BtnFaceColour">
            <summary>
            The colour of the face of the 3D raised button.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.PrimarySelectionFaceColour">
            <summary> This colour will be used for the surface of a 3D button representing the cell that is the primary
            selection. The primary selection is the cell that will open its editor e.g. on pressing key F2. However,
            this colour will only be used in selection modes allowing also non-primary selections like row or column selection
            mode or the multi-selection modes.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.BtnHightlightColour">
            <summary>
            The colour of the highlighted parts of the 3D button.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.BtnShadowColour">
            <summary>
            The colour of the parts of the 3D buttons that are in shadow.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.BtnDarkShadow">
            <summary>
            The colour that will be used for that part of the button's outline that is on the shadow side.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.BtnTextColour">
            <summary>
            The text colour for the label of the button.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.PrimarySelectionTextColour">
            <summary> This colour will be used for the text of a 3D button representing the cell that is the primary
            selection. The primary selection is the cell that will open its editor e.g. on pressing key F2. However,
            this colour will only be used in selection modes allowing also non-primary selections like row or column selection
            mode or the multi-selection modes.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if using the setter in readonly mode.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet3D.IsReadonly">
            <summary>
            Returns true if thsi is for reading only.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColourSet2D">
            <summary>
            A colour set for those renderers drawing in a simple 2D style.
            This will distinguish a foreground colour for frame and text. A background
            colour is intended to be used for the background of the cell.
            
            This set will provide 2 foreground and 2 background colours: One pair of colours
            for unselected, one pair for selected cells.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet2D.#ctor">
            <summary>
            A ctor using the system colours SystemColour.COLOUR_WINDOW, SystemColour.COLOUR_WINDOWTEXT,
            SystemColour.COLOUR_HIGHLIGHT, and SystemColour.COLOUR_HIGHLIGHTTEXT.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet2D.#ctor(WX.Colour,WX.Colour,WX.Colour,WX.Colour,WX.Colour,WX.Colour)">
            <summary>
            Creates an instance from the provided colours.
            </summary>
            <param name="fgColour">The foreground colour that will for instance be used to display text.</param>
            <param name="bgColour">The background colour.</param>
            <param name="fgColourSelected">The foreground colour of a selected cell.</param>
            <param name="bgColourSelected">The background colour of a selected cell.</param>
            <param name="fgColourPrimSelection">The foreground colour of the primary selection - the cell that will open its editor.</param>
            <param name="bgColourPrimSelection">The background colour of the primary selection - the cell that will open its editor.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet2D.#ctor(WX.GridCtrl.Extended.ColourSet2D)">
            <summary>
            This will create a shallow copy of the argument using the same instances
            for each of the contained colours. This is to prevent excessive use of handles
            for colours. The new instance is guaranteed to be NOT readonly.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet2D.MakeReadOnly">
            <summary>
            This will make this instance and all property instances of colours readonly.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColourSet2D.Clone">
            <summary>
            This creates a shallow copy of this using the same instances for each
            of teh contained colours as this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.Background">
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.Foreground">
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.BackgroundSelected">
            <summary>Background colour of a selected cell.</summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.ForegroundSelected">
            <summary>Foreground colour of a selected cell.</summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.BackgroundPrimarySelection">
            <summary>Background colour of the primary selection. The primary selection is the cell that will open its
            editor if requeste e.g. pressing key F2. However, this colour will only used in those modes that allow
            secondary selections like row or column selection mode or multi-selection modes.</summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColourSet2D.ForegroundPrimarySelection">
            <summary>Foreground colour of the primary selection. The primary selection is the cell that will open its
            editor if requeste e.g. pressing key F2. However, this colour will only used in those modes that allow
            secondary selections like row or column selection mode or multi-selection modes.</summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="T:WX.GridCtrl.Extended.CellAttr">
            <summary>
            A pure .NET implementation of attributes that can be used to control the presentation of
            cells. for compatibility with standard grid editors and renderers, this 
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.#ctor">
            <summary>
            Provides an instace that does not have any data at all.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.#ctor(WX.GridCtrl.Extended.CellAttr)">
            <summary>
            Creates a copy of the argument.
            Please note, that this is a shallow copy. This will create a copy of the 
            ColourSet2D and ColourSet3D but using the same isntances for the colours
            (to prevent excessive use of handles for colours). Editor and renderer will
            also be the same in this instance and the soruce.
            </summary>
            <param name="src">The source of the copied data.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.SetStdColours2D">
            <summary>
            Assigns standard colours to property <c>Colours2D</c>
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if this is readonly.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.SetStdColours3D">
            <summary>
            Assigns standard colours to property <c>Colours3D</c>
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if this is readonly.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.ConvertToString(System.Object)">
            <summary>
            Converts the argument into a string using the <c>ToStringMethod()</c>.
            </summary>
            <param name="o">The object that will be converted into a string.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.ConvertToString(System.Object,System.Globalization.CultureInfo)">
            <summary>
            Converts the argument into a string using the <c>ToStringMethod()</c>.
            </summary>
            <param name="o">The object that will be converted into a string.</param>
            <param name="culture">The output will be relatively to this culture.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.CompleteArgByThis(WX.GridCtrl.Extended.CellAttr)">
            <summary>
            The result will have the proeprties of the argument. Undefined properties of the argument will
            be completed from this (if available). This method does the same as method <c>Merge</c> but accepts
            <c>null</c> as a representation of more specific arguments.
            </summary>
            <param name="moreSpecificAttributes">The more specific attributes that will be completed by <c>this</c>.
            The argument can be <c>null</c>. In that case, the result will be <c>this</c>.
            </param>
            <returns>The properties of the argument completed by <c>this</c>.</returns>
            <see cref="M:WX.GridCtrl.Extended.CellAttr.Merge(WX.GridCtrl.Extended.CellAttr)"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.Merge(WX.GridCtrl.Extended.CellAttr)">
            <summary>
            The result will have the properties of this instance. Attributes that are not defined
            by this instance will be completed from the argument (if available).
            Additional properties will be merged analogously.
            </summary>
            <param name="lessSpecificAttributes">An instance providing the properties that will be used
            to define properties of the result that are not defined by this instance.</param>
            <returns></returns>
            <see cref="M:WX.GridCtrl.Extended.CellAttr.CompleteArgByThis(WX.GridCtrl.Extended.CellAttr)"/>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.CellAttr.Clone">
            <summary>
            Creates a shallow copy of this instance referring to the same
            instances of wx.Colour, the same editor instance, and the same
            renderer as this.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Colours2D">
            <summary>
            Colours that will be used by renderers without 3D appearance. If this is <c>null</c>, this is not defined.
            The interpretation of undefined attributes is defined by the renderers.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Colours3D">
            <summary>
            Colours that will be used by renderers displaying data in 3D appearance. If this is <c>null</c>, this is not defined.
            The interpretation of undefined attributes is defined by the renderers.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Editor">
            <summary>
            Editor that shall be used to edit the cell. 
            If this is <c>null</c>, the cell cannot be edited.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Renderer">
            <summary>
            Renderer to display the cell.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.ToStringMethod">
            <summary>
            Method to convert values of the cell into a string. This will for instance be used by string renderers
            to display other kinds of objects.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Alignment">
            <summary>
            The alignment of the rendered cell content in the cell rectangle.
            The corresponding flags define the vertical as well as the horizontal alignment.
            The default alignment depends on the used renderer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.Font">
            <summary>
            The font that shall be used. Please note on writing renderers, that this can be <c>null</c>.
            In such cases use the font of the DC.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown by the setter if this is readonly.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.AdditionalProperties">
            <summary>
            Additional properties that might be used by some renderers.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.CellAttr.IsReadonly">
            <summary>
            True iff all modifiers return an System.InvalidOperation exception.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnOrRow">
            <summary>
            Descriptor of a column or a row.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRow.#ctor">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRow.#ctor(System.Type)">
            <summary>
            Creates an instance.
            </summary>
            <param name="typeConstraint">The grid will only assign values to this column or row where
            <c>System.Type,IsInstanceOf(typeConstraint)</c> is <c>true</c>.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRow.#ctor(System.String)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">Name of the column or row. This name can be used in collections of columns or rows
            to search for a particular column or row.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRow.#ctor(System.String,System.Type)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">Name of the column or row. This name can be used in collections of columns or rows
            to search for a particular column or row.</param>
            <param name="typeConstraint">The grid will only assign values to this column or row where
            <c>System.Type,IsInstanceOf(typeConstraint)</c> is <c>true</c>.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRow.MakeReadOnly">
            <summary>
            Makes this and the instances representing cell display properties as readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.Name">
            <summary>
            The name of the column. This is an empty string if undefined.
            This property cannot be set. It is defined by the constructor,
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.Index">
            <summary>
            The columns index. This will be set by the column collection.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.TypeConstraint">
            <summary>
            If not <c>null</c>, this property provides a type of all the values
            in the column or row. The grid will test this and assign only values
            where <c>System.Type,IsInstanceOf()</c> is <c>true</c>.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.CellAttrs">
            <summary>
            Attributes of the cells in the column.These attribtues will override the standard cell attributes
            as defined by the grid. These attributes may be overridden by row attributes and cell attibutes - that
            have been assigned in particular to the cell.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.IsFixed">
            <summary>
            Set this to <c>true</c> if the columns shall be fixed, i.e. the column will not be scrolled.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.IsVisible">
            <summary>
            Set this to <c>false</c> if the column shall be hidden.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRow.DisplayLabel">
            <summary>
            True if this column or row shall be displayed. The grid is free to draw a label even if this is
            false, e.g. to be able to draw error handles. But if this is true for one column or one row, all columns labels
            - or row labels respectively - will be shown.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnProperties">
            <summary>
            Descriptor of a column.
            A column defines cell attribtues for each cell of the column, an optional name, an index, and
            a title.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnProperties.#ctor">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnProperties.#ctor(System.Type)">
            <summary>
            Creates an instance.
            </summary>
            <param name="typeConstraint">The grid will only assign values to this column or row where
            <c>System.Type,IsInstanceOf(typeConstraint)</c> is <c>true</c>.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnProperties.#ctor(System.String)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">Name of the column. This name can be used in column collections
            to search for the column.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnProperties.#ctor(System.String,System.Type)">
            <summary>
            Creates an instance.
            </summary>
            <param name="name">Name of the column. This name can be used in column collections
            to search for the column.</param>
            <param name="typeConstraint">The grid will only assign values to this column or row where
            <c>System.Type,IsInstanceOf(typeConstraint)</c> is <c>true</c>.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnProperties.GridBand">
            <summary>
            The grid band is an optional caption of columns. If columns share the same gird band with their
            neighbours, the grid control shall display this name like a group of columns and provide the opportunity
            to disable and enable the whole group. Empty strings shall be ignored here.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "P:WX.GridCtrl.Extended.ColumnProperties.IndexGrouping" ignoriert -->
        <member name="P:WX.GridCtrl.Extended.ColumnProperties.MinWidth">
            <summary>
            Minimal width of this column. This is initially 10.
            Column widths can be determined according to the renderers of the contained cells - which means a large effort -
            or according to the properties associated with a column. This is a lower boundary of the column width.
            Even user input (dragging the column separator) cannot shrink the width of the column below this.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnProperties.MaxWidth">
            <summary>
            Maximal width of this column. This is initially the maximum integer.
            This is an upper boundary of  the column width.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.RowProperties">
            <summary>
            Properties defining how to present a row in the grid. These properties will override properties associated with
            the column or the grid as a whole.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.RowProperties.MinHeight">
            <summary>
            Minimal height of this row. This is initially 5.
            Rows can be determined according to the renderers of the contained cells - which means a large effort -
            or according to the properties associated with the row. This is a lower boundary of the row height.
            Even user input (dragging the column separator) cannot shrink the height of the row below this.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.RowProperties.MaxHeight">
            <summary>
            Maximal height of this row. This is initially the maximum integer.
            This is an upper boundary of  the row width.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnOrRowLayoutDescr">
             <summary>
            Constants defining how to layout the width of a column or the height if a row.
             </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowLayoutDescr.SizeByLabel">
            <summary>
            The size (width of a column or height of a row) will be determined
            by the size of the label. If the label is unknown or empty, this will
            use label "MMMMM".
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowLayoutDescr.SizeByFirstCell">
            <summary>
            All cells will have the same width (if this describes the layout of columns) or height
            (if this describes the layout of rows). This will be computed according to the
            best size of the FIRST cell at 0x0. This layout option can be computed very efficiently because
            only the properties of the first cell have to be inspected.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowLayoutDescr.SizeByFirstCellLabel">
            <summary>
            All cells will have the same width (if this describes the layout of columns) or height
            (if this describes the layout of rows). This will be computed according to the
            best size of the FIRST column's or row's label. This layout option can be computed very efficiently because
            only the properties of the first cell have to be inspected.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowLayoutDescr.SizeByMaxCellInRowOrColumn">
            <summary>
            If layouting columns, determine the width of a column according to the largest width of the label or
            a column value. Layout rows accordingly.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnOrRowCollection`1">
            <summary>
            A collection of columns or rows.
            You can create an instance describing a number of columns of default properties or
            you can add column descriptor by columns descriptor.
            
            This list notifies event listeners on changes on the number of rows or columns and properties defining
            their appearance.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowCollection`1.OnChanging">
            <summary>
            An event that will be fired before this instance will change.
            This event can be cancelled.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowCollection`1.OnChanged">
            <summary>
            An event that will be fired AFTER this instance has changed.
            This event cannot be cancelled.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.ColumnOrRowCollection`1.OnChangedCellAttr">
            <summary>
            This will be raised if the display attributes of either value cells, columns labels, or
            row labels changed.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.#ctor(System.Int32)">
            <summary>
            Creates a collection of the given number of columns or rows. These columns or rows
            do not have a name or caption - as long as you will not assign such properties -
            but they will have the default cell attributes of this collection.
            </summary>
            <param name="numberOfColumnsOrRows">Number of columns.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Add(System.Int32)">
            <summary>
            Adds specified number of additional columns or rows.
            </summary>
            <param name="numberOfAdditionalColumnsOrRows">Number of additional columns or rows.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.IndexOf(`0)">
            <summary>
            Returns the index of the argument or -1 if the argument does not belong
            to this collection.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Insert(System.Int32,`0)">
            <summary>
            Insert the item before the indicated position. If the index to define the desired position
            of the new item is smaller than 0, this will be equivalent to Add().
            </summary>
            <param name="index">Desired position of the new item.</param>
            <param name="item">The new item that shall be inserted.</param>
            <exception cref="T:System.ArgumentException">This will be raised if the item already has
            an index - because its already part of a collection.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">This will be thrown if the index is larger
            than the known number of elements.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Remove(System.String)">
            <summary>
            Removes the item of the given name if such an item exists.
            </summary>
            <param name="name">The name of the columns or rows to remove.</param>
            <returns>True iff an item has been removed.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Add(`0)">
            <summary>
            Adds a new column or row of the given properties.
            This collection will explicitely use the argument instance and set index 
            property of this instance. If this index property is already set, this method 
            will throw an exception.
            </summary>
            <param name="columnOrRow">The instance that will be used to describe in particular this column or row.</param>
            <exception cref="T:System.ArgumentException">This will be thrown if the argument has already been
            added to another collection of this class.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Contains(`0)">
            <summary>
            Returns true iff this contains the argument.
            </summary>
            <param name="item">The column or row that shall be searched.</param>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.LayoutDescr">
            <summary>
            Describing the layout that shall be used tocompute the width of a column or the height of
            a row.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.StdCellAttrs">
            <summary>
            Standard cell attributes that will be used for columns that have been 
            declared implicitely.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Item(System.Int32)">
            <summary>
            Get or set the description of a particular column or row. Please note, that the getter will usually
            return a read-only instance.
            </summary>
            <param name="index">The index of the requested column or row.</param>
            <returns></returns>
            <exception cref="!:System.ArgumentOutOfRange">This will be raised if the index is larger than or equals the
            number of columns or rows or the assigned value already has an index.</exception>
            <exception cref="T:System.ArgumentException">This will be thrown on assigning a value, if the value already 
            is a part of a collection.</exception>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Item(System.String)">
            <summary>
            Get a column or row identified by its name.
            </summary>
            <param name="name">The name of the column.</param>
            <returns>The contained column or row of the desired name if such an element exists, <c>null</c> otherwise.</returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.Count">
            <summary>
            The number of contained column or row descriptions.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeOperation">
            <summary>
            Represents an operation changing an instance of this type.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent">
            <summary>
            An event describing a change in a collection of rows or columns.
            Events of this type may be able to cancel the operation. Refer to the 
            documentation of the event propagating instances of this class.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.Cancel">
            <summary>
            Call this to request this event to cancel the represented operation.
            </summary>
            <returns>True if this allows for cancellation. False if this is not allowed and
            this request will be ignored.</returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.AllowsCancellation">
            <summary>
            Read this to find out whether this event allows handlers of this event to cancel
            the operation.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.IsCancelled">
            <summary>
            True iff this event has been requested to cancel the represented operation.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.Operation">
            <summary>
            Read this to find out which operation that will be used to change the collection of rows or columns.
            For instance the insertion of 12 rows at index 0 will return Operation.AddColumnOrRow here.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.StartIndex">
            <summary>
            Returns the index of teh first row or column that is affected by the represented change.
            For instance the insertion of 12 rows at index 0 will return 0 here.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.ColumnOrRowCollection`1.ChangeEvent.NumberOfAffectedItems">
            <summary>
            The number of items (rows or columns) that are affected by this change operation.
            For instance the insertion of 12 rows at index 0 will return 12 here.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.ColumnPropertiesCollection">
            <summary>
            A collection of columns.
            A grid model will expose a collection of this kind to define the columns of a grid.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnPropertiesCollection.#ctor(System.Int32)">
            <summary>
            Creates a collection of the given number of columns. These columns
            do not have a name or caption - as long as you will not assign such properties -
            but they will have the default cell attributes of this collection.
            </summary>
            <param name="numberOfColumnsOrRows">Number of columns.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.ColumnPropertiesCollection.#ctor">
            <summary>
            Creates an empty instance.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.RowPropertiesCollection">
            <summary>
            A collection of rows.
            A grid model will expose a collection of this kind to define the rows of a grid.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellLayoutSpecification">
            <summary>
            Instances of this class manage data on those cells spanning over
            more than one column or row.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.SetRowSpan(System.Drawing.Point,System.Int32)">
            <summary>
            Defines the row span of a certain cell, i.e. this cell is set to span over more
            than one row. If this cell also spans over more than one column, a full square
            of cells will be overlayed by this cell.
            </summary>
            <param name="cellCoord">The coordinates of the cell spanning over more than one row. X is the column index, Y is the row index.</param>
            <param name="rowspan">The cell spans over this number of rows.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Will be thrown if <c>rowspan</c> is smaller than 1.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.SetColumnAndRowSpan(System.Drawing.Point,System.Int32,System.Int32)">
            <summary>
            Defines row and column span of a certain cell in one step, i.e. this cell is set to span over more
            than one row and more than one column. A full square
            of cells will be overlayed by this cell.
            </summary>
            <param name="cellCoord">The coordinates of the cell. X is the column index, Y is the row index.</param>
            <param name="columnIndex">The column of the cell spanning over more than one row.</param>
            <param name="rowspan">The cell spans over this number of rows.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Will be thrown if <c>rowspan</c> is smaller than 1.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.SetColumnSpan(System.Drawing.Point,System.Int32)">
            <summary>
            Defines the colspan of a certain cell, i.e. this cell is set to span over more
            than one column. If this cell also spans over more than one row, a full square
            of cells will be overlayed by this cell.
            </summary>
            <param name="cellCoord">The coordinates of the cell spanning over more than one column. X is the column index, Y is the row index.</param>
            <param name="colspan">The cell spans over this number of columns.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Will be thrown if <c>colspan</c> is smaller than 1.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.OverlayedByThis(System.Drawing.Point)">
            <summary>
            Use this to find out whether a cell is visible or another cell spans over it.
            </summary>
            <param name="cellCoord">The cell that you want to know whether another cell spans over it or not.</param>
            <returns>The coordinates of the cell that spans over the argument or <c>null</c> if this cell is visible.
            </returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.GetCellSpan(System.Drawing.Point)">
            <summary>
            This cell spans over a number of columns according to the width
            of the result and a number of rows according to the height of the result.
            If the argument denotes a cell that spans over nothing in the neighbourhood,
            the result is 1x1.
            </summary>
            <param name="cellCoord">The cell that might span over others.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellLayoutSpecification.TopLeftCornerOfOverlappings(System.Drawing.Point)">
            <summary>
            Methode to compute the minimal rectangle containing the origin of all cells that
            are visible in another rectangle specified by the parameter list. This is usually
            simply the rectangle from the argument list. However, differences result from cell
            spanning over more than one row or column with coordinates outside the rectangle
            from the parameter list. Assume, that we have a rectangle specified by the top left corner
            (2 (columnn),2 (row)) in the parameter list. Assume furthermore, that cell (2,1) with row span
            2 and a cell (0,2) with column span 3. This will result into a rectangle specified by the
            top left corner (0,1) containing also the origins (2,1) and (0,2) of those cells spanning
            over cells in the visible region.
            </summary>
            <param name="topLeftCornerOfRectOfInterest">Top left corner of the visible rectangle.</param>
            <returns>The top left corner of the rectangle containing the visible cells and the origin of
            those cells spanning over visible cells.</returns>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellAttributesEvent">
            <summary>
            Grid models usually offer the opportunity to define the display properties of
            a grid cell by this event handlers. Handlers of this event shall be efficient
            regarding both, runtime and memory space, because they will be raised often.
            Handlers may set a new cell attribute here that will be used later on to draw
            the cell. But please keep in mind, that a grid model may define more than one
            handler of these events. The order in which these handlers will be used is undefined.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellAttributesEvent.#ctor(System.Drawing.Point,System.Object,WX.GridCtrl.Extended.CellAttr)">
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellAttributesEvent.SetAttributes(WX.GridCtrl.Extended.CellAttr)">
            <summary>
            This will define the new attributes that will be used to display the cell.
            </summary>
            <param name="attrs">The new attributes.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.CellCoord">
            <summary>
            The coordinates of the cell. X is the column index. Y is the row index.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.RowIndex">
            <summary>
            The index of the row.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.ColumnIndex">
            <summary>
            The index of the column.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.CellValue">
            <summary>
            The value of the cell.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.OriginalAttributes">
            <summary>
            The original attributes that are defined by column and row definitions.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttributesEvent.CurrentAttributes">
            <summary>
            The currently valid attributes of the cell. If none of the event handlers
            have set anything, this will equal the original attributes.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellAttributesEventHandler">
            <summary>
            Handler of the GridCellAttributesEvent.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="evt">The event.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.IGridModel">
            <summary>
            Data model of a grid.
            A grid model defines rows and columns to display and the associated data.
            Refer to class BaseGridModel implementing all stuff but the actually used data containers.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetEditor(System.Drawing.Point,WX.GridCtrl.Editors.GridCellEditor)">
            <summary>
            This is an opportunity for the grid model to define the grid cell editor of a particular cell
            dynamically. The grid will call this after deriving an editor from the column properties (as provided
            by this model), the row properties, or cell properties. However, this original editor can be <c>null</c>.
            This method may return a <c>null</c>. In that case, the gird control will use the editor as specified by
            the properties. Please note, that this method will be called before raiseing the OpeningEditorEvent.
            </summary>
            <param name="cellCoord">The coordinate of teh cell that shall be edited.</param>
            <param name="originalEditor">The editor as defined by column properties, row properties, or specific cell
            attributes.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.UpdateValues(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This will be called immediately before the grid reads values from the model
            for drawing. This method shall enable the model to create generated grid cell
            values en bloc immediately before the update of the display. The model can update
            grid cell values here and store them internally to be returned by method GetValue().
            The grid model will indicate the
            range of indices of required rows and columns. However, the grid model must not rely
            on this method. GetValue() shall always return up to date values whether this has been
            called in advance or not.
            </summary>
            <param name="maxColumnIndex">The maximal index of an affected column.</param>
            <param name="maxRowIndex">The maximal index of an affected row.</param>
            <param name="minColumnIndex">The minimal index of an affected column.</param>
            <param name="minRowIndex">The minimal index of an affected row.</param>
            <see cref="M:WX.GridCtrl.Extended.IGridModel.GetValue(System.Drawing.Point)"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetValue(System.Drawing.Point)">
            <summary>
            The value of a grid cell.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.SetValue(System.Drawing.Point,System.Object)">
            <summary>
            Assign a value to a cell. This will fire a <c>ValueChanged</c> event.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="value">The value that will be assigned to the cell.</param>
            <returns>True if this has been successful. False if this is wither not
            allowed or not implemented.</returns>
            <exception cref="T:System.ArgumentException">Throw an exception of this kind if the value
            does not fit into the cell. The message of this exception shall be a localized and
            informative text explaining the incompatibility.</exception>
            <seealso cref="!:ValueChanged"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetCellAttrs(System.Drawing.Point)">
            <summary>
            The display attribute directly associated to a grid cell.
            These attributes will overide the default attributes of the grid, the attributes
            associated with the column, and the attributes associated with the row.
            The result of this method shall reflect the values that have been set by
            SetCellAttrs().
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <see cref="M:WX.GridCtrl.Extended.IGridModel.SetCellAttrs(System.Drawing.Point,WX.GridCtrl.Extended.CellAttr)"/>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.SetCellAttrs(System.Drawing.Point,WX.GridCtrl.Extended.CellAttr)">
            <summary>
            Assigns display attributes to the cell. Please note, that the grid model also
            provides the opportunity to use the cell attribute event.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="attr">The attribute that will be assigned. This can be <c>null</c>.
            In that case, any cell specific attributes will be removed. All attributes
            of this cell will be read from the grid, the column, or the row properties.
            Please note, that this instance will be made readonly.
            </param>
            <returns>True if this has been successful. False if this is either not
            allowed or not implemented.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetRowLabel(System.Int32)">
            <summary>
            Returns the row label. This may be <c>null</c> if unknown or undefined.
            </summary>
            <param name="rowIndex">The index of the labelled row.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.SetRowLabel(System.Int32,System.String)">
            <summary>
            Sets the row label.
            </summary>
            <param name="rowIndex">The index of the labelled row.</param>
            <param name="newLabel">The new row label.</param>
            <returns>True if successful. False if either not allowed or not implemented.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetRowLabelAttrs(System.Int32)">
            <summary>
            These are the display properties to display the row label of the designated row.
            </summary>
            <param name="rowIndex">The labelled row.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetColumnLabel(System.Int32)">
            <summary>
            Returns  the column label. This may be <c>null</c> if unknown or undefined.
            </summary>
            <param name="columnIndex">The index of the labelled column.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.SetColumnLabel(System.Int32,System.String)">
            <summary>
            Sets the column label.
            </summary>
            <param name="columnIndex">The index of the labelled column.</param>
            <param name="newLabel">The new label.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.IGridModel.GetColumnLabelAttrs(System.Int32)">
            <summary>
            These are the display properties to display the column label of the designated column.
            </summary>
            <param name="columnIndex">The labelled column.</param>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.IGridModel.ColumnProperties">
            <summary>
            Collection of valid columns.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.IGridModel.RowProperties">
            <summary>
            Collection of valid rows.
            This collection does, in fact, rather hold the properties used to display rows
            but not the data.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.IGridModel.CellLayout">
            <summary>
            Opportunity to define that some grid cells span over others.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.IGridModel.OnValueChanged">
            <summary>
            This will be fired if one or more grid cell value changes.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.IGridModel.OnAttributesChanged">
            <summary>
            This will be raised if the attributes of value cells or label cells 
            change.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.IGridModel.DefaultLabelAttr">
            <summary>
            Gets or sets the default label attributes. The labels returned by GetRowLabel() and GetColumnLabel() shall be
            the attributes set by SetRowLabel() or SetColumnLabel() completed by these default attribute.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridEventAffectingSingleCell">
            <summary>
            A grid event affecting a single cell.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridEventAffectingSingleCell.CellCoord">
            <summary>
            The coordinates of the affected grid cell. X is the column index. Y is the row index.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridEventAffectingSingleCell.RowIndex">
            <summary>
            Change affects this row.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridEventAffectingSingleCell.ColumnIndex">
            <summary>
            Change affects a cell in this column.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellEditorEvent">
            <summary>
            Base class of the events on grid cell editors.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellEditorEvent.OriginalEditor">
            <summary>
            The original editor set by the column properties, the row properties, or by the grid,
            that has been passed to this event on creation. Some kinds of events allow handlers to
            set the editor. This is always the originally specified editor.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.OpeningEditorEvent">
            <summary>
            This will be raised before the grid control creates an editor.
            Handlers of this event can cancel this operation. Handlers of this
            event may also specify another editor that shall be used.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.OpeningEditorEvent.Veto">
            <summary>
            Event handlers can call this to veto the action. In that case, the grid cell editor will not open.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.OpeningEditorEvent.SetEditor(WX.GridCtrl.Editors.GridCellEditor)">
            <summary>
            Event handlers call this to define another editor to be used.
            please keep in mind, that only one handler can set an editor. If more than one editor
            tries to set an editor, this method will raise an exception.
            </summary>
            <param name="editor">The editor, that shall be used.</param>
            <exception cref="T:System.InvalidOperationException">This iwll be thrown if the editor has already been set
            by an event handler. Use <c>HasEditorBeenSetByEventHandler</c> to avoid this exception.</exception>
            <seealso cref="P:WX.GridCtrl.Extended.OpeningEditorEvent.HasEditorBeenSetByEventHandler"/>
        </member>
        <member name="P:WX.GridCtrl.Extended.OpeningEditorEvent.IsVetoed">
            <summary>
            True iff this operation has been vetoed by an event handler.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.OpeningEditorEvent.HasEditorBeenSetByEventHandler">
            <summary>
            This is true if the current editor has been set by an event handler.
            Please note, that resetting the editor will cause exceptions if this is true.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.OpeningEditorEvent.CurrentEditor">
            <summary>
            The editor that shall be used by the grid. Change this using SetEditor(). If <c>HasEditorBeenSetByEventHandler</c>.
            this is the editor that has been set by another event handler. Other´wise, this is the original event handler.
            </summary>
            <seealso cref="M:WX.GridCtrl.Extended.OpeningEditorEvent.SetEditor(WX.GridCtrl.Editors.GridCellEditor)"/>
            <seealso cref="P:WX.GridCtrl.Extended.OpeningEditorEvent.HasEditorBeenSetByEventHandler"/>
        </member>
        <member name="T:WX.GridCtrl.Extended.OpeningEditorEventHandler">
            <summary>
            Handler for the OpeningEditorEvent.
            </summary>
            <param name="sender">The sender of the event, typically a Grid.</param>
            <param name="evt">The event to handle.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.EditorOpenedEvent">
            <summary>
            This event will be raised by he grid if an editor has been opened.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.EditorOpenedEventHandler">
            <summary>
            Handler for the EditorOpenedEvent.
            </summary>
            <param name="sender">The sender of the event, typically a Grid.</param>
            <param name="evt">The event to handle.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.EditorClosedEvent">
            <summary>
            This event will be raised by he grid if an editor has been opened.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.EditorClosedEvent.#ctor(System.Drawing.Point,WX.GridCtrl.Editors.GridCellEditor,System.Object)">
            <summary>
            Creates an instance.
            </summary>
            <param name="cellCoord">the cell where the editor has been closed.</param>
            <param name="editor">The editor that has been closed.</param>
            <param name="newValue">The value that has been transferred from the editor into the grid model.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.EditorClosedEventHandler">
            <summary>
            Handler for the EditorClosedEvent.
            </summary>
            <param name="sender">The sender of the event, typically a Grid.</param>
            <param name="evt">The event to handle.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellSelectionEvent">
            <summary>
            Grid event on selection.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellSelectionEvent.#ctor(WX.GridCtrl.Extended.Grid,WX.GridCtrl.Extended.GridSelectionMode,System.Drawing.Point,System.Boolean)">
            <summary>
            Creates an instance.
            </summary>
            <param name="ctrl">The control that originally sent the event.</param>
            <param name="mode">The selection mode of the sending grid control at the time when the selection
            changed.</param>
            <param name="cell">The cell describing the region in the grid that changed its state w.r.t. selection.
            In cell selection mode (single- or multi-select), only the selection of this cell changed.
            In row selection mode (single- or multi-select), the row containing this cell changed its state,
            in column selection mode all cells in the column changed. If this event refers to a selection
            (the cells were unselected but are selected now), this cell is the new selected cell, that can
            open its editor.</param>
            <param name="stateChangedFromUnselectToSelect">True if the cells changed their state from unselected to selected. False if the
            cells became unselected.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellSelectionEvent.Mode">
            <summary>
            The selection mode of the sending grid control at the time when the selection
            changed.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellSelectionEvent.Control">
            <summary>
            The control that originally sent the event.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellSelectionEvent.Selected">
            <summary>
            True if the cells changed their state from unselected to selected. False if the
            cells became unselected.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellSelectionChangedEvent">
            <summary>
            An event that will be fired if the selection of cells changed in a Grid. The cells becoming selected
            or unselected are described by the coordinates of a single cell.
            In cell selection mode (single- or multi-select), only the selection of this cell changed.
            In row selection mode (single- or multi-select), the row containing this cell changed its state,
            in column selection mode all cells in the column changed. If this event refers to a selection
            (the cells were unselected but are selected now), this cell is the new selected cell, that can
            open its editor.
            </summary> 
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellSelectionChangedEvent.#ctor(WX.GridCtrl.Extended.Grid,WX.GridCtrl.Extended.GridSelectionMode,System.Drawing.Point,System.Boolean)">
            <summary>
            Creates an instance.
            </summary>
            <param name="ctrl">The control that originally sent the event.</param>
            <param name="mode">The selection mode of the sending grid control at the time when the selection
            changed.</param>
            <param name="cell">The cell describing the region in the grid that changed its state w.r.t. selection.
            In cell selection mode (single- or multi-select), only the selection of this cell changed.
            In row selection mode (single- or multi-select), the row containing this cell changed its state,
            in column selection mode all cells in the column changed. If this event refers to a selection
            (the cells were unselected but are selected now), this cell is the new selected cell, that can
            open its editor.</param>
            <param name="stateChangedFromUnselectToSelect">True if the cells changed their state from unselected to selected. False if the
            cells became unselected.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellSelectionChangedEventHandler">
            <summary>
            Type of the handlers of the GridCellSelectionChangedEvent.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="evt">The event that shall be handled.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellSelectionChangingEvent">
            <summary>
            An event that will be fired BEFORE the selection of cells change in a Grid. Event handler can veto
            this operation.
            
            The cells becoming selected
            or unselected are described by the coordinates of a single cell.
            In cell selection mode (single- or multi-select), only the selection of this cell changed.
            In row selection mode (single- or multi-select), the row containing this cell changed its state,
            in column selection mode all cells in the column changed. If this event refers to a selection
            (the cells were unselected but are selected now), this cell is the new selected cell, that can
            open its editor.
            </summary> 
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellSelectionChangingEvent.#ctor(WX.GridCtrl.Extended.Grid,WX.GridCtrl.Extended.GridSelectionMode,System.Drawing.Point,System.Boolean,System.Boolean)">
            <summary>
            Creates an instance.
            </summary>
            <param name="ctrl">The control that originally sent the event.</param>
            <param name="mode">The selection mode of the sending grid control at the time when the selection
            changed.</param>
            <param name="cell">The cell describing the region in the grid that changed its state w.r.t. selection.
            In cell selection mode (single- or multi-select), only the selection of this cell changed.
            In row selection mode (single- or multi-select), the row containing this cell changed its state,
            in column selection mode all cells in the column changed. If this event refers to a selection
            (the cells were unselected but are selected now), this cell is the new selected cell, that can
            open its editor.</param>
            <param name="canVeto">True if handlers of this event are allowed to veto the selection operation.</param>
            <param name="stateChangingFromUnselectToSelect">True if the cells are changing their state from unselected to selected. False if the
            cells are becoming unselected.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellSelectionChangingEvent.Veto">
            <summary>
            Event handlers call this method to indicate that the selection shall be cancelled.
            Returns true on successful operation. The result will be false, if not CanVeto().
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellSelectionChangingEvent.IsVetoed">
            <summary>
            True iff this event has been cancelled.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellSelectionChangingEvent.CanVeto">
            <summary>
            True if event handlers are allowed to veto the selection operation.
            </summary>
            <see cref="M:WX.GridCtrl.Extended.GridCellSelectionChangingEvent.Veto"/>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellSelectionChangingEventHandler">
            <summary>
            Type of the handlers of the GridCellSelectionChangingEvent.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="evt">The event that shall be handled.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellValueChange">
            <summary>
            Describes the change of a grid cell value.
            Instances will be sorted primarily with repect to rows and columns.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellValueChange.#ctor(System.Drawing.Point,System.Object,System.Object)">
            <summary>
            Creates an instance.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell changing its value. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="newValue">The new value. </param>
            <param name="oldValue">The old value that has been replaced.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellValueChange.OldValue">
            <summary>
            The old value that has been replaced.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellValueChange.NewValue">
            <summary>
            The new value that replaces the old value.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellValueChangedEvent">
            <summary>
            An event indicating changed values in a grid model.
            This event can be made readonly. This event may indicate more than
            one changed cell value.
            Grid models typically create this event, add eventually additional
            cell changes, make the event readonly and fire the event, so that
            it can be handled by event handlers.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellValueChangedEvent.#ctor(System.Drawing.Point,System.Object,System.Object)">
            <summary>
            Creates an instance.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell affected by this change. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="newValue">The new value. </param>
            <param name="oldValue">The old value that has been replaced.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellValueChangedEvent.Add(WX.GridCtrl.Extended.GridCellValueChange)">
            <summary>
            Adds the argument representing a change in a grid to the list of changes communicated by this event.
            </summary>
            <param name="change">The grid cell value change.</param>
            <exception cref="!:system.InvalidOperationException">This will be thrown if this instance
            is readonly.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellValueChangedEvent.MakeReadOnly">
            <summary>
            From this call, all calls to modifiers will cause exceptions.
            This shall return <c>this</c>.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellValueChangedEvent.IsReadonly">
            <summary>
            If this is true, all modifiers will cause exceptions. If this is false,
            modfiers can be used.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellValueChangedEventHandler">
            <summary>
            Type of event handlers for the grid cell changed event.
            </summary>
            <param name="sender">The grid model that changed.</param>
            <param name="evt">The event.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellAttrChangedEventMode">
            <summary>
            An enumeration describing the mode of a GridCellAttrChangedEvent.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.GridCellAttrChangedEventMode.ColumnLabel">
             <summary>
            The display attributes of some column label attributes changed.
            MinimalAffectedColumn and MaximalAffectedColumn describe the affected labels.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.GridCellAttrChangedEventMode.RowLabel">
             <summary>
             The display attributes of some row label attributes changed.
            MinimalAffectedRow and MaximalAffectedRow describe the affected labels.
             </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.GridCellAttrChangedEventMode.ValueCell">
             <summary>
             The display attributes of some value cell attributes changed. 
            MinimalAffectedColumn, MaximalAffectedColumn, MinimalAffectedRow, and MaximalAffectedRow describe
            a square of affected value cells.
             </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellAttrChangedEvent">
            <summary>
            This event indicates a change in the display attributes of label cells or value cells.
            Properties indicate, whether labels or values changed, the minimum and maximum column index
            of affected cells and the minumum and maximum affected row index of affected cells.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellAttrChangedEvent.#ctor(WX.GridCtrl.Extended.GridCellAttrChangedEventMode,System.Drawing.Point)">
            <summary>
            Creates an isntance affecting exactly one cell.
            </summary>
            <param name="mode">The mode of the event instance.</param>
            <param name="cellCoord">Designates the cell. X is the column index. Y is the row index.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.GridCellAttrChangedEvent.#ctor(WX.GridCtrl.Extended.GridCellAttrChangedEventMode,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance.
            </summary>
            <param name="mode">The mode of the event instance.</param>
            <param name="minCol">The minimal column index of an affected cell or label.</param>
            <param name="maxCol">The maximal column index of an affected cell or label.</param>
            <param name="minRow">The minimal row index of an affected cell or label.</param>
            <param name="maxRow">The maximal row index of an affected cell or label.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttrChangedEvent.Mode">
            <summary>
            Returns the mode of this event (whether row labels, column labels, or value cells are affected).
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttrChangedEvent.MinimalAffectedColumn">
            <summary>
            Minimal column index of an affected value cell or column label. This is -1 if unknown.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttrChangedEvent.MaximalAffectedColumn">
            <summary>
            Maximal column index of an affected value cell or column label. This is -1 if unknown.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttrChangedEvent.MinimalAffectedRow">
            <summary>
            Minimal column index of an affected value cell or row label. This is -1 if unknown.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.GridCellAttrChangedEvent.MaximalAffectedRow">
            <summary>
            Maximal row index of an affected value cell or row label. This is -1 if unknown.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.GridCellAttrChangedEventHandler">
            <summary>
            Type of event handlers for the grid cell attribute change event.
            </summary>
            <param name="sender">The grid model that changed.</param>
            <param name="evt">The event.</param>
        </member>
        <member name="T:WX.GridCtrl.Extended.BaseGridModel">
            <summary>
            Class implementing reusable methods managing column properties and row properties.
            You only have to implement GetValue() in order to get a valid and fully functional
            grid model.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.#ctor(WX.GridCtrl.Extended.BaseGridModel.Style,System.Int32,System.Int32)">
            <summary>
            Creates an instance.
            </summary>
            <param name="style"></param>
            <param name="noOfColumns">Number of initially valid columns. This should be the valid number
            </param>
            <param name="noOfRows"></param>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetEditor(System.Drawing.Point,WX.GridCtrl.Editors.GridCellEditor)">
            <summary>
            This is an opportunity for the grid model to define the grid cell editor of a particular cell
            dynamically. The grid will call this after deriving an editor from the column properties (as provided
            by this model), the row properties, or cell properties. However, this original editor can be <c>null</c>.
            This implementation of the method simply returns <c>null</c>. In that case, the gird control will use the editor as specified by
            the properties. Please note, that this method will be called before raiseing the OpeningEditorEvent.
            </summary>
            <param name="cellCoord">The coordinate of teh cell that shall be edited.</param>
            <param name="originalEditor">The editor as defined by column properties, row properties, or specific cell
            attributes.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.UpdateValues(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This method does nothing since this model does not expect extensive efforts to
            be spend on getting values. However, inheritors are free to override this.
            </summary>
            <remarks>
            This will be called immediately before the grid reads values from the model
            for drawing. This method shall enable the model to create generated grid cell
            values en bloc immediately before the update of the display. The model can update
            grid cell values here and store them internally to be returned by method GetValue().
            The grid model will indicate the
            range of indices of required rows and columns. However, the grid model must not rely
            on this method. GetValue() shall always return up to date values whether this has been
            called in advance or not.
            </remarks>
            <param name="maxColumnIndex">The maximal index of an affected column.</param>
            <param name="maxRowIndex">The maximal index of an affected row.</param>
            <param name="minColumnIndex">The minimal index of an affected column.</param>
            <param name="minRowIndex">The minimal index of an affected row.</param>
            <see cref="M:WX.GridCtrl.Extended.BaseGridModel.GetValue(System.Drawing.Point)"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetValue(System.Drawing.Point)">
            <summary>
            The value of a grid cell.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <c>rowIndex</c> or <c>columnIndex</c>
            is negative or equal to or larger than the number of rows or columns repectively.</exception>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetCellAttrs(System.Drawing.Point)">
            <summary>
            The display attribute directly associated to a grid cell.
            These attributes will overide the default attributes of the grid, the attributes
            associated with the column, and the attributes associated with the row.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.RunOnGetGridCellAttributes(System.Drawing.Point,WX.GridCtrl.Extended.CellAttr)">
            <summary>
            Runs the <c>OnGetGridCellAttributes</c> event.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="originalAttributes">The original attributes that would be set without running the events.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.RaiseGridCellValueChangedEvent(System.Drawing.Point,System.Object,System.Object)">
            <summary>
            This will raise the <c>ValueChanged</c> event with the provided arguments.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="newValue">The new value of the changed cell.</param>
            <param name="oldValue">The old value f the changed cell.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.SetValue(System.Drawing.Point,System.Object)">
            <summary>
            Assign a value to a cell. This will fire a <c>ValueChanged</c> event.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="value">The value that will be assigned to the cell.</param>
            <returns>True if this has been successful. False if this is wither not
            allowed or not implemented.</returns>
            <exception cref="T:System.ArgumentException">Throw an exception of this kind if the value
            does not fit into the cell. The message of this exception shall be a localized and
            informative text explaining the incompatibility.</exception>
            <exception cref="T:System.IndexOutOfRangeException">If <c>rowIndex</c> or <c>columnIndex</c>
            is negative or equal to or larger than the number of rows or columns repectively.
            However, this is not mandatory. Grid model may simply accept illegal indices.</exception>
            <seealso cref="!:ValueChanged"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetRowLabel(System.Int32)">
            <summary>
            Returns an object hat is the row label. This may be <c>null</c> if unknown or undefined.
            </summary>
            <param name="rowIndex">the index of the labelled row.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetRowLabelAttrs(System.Int32)">
            <summary>
            These are the display properties to display the row label of the designated row.
            </summary>
            <param name="rowIndex">The labelled row.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetColumnLabel(System.Int32)">
            <summary>
            Returns an object hat is the column label. This may be <c>null</c> if unknown or undefined.
            </summary>
            <param name="columnIndex">the index of the labelled column.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.GetColumnLabelAttrs(System.Int32)">
            <summary>
            These are the display properties to display the column label of the designated column.
            </summary>
            <param name="columnIndex">The labelled column.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.SetRowLabel(System.Int32,System.String)">
            <summary>
            Sets the row label.
            </summary>
            <param name="rowIndex">The index of the labelled row.</param>
            <param name="newLabel">The new row label.</param>
            <returns>True if successful. False if either not allowed or not implemented.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.SetColumnLabel(System.Int32,System.String)">
            <summary>
            Sets the column label.
            </summary>
            <param name="columnIndex">The index of the labelled column.</param>
            <param name="newLabel">The new label.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.BaseGridModel.RaiseOnCallLabelChanged(System.Drawing.Point,System.String,System.String)">
            <param name="newLabel">The new label. This is <c>null</c> if the label has been removed.</param>
            <param name="oldLabel">The old label. This is <c>null</c> if this label has been undefined in advance.</param>
            <see cref="E:WX.GridCtrl.Extended.BaseGridModel.OnLabelChanged"/>
        </member>
        <member name="P:WX.GridCtrl.Extended.BaseGridModel.ColumnProperties">
            <summary>
            Collection of valid columns.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.BaseGridModel.RowProperties">
            <summary>
            Collection of valid rows.
            This collection does, in fact, rather hold the properties used to display rows
            but not the data.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.BaseGridModel.CellLayout">
            <summary>
            Opportunity to define that some grid cells span over others.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.BaseGridModel.OnValueChanged">
            <summary>
            This will be fired if one or more grid cell value changes.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.BaseGridModel.OnAttributesChanged">
            <summary>
            This will be raised if the attributes of value cells or label cells 
            change. Please note, that this does not necessarily fire if attribute
            specifications returned by GridCellAttributesEventHandler change.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.BaseGridModel.OnGetGridCellAttributes">
            <summary>
            This event will be raised whenever this model will be asked for
            attributes to display a cell value. Handlers may change these attributes.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.BaseGridModel.DefaultLabelAttr">
            <summary>
            Gets or sets the default label attributes. The labels returned by GetRowLabel() and GetColumnLabel() shall be
            the attributes set by SetRowLabel() or SetColumnLabel() completed by these default attribute.
            </summary>
        </member>
        <member name="E:WX.GridCtrl.Extended.BaseGridModel.OnLabelChanged">
            <summary>
            The model fires this event if one or more of the labels changed.
            The coordinates of the change elements of the event will indicate which
            labels changed. If the row is -1, a column label is affected. If the column
            index is -1, a row label is affected.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.BaseGridModel.Style">
            <summary>
            Some style flags for the model.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.BaseGridModel.Style.StaticNumberOfColumns">
            <summary>
            The number of columns os fixed and cannot be changed. This is the default.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.BaseGridModel.Style.DynamicNumberOfColumns">
            <summary>
            The number of columns can change. Models using this style shall add 
            a handler of the ColumnPropertyCollection.OnChanging event.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.BaseGridModel.Style.StaticNumberOfRows">
            <summary>
            The number of rows os fixed and cannot be changed. This is the default.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.BaseGridModel.Style.DynamicNumberOfRows">
            <summary>
            The number of rows can change. Models using this style shall add 
            a handler of the RowPropertyCollection.OnChanging event.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.DefaultValueGenerator">
            <summary>
            Instances of this delegate can be used in a SparseGridModel to create default values
            that will be returned by the grid model for those cells, that do not contain stored
            values. This delegate shall be efficient and the function shall only depend on the
            arguments.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <returns></returns>
            <example>
            <code>
            SparseGridModel model=new SparseGridModel(100000, 100000);
            model.DefaultValueGenerator=delegate(Point cellCoord)
            {
                return cellCoord;
            };
            </code>
            </example>
        </member>
        <member name="T:WX.GridCtrl.Extended.SparseGridModel">
            <summary>
            A model for large but sparsely filled grd model.
            
            You may set labels. The default column labels will be the strings 'A' to 'Z' if
            the number of columns is smaller than 27, 'AA' to 'ZZ' if less than 677 columns
            are defined, 'AAA' to 'ZZZ' if 15677, and so on. The default row labels will be
            the running row index starting with 1.
            
            The number of rows and column can be changed dynamically.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.SparseGridModel.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an instance.
            </summary>
            <param name="initialNoOfColumns">Initial number of columns.</param>
            <param name="initialNoOfRows">Initial number of rows.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.SparseGridModel.#ctor(WX.GridCtrl.Extended.DefaultValueGenerator,System.Int32,System.Int32)">
            <summary>
            Creates an instance.
            </summary>
            <param name="defaultValueGenerator">Delegate to create default values that will be returned
            for those cells that do not contain a stored value (set by SetValue()).</param>
            <param name="initialNoOfColumns">Initial number of columns.</param>
            <param name="initialNoOfRows">Initial number of rows.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.SparseGridModel.GetValue(System.Drawing.Point)">
            <summary>
            The value of a grid cell.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <c>rowIndex</c> or <c>columnIndex</c>
            is negative or equal to or larger than the number of rows or columns repectively.</exception>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.SparseGridModel.SetValue(System.Drawing.Point,System.Object)">
            <summary>
            Assign a value to a cell.
            </summary>
            <param name="cellCoord">The coordinates of the grid cell. The X coordinate provides
            the column index, the Y coordinate is the row index.</param>
            <param name="value">The value that will be assigned to the cell.</param>
            <returns>True if this has been successful. False if this is either not
            allowed or not implemented.</returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.SparseGridModel.DefaultValueGenerator">
            <summary>
            Get or set the default value generator.
            Please note, that changing the default value generator will NOT raise value change events.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Grid">
            <summary>
            A native .NET implementation of a grid providing additional capabilities.
            
            
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid._indexTopLeftCell">
            <summary>
            Coordinates of the cell that will show up in the top left edge of the control.
            This will be used for scrolling.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid._selectedCell">
            <summary>
            The selected cell is the cell whose editor can be opened.
            In row selection mode, the whole row containing will be displayed selected.
            In column selection mode, the whole column will be selected.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid._multiselectedCells">
            <summary>
            Collection of additionally selected cells (used in multiselection mode).
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid._multiselectedRows">
            <summary>
            Collection of additionally selected rows (used in multiselection mode).
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid._multiselectedColumns">
            <summary>
            Collection of additionally selected rows (used in multiselection mode).
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>
            Creates an instance.
            </summary>
            <param name="parent">The parent control.</param>
            <param name="position">The position of the window. Use <c>wxDefaultPosition</c> if unknown.</param>
            <param name="size">The initial size of the window. Use <c>wxDefaultSize</c> if unknown.</param>
            <param name="styles">Styles of the control.</param>
            <remarks>
            Used styles:
            <list type="table">
            <term>WindowStyles.GRID_SELECT_CELLS</term><description>Selection mode: Select cells.</description>
            <term>WindowStyles.GridSelectRows</term><description>Selection mode: Select rows.</description>
            <term>WindowStyles.GRID_SELECT_COLUMNS</term><description>Selection mode: Select columns.</description>
            <term>WindowStyles.GRID_MULTISELECT</term><description>Allows multi-selection in ExtendedGrid. The effect depends on the selection mode as defined by the
            styles GRID_SELECT_CELLS, GridSelectRows, or GRID_SELECT_COLUMNS.</description>
            <term>WindowStyles.GRID_EXPAND_COLUMNS</term><description>Always resize columns in such a way that the full client size
            of the control gets filled. If the grid gets resized, the column width will grow or decrease
            according to the proportion of its width to the sum of the widths of all columns.</description>
            </list>
            This CTor will create a SparseGridModel.
            </remarks>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles)">
            <summary>
            Creates an instance.
            </summary>
            <param name="parent">The parent control.</param>
            <param name="id">A numeric ID of this control. Useful for searching.</param>
            <param name="position">The position of the window. Use <c>wxDefaultPosition</c> if unknown.</param>
            <param name="size">The initial size of the window. Use <c>wxDefaultSize</c> if unknown.</param>
            <param name="styles">Styles of hte control.</param>
            <remarks>
            Used styles:
            <list type="table">
            <term>WindowStyles.GRID_SELECT_CELLS</term><description>Selection mode: Select cells.</description>
            <term>WindowStyles.GridSelectRows</term><description>Selection mode: Select rows.</description>
            <term>WindowStyles.GRID_SELECT_COLUMNS</term><description>Selection mode: Select columns.</description>
            <term>WindowStyles.GRID_MULTISELECT</term><description>Allows multi-selection in ExtendedGrid. The effect depends on the selection mode as defined by the
            styles GRID_SELECT_CELLS, GridSelectRows, or GRID_SELECT_COLUMNS.</description>
            <term>WindowStyles.GRID_EXPAND_COLUMNS</term><description>Always resize columns in such a way that the full client size
            of the control gets filled. If the grid gets resized, the column width will grow or decrease
            according to the proportion of its width to the sum of the widths of all columns.</description>
            </list>
            Please note, that the grid will set <c>WindowStyles.FullRepaintOnResize</c> automatically. Thus,
            this style will have no effect if specified by the application.
            
            This CTor will create a SparseGridModel.
            </remarks>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.Scroll(System.Int32,WX.Orientation,System.Int32)">
            <summary>
            Conducts a scrolling including dialog refresh according to
            the provided ID of a scrolling event and orientation.
            </summary>
            <param name="eventType">The type of the scrolling event like Event.wxEVT_SCROLLWIN_TOP, Event.wxEVT_SCROLLWIN_BOTTOM, or Event.wxEVT_SCROLLWIN_LINEDOWN.</param>
            <param name="orient">Orientation</param>
            <param name="pos">Position. Used with event types Event.wxEVT_SCROLLWIN_THUMBRELEASE and Event.wxEVT_SCROLLWIN_THUMBTRACK</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.AddUpdateSelectionRegion(System.Collections.Generic.ICollection{System.Drawing.Rectangle},System.Drawing.Point,WX.GridCtrl.Extended.GridSelectionMode)">
            <summary>
            Adds update regions (in rectangles of cells) to the appropriate argument that shall
            be repainted in order to refresh the selection of the cell as described by the parameter list. 
            </summary>
            <param name="updateRegions">The update regions.</param>
            <param name="selectedCell">The selection that shall be refreshed.</param>
            <param name="selectionMode">The selection mode that shall be presupposed.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.RaiseSelectionChanging(System.Boolean,System.Drawing.Point)">
            <summary>
            This method raises the <c>OnSelectionChanging</c> event and returns
            whether this event has been vetoed by an event handler or not.
            </summary>
            <param name="canVeto">If true, the raised event can be vetoed.</param>
            <returns></returns>
            <see cref="F:WX.GridCtrl.Extended.Grid.OnSelectionChanging"/>
            <see cref="T:WX.GridCtrl.Extended.GridCellSelectionChangingEvent"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.RaiseSelectionChanged(System.Drawing.Point)">
            <summary>
            This will raise an <c>OnSelectionChanged</c> event.
            Call this after changing <c>_selectedCell</c>.
            </summary>
            <param name="originalSelection">The original selection</param>
            <see cref="F:WX.GridCtrl.Extended.Grid.OnSelectionChanged"/>
            <see cref="T:WX.GridCtrl.Extended.GridCellSelectionChangedEvent"/>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.MakeVisible(System.Drawing.Point)">
            <summary>
            Ensures, that a cell is visible.
            </summary>
            <param name="cell"></param>
            <returns>True if a Refresh() is necessary to make the effect visible. If this returns <c>true</c>,
            <c>Refresh()</c> has already been called at this window.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.AddSelection(System.Drawing.Point)">
            <summary>
            In multiselection modes, this method adds the selection that can be derived from the argument
            to the current selection, i.e. in multiselect row mode, this will add the row containing the
            cell from the argument list, in multiselect column mode, this will add the column, in multiselect
            cells mode, this will add the cell.
            The current selection will be stored. The selected cell will change to the argument.
            
            This operation is only available in a multiselect mode.
            </summary>
            <param name="cellCoord">The new part of the selection.</param>
            <exception cref="T:System.NotSupportedException">This grid is not in a multiselection mode.</exception>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.IsSelected(System.Drawing.Point)">
            <summary>
            Returns true if the cell designated by the argument is selected (either the selected cell
            or a cell selected additionally in row or column selection mode or in a multiselect mode.
            </summary>
            <param name="cellCoord">The coordinates of the cell that shall be investigated.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetSelectedCells">
            <summary>
            Returns a freshly allocated
            collection of selected cells (no side effects on removing or adding values).
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetPresentationMode(System.Drawing.Point)">
            <summary>
            Returns the presentation mode of the cell designated by the parameter.
            </summary>
            <param name="cellCoord">The cell whose presentation mode is required.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.ClientSizeGrid">
            <summary>
            Returns the size of that region in the client size of this window displaying the
            actual table - not labels or handles etc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetStartOfPage(System.Drawing.Point)">
            <summary>
            This returns the start (top left coordinate) of the page that
            ends with the specified bottom right cell.
            This will compute the layout.
            </summary>
            <param name="bottomRightOfThisPage">Coordinates of the bottom right cell of the desired page.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetIndexBottomRightCell">
            <summary>
            Returns the indices of the bottom right cell of the current page.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetSizeOfCurrentPage">
            <summary>
            Size of the current page in no. of columns (X) and no. of rows (Y).
            This will compute the layout.
            </summary>
            <returns></returns>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.OnSelectionChanging">
            <summary>
            This will be raised before changing the selection of a cell (even if using the property setter).
            Handlers are allowed to cancel the operation.
            </summary>
            <seealso cref="P:WX.GridCtrl.Extended.Grid.SelectedCell"/>
            <seealso cref="M:WX.GridCtrl.Extended.Grid.AddSelection(System.Drawing.Point)"/>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.OnSelectionChanged">
            <summary>
            This will be raised after the selection of cells in the grid has been changed (even if using the
            property setter).
            </summary>
            <seealso cref="P:WX.GridCtrl.Extended.Grid.SelectedCell"/>
            <seealso cref="M:WX.GridCtrl.Extended.Grid.AddSelection(System.Drawing.Point)"/>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.OnOpeningEditor">
            <summary>
            Raised before opening a grid cell editor. Handlers may veto the operation or set
            another editor.
            </summary>
            <see cref="M:WX.GridCtrl.Extended.Grid.GetCellEditor"/>
            <seealso cref="F:WX.GridCtrl.Extended.Grid.OnEditorOpened"/>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.OnEditorOpened">
            <summary>
            Raised immediately after opening an editor on a cell.
            </summary>
            <see cref="M:WX.GridCtrl.Extended.Grid.ShowCellEditor"/>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.OnEditorClosed">
            <summary>
            Raised after closing a grid cell editor.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetCellEditor">
            <summary>
            Returns the grid cell editor associated with the currently valid primary selection.
            If this editor is undefined, the result will be <c>null</c>.
            This will raise an <c>OnOpeningEditor</c> event. If one of the handlers of this event
            defines another editor to be used, this editor will be the result of this method.
            If one ofthe handlers cancelled the operation, the result of this method will be <c>null</c>.
            This will do nothing but returning <c>null</c> if this is read-only.
            </summary>
            <seealso cref="P:WX.GridCtrl.Extended.Grid.SelectedCell"/>
            <seealso cref="F:WX.GridCtrl.Extended.Grid.OnOpeningEditor"/>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.ShowCellEditor">
            <summary>
            Finds an editor to edit the current primary selection and shows it.
            Returns true on success. the result will be false if GetCellEditor fails
            to find an appropriate editor or the editor is already shown.
            </summary>
            <seealso cref="M:WX.GridCtrl.Extended.Grid.GetCellEditor"/>
            <returns>True on success. False if readonly, undefined editor, cancelled operation.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetCellAttributes(System.Drawing.Point)">
            <summary>
            Returns the attributes to desplay the cell designated by the provided row and column indices.
            This method defines how to merge column attributes, row attributes, and cell attributes.
            </summary>
            <param name="rowIndex">Row index of the cell to be displayed.</param>
            <param name="columnIndex">Column index of the cell to be displayed.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.OnPaintHandler(System.Object,WX.Event)">
            <summary>
            Handler of the drawing event. This will create a PaintDC and call OnDraw.
            </summary>
            <param name="sender"></param>
            <param name="evt"></param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.OnDrawHandler(WX.DC)">
            <summary>
            Draws the grid.
            </summary>
            <param name="dc">The device context that will show the grid.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.OffsetForLabels(WX.DC,System.Int32@,System.Int32@)">
            <summary>
            Assigns the extent of the column labels and the row labels to the arguments.
            </summary>
            <param name="labelXOffset">Gets the width of the row labels in pixels assigned. 0 if row labels invisible.</param>
            <param name="labelYOffset">Gets the height of the column labels in pixels assigned. 0 if column labels invisible.</param>
            <param name="dc">The device context that is used to draw this control.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.Draw(WX.DC,System.Collections.Generic.ICollection{System.Drawing.Rectangle})">
            <summary>
            Draw the grid onto the provided context.
            </summary>
            <param name="dc">The grid will be drawn on this context.</param>
            <param name="updateCellRegions">If not empty, describes the grid cells that shall be repainted refreshing the device context.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.HitTest(WX.MouseEvent)">
            <summary>
            Returns the coordinates of the cell that has been hit by the provided mouse event.
            If this position is not related
            to a grid cell, the result will be <c>wxDefaultPosition</c>. If the Y position is -1 but the X position
            is larger than or equal to 0, the result represent a column label. If the X position is -1 but the Y
            position is larger than or equal to 0, the result is a row label.
            </summary>
            <param name="evt">The mouse event that shall be analysed.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.GetCellRectangle(System.Drawing.Point)">
            <summary>
            Returns the rectangle that the cell  asspecified by the
            coordinates (X is column index, Y is row index) occupies on
            the current display. Cells that are currently not visible
            return an empty rectangle here.
            </summary>
            <param name="cellCoord">The cell.</param>
            <returns></returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.HitTest(WX.DC,System.Drawing.Point)">
            <summary>
            Returns the grid coordinates of the cell that has been drawn into the provided DC at the logical
            position in the client area that is provided by the parameters. If this position is not related
            to a grid cell, the result will be <c>wxDefaultPosition</c>. If the Y position is -1 but the X position
            is larger than or equal to 0, the result represent a column label. If the X position is -1 but the Y
            position is larger than or equal to 0, the result is a row label.
            </summary>
            <param name="logicalPosition">Logical position in the provided device context.</param>
            <param name="dc">The device context where the grid has been drawn to.</param>
            <returns></returns>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.HideRowLabels">
            <summary>
            Get or set whether row labels are hidden. You can specify the initial value of this property with
            style flag WindowStyles.GRID_HIDE_ROW_LABELS.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.HideColumnLabels">
            <summary>
            Get or set whether row labels are hidden. You can specify the initial value of this property with
            style flag WindowStyles.GRID_HIDE_COLUMN_LABELS.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.LabelsAreFixed">
            <summary>
            Get or set a value indicating whether the row and column labels will be displayed in fixed positions if not
            hidden. If this is true, the user only scrolls data cells. Labels will be displayed without regarding the 
            scroll position.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.SelectionMode">
            <summary>
            Get or set the selection mode.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.IsMultiselect">
            <summary>
            Get or set whether this is in multiselect mode or not. If you assign a value
            to this property, the <c>SelectionMode</c> will change. If the previous selection
            mode selects individual cells, the new selection mode will also select individual
            cells. If the previous selection selected columns or rows, the new selection mode
            will also select columns or rows respectively.
            </summary>
            <remarks>
            Is you assign a value to this flag, the selection mode will change according to the
            table below. If this is false but you assign true, the value in the left column
            will be replaced by the value in the right column. If this is true and you assign
            false, the right value will be replaced by the left value.
            <list type="table">
            <listheader><term>IsMultiselect is false</term><description>IsMultiselect is true</description></listheader>
            <item><term>GridSelectionMode.Cell</term><description>GridSelectionMode.MultiselectCells</description></item>
            <item><term>GridSelectionMode.Row</term><description>GridSelectionMode.MultiselectRows</description></item>
            <item><term>GridSelectionMode.Column</term><description>GridSelectionMode.MultiselectColumns</description></item>
            </list>
            </remarks>
            <seealso cref="P:WX.GridCtrl.Extended.Grid.SelectionMode"/>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.TopLeftCellIndex">
            <summary>
            This is the index of the cell visible in the top left corner of the client size.
            Use this if you need to have information on the visible cells. In multiselection modes,
            all selections without direct reference to the selected cell will get lost.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.SelectedCell">
            <summary>
            The currently selected cell. In all selection modes this property will have 
            the coordinates of that cell as value, that is allowed to show up the editor
            if required. In row selection mode, the whole row containing this cell will
            be displayed as selection. In column mode, the whole column containing this
            cell will be displayed as selection. In multiselection mode, all previous 
            selections will get lost.
            
            The setter will make the new selection visible.
            </summary>
            <seealso cref="M:WX.GridCtrl.Extended.Grid.MakeVisible(System.Drawing.Point)"/>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.IsReadOnly">
            <summary>
            Get or set whether this grid is for reading only.
            Readonly grids do not open editors.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.Data">
            <summary>
            The data presented by this control.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.DefaultLabelAttrs">
            <summary>
            Default attributes of label cells. These attributes MUST implement all properties. They will be used to
            complete missing properties in more specific attribute sets returned by the data model.
            Please note, that row span and column span properties will be ignored when drawing the labels.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.DefaultValueCellAttrs">
            <summary>
            Default attributes of value cells. These attributes MUST implement all properties. They will be used to
            complete missing properties in more specific attribute sets returned by the data model. Row span and
            column span will be normalized to 1 on setting this value.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.BorderPen">
            <summary>
            Pen that will be used to draw the border between cells.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.BorderPenFixedWidth">
            <summary>
            Pen that will be used to draw borderlines between fixed and scrollable columns.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Grid.CellLayoutCollection">
            <summary>
            Can be created in two modes "Column" or "Row".
            Returns in column mode width, left boundary, and right boundary of a cell.
            Returns in row mode height, upper boundary, and lower boundary of a cell.
            
            All selectors and modifiers will be named with respect to column mode, i.e.
            width rather than height, left boundary instead of upper boundary
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Grid.CellLayoutCollection._maxLabelHeight">
            <summary>
            In column mode the maximal height of a column label.
            In row mode the maximal width of a row label.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.#ctor(WX.GridCtrl.Extended.Grid.ColumnOrRow)">
            <summary>
            Creates an instance.
            </summary>
            <param name="mode">Defines whether this defines column widhts or row heights.</param>
            <param name="dc">The graphics device that will be used for drawing. Please note, that
            this instance may reuse results that have been created using a different context.</param>
            <param name="data">This will be used to derive column or row properties and labels or values.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.InvalidateLayout">
            <summary>
            Invalidates the layout. <c>BoundariesInRange</c> will recompute
            the layout if this has been called.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.ComputeLayout(WX.Window,WX.GridCtrl.Extended.IGridModel,WX.GridCtrl.Extended.CellAttr,WX.GridCtrl.Extended.CellAttr)">
            <summary>
            Set up all internal caches to represent a layout for the presentation of
            the provided data on the provided device context.
            </summary>
            <param name="win">The window that will paint the grid.</param>
            <param name="data">the data that will be presented.</param>
            <param name="defaultLabelAttrs">Default attributes of labels. These attributes will be used
            if the layout refers to the size of label cells to complete cell attribtes read from the model.</param>
            <param name="defaultValueCellAttrs">Default attributes of value cells. These attributes will be used
            if the layout refers to the size of value cells to complete cell attribtes read from the model.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.ComputeLayout(WX.DC,WX.GridCtrl.Extended.IGridModel,WX.GridCtrl.Extended.CellAttr,WX.GridCtrl.Extended.CellAttr)">
            <summary>
            Set up all internal caches to represent a layout for the presentation of
            the provided data on the provided device context.
            </summary>
            <param name="dc">The device context that will be used for presentation.</param>
            <param name="data">the data that will be presented.</param>
            <param name="defaultLabelAttrs">Default attributes of labels. These attributes will be used
            if the layout refers to the size of label cells to complete cell attribtes read from the model.</param>
            <param name="defaultValueCellAttrs">Default attributes of value cells. These attributes will be used
            if the layout refers to the size of value cells to complete cell attribtes read from the model.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.BoundariesInIndexRange(System.Int32,System.Int32)">
            <summary>
            Returns an array of boundaries between cells overlapping with the coordinates
            of the arguments.
            </summary>
            <param name="minColumnIndex">Minimal column index that will be considered.
            In row mode this is the minimal row index.</param>
            <param name="maxColumnIndex">Maximal column index that will be considered.
            In row mode this is the maximal row index.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.BoundariesInRange(System.Int32,System.Int32)">
            <summary>
            Returns an array of boundaries between cells overlapping with the coordinates
            of the arguments.
            </summary>
            <param name="leftEdgeOfClippingRegion">Left edge of the clipping region. Cells
            placed completely left to this edge will not appear in the result.</param>
            <param name="widthOfClippingRegion">The width of the clipping region. Add this width
            to the left edge of the clipping region to get the right edge of the clipping region.
            Cells placed completely right to the right edge of the clipping region will not appear
            in the result. -1 will be normalized to the number of columns (or rows in row mode).
            </param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Grid.CellLayoutCollection.BoundariesInRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns an array of boundaries between cells overlapping with the coordinates
            of the arguments.
            </summary>
            <param name="leftEdgeOfClippingRegion">Left edge of the clipping region. Cells
            placed completely left to this edge will not appear in the result. -1 will be
            normalized to 0.</param>
            <param name="widthOfClippingRegion">The width of the clipping region. Add this width
            to the left edge of the clipping region to get the right edge of the clipping region.
            Cells placed completely right to the right edge of the clipping region will not appear
            in the result. -1 will be normalized to the number of columns (or rows in row mode).
            </param>
            <param name="minColumnIndex">Minimal column index that will be considered.
            In row mode this is the minimal row index. -1 will be ignored.</param>
            <param name="maxColumnIndex">Maximal column index that will be considered.
            In row mode this is the maximal row index. -1 will be ignored.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.CellLayoutCollection.Width">
            <summary>
            Width of the table. 
            Use this method to find out how many pixels are required to display all columns.
            However, if this is in row mode, this will return the numbe of pixels required
            to display all rows (the height of the table). If the layout is invalid, this will
            be -1.
            </summary>
        </member>
        <member name="P:WX.GridCtrl.Extended.Grid.CellLayoutCollection.Height">
            <summary>
            In column mode the maximal height of a column label.
            In row mode the maximal width of a row label.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Grid.CellLayoutCollection.LayoutInfo">
            <summary>
            Returns boundaries of cells. 2 Proeprties: The boundaries in x direction
            if called for columns and in y direction if called for rows, plus the index
            of the starting cell. If called for columns, this is the index of the column,
            where the first Boundary is the left boundary. If calles for rows, this is the
            index of the row where the upper boundary is Boundary[0].
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Renderers.Border">
            <summary>
            Informs the grid about the colour sets and basic effects of the renderer.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Renderers.Border.GridBorder">
            <summary>
            Renderers of this kind require the grid to draw the border between cells.
            The border will NOT be part of the best cell size returned by the renderer.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Renderers.Border.RendererDrawsBorder">
            <summary>
            Renderers of this kind will draw the border between cells on their own. The
            size required by this border will be part of the best cell size returned
            by the renderer. Renderers using the ColourSet3D for a 3 dimensional button
            effect. Such buttons usually do not have a border. The shadow/highlight effect
            separates them.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Renderers.PresentationMode">
            <summary>
            Enumeration of options for the presentation of cells.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Renderers.PresentationMode.None">
            <summary>
            Standard form of presentation.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Renderers.PresentationMode.Selected">
            <summary>
            This is a selected cell.
            </summary>
        </member>
        <member name="F:WX.GridCtrl.Extended.Renderers.PresentationMode.PrimarySelection">
            <summary>
            This is a primary selection. This is used in multiselection modes or in column and row selection modes to
            draw that cell that will open its editor.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Renderers.IRenderer">
            <summary>
            Base class of renderers that fit exclusively to the extended grid.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.IRenderer.GetBestSize(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Computes and returns the size that is desired to render the given object
            using the specified cell attributes. The grid may ask to draw the cell into a
            smaller rectangle but usually the grid will turn on scrolling to provide at
            least this size for drawing.
            </summary>
            <param name="attr">The attributes that shall be used to render the object.</param>
            <param name="dataObject">The data object that shall be rendered.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
            <returns>Returns the smallest size that ensures with Draw() a full display of the cell data.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.IRenderer.GetErrorHandleHitregion(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode)">
            <summary>
            Assume, that Draw() rendered a cell using the provided attributes on the provided device context
            presenting the provided data object. This method shall return the smallest rectangle containing
            the error handle. This is required for hit tests - e.g. to trigger the display of a tool tip
            presentign an error message. the result must, of course, be contained in argument <c>rect</c>.
            </summary>
            <param name="attr">The attributes that shall be used to render the object.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be rendered.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <returns>The smallest rectangle containing the error handle.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.IRenderer.Draw(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode,System.Globalization.CultureInfo)">
            <summary>
            Implementations of this method draw a cell of an extended grid containing
            the provided data within the specified rectangle.
            </summary>
            <param name="attr">The attributes that shall be used to display the cell.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be displayed.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.Renderers.IRenderer.BorderlineBetweenCells">
            <summary>
            Specifies which kind of border shall be painted by the grid control to separate
            cells.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Renderers.Standard2DRenderer">
            <summary>
            A renderer displaying a string representation of a grid cell value in 2 dimensional manner using background
            colour for the cell background and foreground colour for the text.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard2DRenderer.#ctor">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard2DRenderer.GetBestSize(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Object,System.Globalization.CultureInfo)">
            <summary>
            The text extend of the string representation of the data value +2 pixel in height and width.
            </summary>
            <param name="attr">The attributes that shall be used to render the object.</param>
            <param name="dataObject">The data object that shall be rendered.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard2DRenderer.GetErrorHandleHitregion(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode)">
            <summary>
            Assume, that Draw() rendered a cell using the provided attributes on the provided device context
            presenting the provided data object. This method shall return the smallest rectangle containing
            the error handle. This is required for hit tests - e.g. to trigger the display of a tool tip
            presentign an error message. the result must, of course, be contained in argument <c>rect</c>.
            </summary>
            <param name="attr">The attributes that shall be used to render the object.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be rendered.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <returns>The smallest rectangle containing the error handle.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard2DRenderer.Draw(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode,System.Globalization.CultureInfo)">
            <summary>
            Implementations of this method draw a cell of an extended grid containing
            the provided data within the specified rectangle.
            </summary>
            <param name="attr">The attributes that shall be used to display the cell.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be displayed.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.Renderers.Standard2DRenderer.BorderlineBetweenCells">
            <summary>
            This renderer requires the grid to draw a border between the cells.
            </summary>
        </member>
        <member name="T:WX.GridCtrl.Extended.Renderers.Standard3DRenderer">
            <summary>
            This renderer will display strings as labels of a button using the ColourSet3D colour set of the
            cell attribute (providing colours for shadow and highlight). Unselected cells will be display like
            a raised button. Selected cells will be displayed like a pressed button.
            
            This is the standard renderer for labels.
            </summary>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard3DRenderer.GetBestSize(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Object,System.Globalization.CultureInfo)">
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard3DRenderer.GetErrorHandleHitregion(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode)">
            <summary>
            Assume, that Draw() rendered a cell using the provided attributes on the provided device context
            presenting the provided data object. This method shall return the smallest rectangle containing
            the error handle. This is required for hit tests - e.g. to trigger the display of a tool tip
            presentign an error message. the result must, of course, be contained in argument <c>rect</c>.
            </summary>
            <param name="attr">The attributes that shall be used to render the object.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be rendered.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <returns>The smallest rectangle containing the error handle.</returns>
        </member>
        <member name="M:WX.GridCtrl.Extended.Renderers.Standard3DRenderer.Draw(WX.GridCtrl.Extended.CellAttr,WX.DC,System.Drawing.Rectangle,System.Object,WX.GridCtrl.Extended.Renderers.PresentationMode,System.Globalization.CultureInfo)">
            <summary>
            Implementations of this method draw a cell of an extended grid containing
            the provided data within the specified rectangle.
            </summary>
            <param name="attr">The attributes that shall be used to display the cell.</param>
            <param name="dc">The graphics device context that shall be used for drawing.</param>
            <param name="rect">The rectangle that shall be used to render the cell. This might be smaller than
            the best size.</param>
            <param name="dataObject">The data object that shall be displayed.</param>
            <param name="mode">Specifies the presentation mode, e.g. whether this cell is selected or not.</param>
            <param name="ci">The culture that shall be used for string conversion if necessary.</param>
        </member>
        <member name="P:WX.GridCtrl.Extended.Renderers.Standard3DRenderer.BorderlineBetweenCells">
            <summary>
            This renderer draws the border between cells on his own. 
            In fact, a border is not required to separate cells. The highlight and
            shadow effects outline the cell.
            </summary>
        </member>
        <member name="P:WX.StaticLine.IsVertical">
            <summary>
            True if the line is vertical, false if horizontal.
            </summary>
        </member>
        <member name="P:WX.StaticLine.DefaultSize">
            <summary>
            This static function returns the size which will be given to the smaller dimension of the static line,
            i.e. its height for a horizontal line or its width for a vertical one.
            </summary>
        </member>
        <member name="T:WX.SashLayoutWindow">
             <summary>
             SashLayoutWindow responds to <c>OnCalculateLayout</c> events generated by LayoutAlgorithm.
             It allows the application to use simple accessors to specify how the window should be laid out,
             rather than having to respond to events. The fact that the class derives from SashWindow allows
             sashes to be used if required, to allow the windows to be user-resizable.
            
             The documentation for LayoutAlgorithm explains the purpose of this class in more detail.
             </summary>
             <remarks>
             \image html sashwindow.png
             </remarks>
        </member>
        <member name="M:WX.SashLayoutWindow.SetDefaultSize(System.Drawing.Size)">
            <summary>
            Sets the default dimensions of the window.
            The dimension other than the orientation will be fixed to this value, and the orientation
            dimension will be ignored and the window stretched to fit the available space.
            </summary>
        </member>
        <member name="P:WX.SashLayoutWindow.Alignment">
            <summary>
            The alignment of the window.
            </summary>
        </member>
        <member name="P:WX.SashLayoutWindow.Orientation">
            <summary>
            The orientation  of the window.
            </summary>
        </member>
        <member name="T:WX.LayoutAlgorithm">
             <summary>
             LayoutAlgorithm implements layout of subwindows in MDI or SDI frames. It sends a CalculateLayoutEvent
             event to children of the frame, asking them for information about their size. For MDI parent frames, the
             algorithm allocates the remaining space to the MDI client window (which contains the MDI child frames).
             For SDI (normal) frames, a 'main' window is specified as taking up the remaining space.
             </summary>
             <remarks>
             Because the event system is used, this technique can be applied to any windows, which are not necessarily
             'aware' of the layout classes (no virtual functions in wxWindow refer to wxLayoutAlgorithm or its events).
             However, you may wish to use wxSashLayoutWindow for your subwindows since this class provides handlers for
             the required events, and accessors to specify the desired size of the window. The sash behaviour in the base
             class can be used, optionally, to make the windows user-resizable.
            
             LayoutAlgorithm is typically used in IDE (integrated development environment) applications, where there are
             several resizable windows in addition to the MDI client window, or other primary editing window. Resizable
             windows might include toolbars, a project window, and a window for displaying error and warning messages.
            
             When a window receives an OnCalculateLayout event, it should call SetRect in the given event object, to be the
             old supplied rectangle minus whatever space the window takes up. It should also set its own size accordingly. 
             SashLayoutWindow::OnCalculateLayout generates an OnQueryLayoutInfo event which it sends to itself to determine
             the orientation, alignment and size of the window, which it gets from internal member variables set by the application.
            
             The algorithm works by starting off with a rectangle equal to the whole frame client area. It iterates through
             the frame children, generating OnCalculateLayout events which subtract the window size and return the remaining 
             rectangle for the next window to process. It is assumed (by SashLayoutWindow.OnCalculateLayout) that a window
             stretches the full dimension of the frame client, according to the orientation it specifies. For example, a
             horizontal window will stretch the full width of the remaining portion of the frame client area. In the other
             orientation, the window will be fixed to whatever size was specified by OnQueryLayoutInfo. An alignment setting
             will make the window 'stick' to the left, top, right or bottom of the remaining client area. This scheme implies
             that order of window creation is important. Say you wish to have an extra toolbar at the top of the frame, a
             project window to the left of the MDI client window, and an output window above the status bar. You should therefore
             create the windows in this order: toolbar, output window, project window. This ensures that the toolbar and output
             window take up space at the top and bottom, and then the remaining height in-between is used for the project window.
             
             LayoutAlgorithm is quite independent of the way in which OnCalculateLayout chooses to interpret a window's size
             and alignment. Therefore you could implement a different window class with a new OnCalculateLayout event handler,
             that has a more sophisticated way of laying out the windows. It might allow specification of whether stretching
             occurs in the specified orientation, for example, rather than always assuming stretching. (This could, and probably
             should, be added to the existing implementation).
            
             \par Note
             LayoutAlgorithm has nothing to do with LayoutConstraints. It is an alternative way of specifying layouts for which
             the normal constraint system is unsuitable.
             </remarks>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            Will ask you to <c>_("Choose a file")</c>.
            </summary>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String,System.String,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String,System.String,System.String,System.String,WX.WindowStyles)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,System.String,System.String,System.String,System.String,WX.WindowStyles,System.Drawing.Point)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="pos">The position of this dialog</param>
        </member>
        <member name="M:WX.FileDialog.#ctor(WX.Window,WX.wxString,WX.wxString,WX.wxString,WX.wxString,WX.WindowStyles,System.Int32,System.Int32)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.</summary>
        </member>
        <member name="M:WX.FileDialog.ShowModal">
            <summary>
            This will show the dialog, wait for an input and return ShowModalResult.Ok on successful userinput.
            On cancelled input, the result will be ShowModalResult.CANCEL.
            Read <c>Filename</c> or <c>Filenames</c> for the results.
            </summary>
        </member>
        <member name="P:WX.FileDialog.Directory">
            <summary>
            The directory where the files have been selected.
            </summary>
        </member>
        <member name="P:WX.FileDialog.Filename">
            <summary>
            Returns the file that has been selected without directory.
            </summary>
        </member>
        <member name="P:WX.FileDialog.Path">
            <summary>
            Returns the path that has been selected - directory and filename.
            </summary>
        </member>
        <member name="P:WX.FileDialog.Paths">
            <summary>
            Returns the paths that have been selected - directory and filename.
            </summary>
        </member>
        <member name="P:WX.FileDialog.Filenames">
            <summary>
            Returns an array of the selected filenames (without directory).
            </summary>
        </member>
        <member name="T:WX.ConfigStyle">
            <summary>Style flags for the wx.Config class.
            </summary>
        </member>
        <member name="F:WX.ConfigStyle.USE_Default_STYLE">
            <summary>This will read and store the configuration from and to the default location.
            If  wxWidgets has been compiled with <c>wxUSE_CONFIG_NATIVE</c>, this is usually
            the registry (using <c>wxRegConfig</c>).</summary>
        </member>
        <member name="F:WX.ConfigStyle.USE_LOCAL_FILE">
            <summary>
            Use this to use a local file (within the home of the user) rather than a global file or HKCU rather than HKLM 
            in the registry base of Windows. This may be specified in conjunction with USE_GLOBAL_FILE. In that case,
            the configuration class will search for locally defined values first and consider the global file or HKLM if
            the local configuration does not define the value.
            </summary>
        </member>
        <member name="F:WX.ConfigStyle.USE_GLOBAL_FILE">
            <summary>
            Use this to use a global file rather than a local file (within the home of the user) or HKLM rather than HKCU 
            in the registry base of Windows. This may be specified in conjunction with USE_LOCAL_FILE. In that case,
            the configuration class will search for locally defined values first and consider the global file or HKLM if
            the local configuration does not define the value. However, the configuration will always be saved locally.
            This implementation does not provide any means to write global configurations.
            </summary>
        </member>
        <member name="F:WX.ConfigStyle.USE_RELATIVE_PATH">
            <summary>Only relevant if using a file for reading/writing the configuration.
            </summary>
        </member>
        <member name="F:WX.ConfigStyle.USE_NO_ESCAPE_CHARACTERS">
            <summary>This will turn off character escaping for the values of entries stored in the config file.
            For example a foo key with some backslash characters will be stored as <c>foo=C:\mydir</c> instead
            of the usual storage of <c>foo=C:\\mydir</c>. For <c>wxRegConfig</c>, this flag refers to HKLM,
            and provides read-only access.
            The <c>USE_NO_ESCAPE_CHARACTERS</c> style can be helpful if your config file must be read or
            written to by a non-wxWidgets program (which might not understand the escape characters).
            Note, however, that if <c>USE_NO_ESCAPE_CHARACTERS</c> style is used, it is is now your
            application's responsibility to ensure that there is no newline or other illegal
            characters in a value, before writing that value to the file.
            </summary>
        </member>
        <member name="T:WX.XmlSerializer">
            <summary>Service class that implements serialization of colours and fonts into XML.</summary><remarks>
                 * Create an instance encapsulating a font or a colour to serialize or call ReadXml()
                 * to deserialize. Example:
                 * \code
                 // This writes a font before writing a colour into an xmlWriter.
                 XmlSerializer serializer=new XmlSerializer(font);
                 serializer.WriteXml(xmlWriter);
                 serializer.Colour=colour;
                 serializer.WriteXml(xmlWriter);
                 
                 // this reads a colour after a font from an xmlReader.
                 serializer.ReadXml(xmlReader);
                 font=serializer.Font;
                 serializer.ReadXml(xmlReader);
                 colour=serializer.Colour;
                 \endcode
                 * </remarks>
        </member>
        <member name="M:WX.XmlSerializer.#ctor">
            <summary>Creates an instance without data.
            Serialization will be a NOP.</summary>
        </member>
        <member name="M:WX.XmlSerializer.#ctor(WX.Font)">
            <summary>Creates an instance referring to a font for serialization.</summary>
        </member>
        <member name="M:WX.XmlSerializer.#ctor(WX.Colour)">
            <summary>Creates an instance referring to a colour for serialization.</summary>
        </member>
        <member name="M:WX.XmlSerializer.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:WX.XmlSerializer.ReadXml(System.Xml.XmlReader)">
            <summary>This will either read a colour or a font from <c>reader</c> and provide the result as <c>Colour</c> or <c>Font</c>.
            If <c>reader</c> does not provide an appropriate serialization, then <c>Colour</c> and <c>Font</c> will be <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.XmlSerializer.WriteXml(System.Xml.XmlWriter)">
            <summary>Writes the data to <c>writer</c>.
            The data may either be a colour or a font that has been set by the CTor
            or assignment to an appropriate property. Data <c>null</c> will cause this to be
            a NOP.
            </summary>
        </member>
        <member name="P:WX.XmlSerializer.Font">
            <summary>Gets or sets a font as data.
            Use this property to retrieve a font that has been read by ReadXml()
            or to set a font to be written by WriteXml().</summary>
        </member>
        <member name="P:WX.XmlSerializer.Colour">
            <summary>Gets or sets a colour as data.
            Use this property to retrieve a Colour that has been read by ReadXml()
            or to set a font to be written by WriteXml().</summary>
        </member>
        <member name="T:WX.Config">
            <summary>This is the class for writing and reading configuration parameters via wxWidgets <c>wxConfigBase</c> implementations.
            
             The idea of  wxWidgets configuration class is to provide an interface that allows
             applications to manage configuration data without regard to the method of storing the
             information. Configurations may either be stored in a global or local file, or into the
             registry database. The syntax of the files is according to the good old Ini-files as
             common to 16-Bit Windows.
             
             This class only maintains (writes to) user specific configurations.
             </summary>
             <remarks>
             This interface might be extended in the future to provide some additional styles that
             implement the standard way of configuring .NET applications (XML file <c>myApp.exe.config</c> for
             application <c>myApp.exe</c> read by class System.Configuration.Configuration).
             
             Although <c>wxConfig</c> is not derived from <c>wxObject</c>, this class is derived from wx.Object since
             the main concern of wx.Object is to manage pointers to C++ objects.
             Use Config.Get() to get an instance.
             
             The original C++ implementation uses Method <c>Read</c> with many, many signatures. Since this may lead to
             some confusion (at least I have been confused on using this class), this class implements <c>Read</c>
             functionality in two flavours: Returning the value or a default as method result and loading a
             reference with the value from the configuration if this has been found. Methods of the first flavour
             still are called <c>Read</c> whereas methods of the second flavour contain the data type as part of their name
             like wx.Config.ReadInt(). 
             
             In the past, both flavours were named simply <c>Read</c>. Hence, programmers that missed to use the small
             C# keyword <c>ref</c> accidentally turned an intended call of flavour 2 into one of flavour 1.
             
             A few things have been added to this class going beyond the functions in  wxWidgets: WriteProperties()
             and ReadProperties() will write and read public properties and fields using reflection.
             
             \b Problems:
             There is some evidence that reading strings for non-existing keys using a default value
             might lead to memory corruption at least in some cases.
            </remarks>
        </member>
        <member name="M:WX.Config.#ctor(System.String,System.String,System.String,System.String,WX.ConfigStyle)">
            <summary>Use this CTor and call Set() to create a configuration of a particular style.</summary>
            <param name="appName"> The application name. If this is empty, the class will normally use
                   wx.App.GetAppName to set it. The application name is used in the registry key on
                   Windows, and can be used to deduce the local filename parameter if that is missing.
                   </param>
            <param name="vendorName"> The vendor name. If this is empty, it is assumed that no vendor name is
                   wanted, if this is optional for the current config class. The vendor name is
                   appended to the application name for <c>wxRegConfig</c>.
                   </param>
            <param name="localName"> Some config classes require a local filename. If this is not
                   present, but required, the application's name will be used instead.
                   </param>
            <param name="globalName"> Some config classes require a global filename. If this is not
                   present, but required, the application's name will be used instead.
                   </param>
            <param name="style"> Can be one of <c>USE_LOCAL_FILE</c> and <c>USE_GLOBAL_FILE</c>. The style interpretation
                   depends on the config class and is ignored by some. For <c>wxFileConfig</c>, these
                   styles determine whether a local or global config file is created or used. If
                   the flag is present but the parameter is empty, the parameter will be set to a
                   default. If the parameter is present but the style flag not, the relevant flag
                   will be added to the style. For wxFileConfig you can also add <c>USE_RELATIVE_PATH</c>
                   by logically or'ing it to either of the _FILE options to tell <c>wxFileConfig</c> to
                   use relative instead of absolute paths. For <c>wxFileConfig</c>, you can also add
                   USE_NO_ESCAPE_CHARACTERS which will turn off character escaping for the values
                   of entries stored in the config file.</param>
        </member>
        <member name="M:WX.Config.Set(WX.Config)">
            <summary>This method will set the argument as the current configuration returning the old instance of Config that has been the current configuration before calling this.</summary>
        </member>
        <member name="M:WX.Config.Set(WX.ConfigStyle)">
            <summary>
            Creates a new configuration using the provided style and returns the result. The new configuration
            will be the default instance returned by Get().
            </summary>
            <param name="style">A style describing the new instance.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Config.Get(System.Boolean)">
            <summary>This will get the current configuration of the application.
            If the argument is <c>true</c>, this method will wx.Config.Create() a new configuration
            is required.</summary>
        </member>
        <member name="M:WX.Config.Get">
            <summary>Equivalent to wx.Config.Get(true).</summary>
        </member>
        <member name="M:WX.Config.Create">
            <summary>Create a new configuration according to properties of the application.
            On Windows, the configuration will preferably recorded in the registry database
            within the <c>HKEY_CURRENT_USER</c> section using the vendor's name and the application's name
            to create subkeys. However, this depends on whether <c>wxUSE_CONFIG_NATIVE</c> has been defined
            on compiling  wxWidgets or not. In most other cases, this will use a file of the application
            name in the current working directory. Refer also to wx.App.AppName and wx.App.VendorName.</summary>
        </member>
        <member name="M:WX.Config.GetFirstGroup(System.String@,System.Int32@)">
            <summary>
            Gets the first group in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first group.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:WX.Config.GetEnumeratorOfGroups"/>
        </member>
        <member name="M:WX.Config.GetNextGroup(System.String@,System.Int32@)">
            <summary>
            Gets the next group in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the next group.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:WX.Config.GetEnumeratorOfGroups"/>
        </member>
        <member name="M:WX.Config.GetEnumeratorOfGroups">
            <summary>
            Returns an enumerator of all groups.
            </summary>
            <seealso cref="M:WX.Config.GetFirstGroup(System.String@,System.Int32@)"/>
            <seealso cref="M:WX.Config.GetNextGroup(System.String@,System.Int32@)"/>
        </member>
        <member name="M:WX.Config.GetEnumerableGroups">
            <summary>
            Returns an enumerable collection of all contained groups.
            You may use this in <c>foreach</c> loops.
            Please keep care on the <c>Path</c>. The path shall always be the same
            on moving to the next entry.
            </summary>
        </member>
        <member name="M:WX.Config.GetFirstEntry(System.String@,System.Int32@)">
            <summary>
            Gets the first entry in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first entry.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:WX.Config.GetEnumeratorOfEntries"/>
        </member>
        <member name="M:WX.Config.GetNextEntry(System.String@,System.Int32@)">
            <summary>
            Gets the next entry in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first entry.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:WX.Config.GetEnumeratorOfEntries"/>
        </member>
        <member name="M:WX.Config.GetEnumeratorOfEntries">
            <summary>
            Returns an enumerator of all entries.
            </summary>
            <seealso cref="M:WX.Config.GetFirstEntry(System.String@,System.Int32@)"/>
            <seealso cref="M:WX.Config.GetNextEntry(System.String@,System.Int32@)"/>
        </member>
        <member name="M:WX.Config.GetEnumerableEntries">
            <summary>
            Returns an enumerable collection of all contained groups.
            You may use this in <c>foreach</c> loops.
            Please keep care on the <c>Path</c>. The path shall always be the same
            on moving to the next entry.
            </summary>
        </member>
        <member name="M:WX.Config.Exists(System.String)">
            <summary>
            returns true if either a group or an entry with a given name exists
            </summary>
            <param name="strName">name of an entry or a group</param>
        </member>
        <member name="M:WX.Config.ReadString(System.String,System.String@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="str">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadString(System.String,System.String@,System.String)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="str">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadInt(System.String,System.Int32@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="pl">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadInt(System.String,System.Int32@,System.Int32)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="pl">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadDouble(System.String,System.Double@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadDouble(System.String,System.Double@,System.Double)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadBool(System.String,System.Boolean@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadBool(System.String,System.Boolean@,System.Boolean)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadFont(System.String,WX.Font@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadFont(System.String,WX.Font@,WX.Font)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadColour(System.String,WX.Colour@,WX.Colour)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:WX.Config.ReadSize(System.String,System.Drawing.Size@)">
            <summary>
            Reads a size from this configuration using the specified key. The result is true on success.
            On success, the read value will be assigned to <c>val</c>. Otherwise, <c>val</c> will remain
            unchanged.
            </summary>
            <param name="key">The key that will be used to read the size</param>
            <param name="val">The reference that will be used to return the result on success</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:WX.Config.ReadPoint(System.String,System.Drawing.Point@)">
            <summary>
            Reads a point from this configuration using the specified key. The result is true on success.
            On success, the read value will be assigned to <c>val</c>. Otherwise, <c>val</c> will remain
            unchanged.
            </summary>
            <param name="key">The key that will be used to read the size</param>
            <param name="val">The reference that will be used to return the result on success</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:WX.Config.Write(System.String,System.Xml.Serialization.IXmlSerializable)">
            <summary>This will write a serializable object identified by <c>key</c>.
            </summary>
        </member>
        <member name="M:WX.Config.Flush">
            <summary>
            permanently writes all changes (otherwise, they're only written from object's destructor)
            </summary>
        </member>
        <member name="M:WX.Config.Flush(System.Boolean)">
            <summary>
            permanently writes all changes (otherwise, they're only written from object's destructor)
            </summary>
        </member>
        <member name="M:WX.Config.DeleteEntry(System.String)">
            <summary>
            Deletes the specified entry and the group it
            belongs to if it was the last key in it.
            </summary>
            <param name="key">The key of the entry to delete</param>
        </member>
        <member name="M:WX.Config.DeleteEntry(System.String,System.Boolean)">
            <summary>
            Deletes the specified entry and the group it
            belongs to if it was the last key in it and the second parameter is true.
            </summary>
            <param name="key">The key of the entry to delete</param>
            <param name="bDeleteGroupIfEmpty">If true the whole group will be deleted if this deleted the last entry</param>
        </member>
        <member name="M:WX.Config.DeleteGroup(System.String)">
            <summary>
            Delete the group (with all subgroups). If the current path is under the group being deleted it is changed to
            its deepest still existing component. E.g. if the current path is /A/B/C/D and the group C is deleted the
            path becomes /A/B.
            </summary>
            <param name="key">Designator of the group to be deleted</param>
        </member>
        <member name="M:WX.Config.DeleteAll">
            <summary>
            Delete the whole underlying object (disk file, registry key, ...). Primarly for use by uninstallation routine.
            </summary>
        </member>
        <member name="M:WX.Config.WithEnvVarsExpanded(System.String)">
            <summary>This is the equivalent to <c>wxConfig</c>::EnvVarsExpanded().
             This has to be renamed since <c>EnvVarsExpanded</c> is required as name of the property
             for automatic expansion.
            </summary>
        </member>
        <member name="P:WX.Config.ExpandEnvVars">
            <summary>This read/write property defines automatic expansion of environment variables.
             Use WithEnvVarsExpanded() to read a string with expanded environment variables.
            </summary>
        </member>
        <member name="P:WX.Config.RecordDefaults">
            <summary>
            If true, all default values provided with Read() actions will be recorded.
            </summary>
        </member>
        <member name="P:WX.Config.AppName">
            <summary>
            The name of the application.
            </summary>
        </member>
        <member name="P:WX.Config.VendorName">
            <summary>
            The name of the vendor.
            </summary>
        </member>
        <member name="P:WX.Config.Style">
            <summary>
            The style that has been used. You may also change this.
            </summary>
        </member>
        <member name="P:WX.Config.Path">
            <summary>
            Get or set the current path in the configuration:
            On reading the path: Path information is always absolute on reading.
            On setting the path:
            if the first character is '/', it is the absolute path, otherwise it is a relative path. '..' is supported. If strPath doesn't exist it is created.
            </summary>
        </member>
        <member name="T:WX.Config.EntryType">
            <summary>An enumeration representing the data type of an atomic field.
            </summary>
        </member>
        <member name="M:WX.ColourDialog.ShowModal">
            Modal display of the dialog. Returns whether input has been confirmed or cancelled.
        </member>
        <member name="T:WX.CalendarPeriod">
            <summary>An enumeration representing periods within a calendar.
            Refer to Calendar.DaysInPeriod().</summary>
        </member>
        <member name="T:WX.Calendar">
            <summary>Assigns name and attributes to special days.
            These will be displayed in calendar controls if set to the appropriate property.
            
            Add styles to the calendar and asign them to days.
            
            You may either extend this by subclassing or providing event handlers.</summary>
        </member>
        <member name="M:WX.Calendar.DaysInPeriod(System.DateTime,WX.CalendarPeriod,System.DateTime,System.DateTime)">
            <summary>This returns a list of days with a distance referring to <c>repreat</c> to day \ reference within a period of days.
            Example 1: Reference 1st of July 2008 and <c>repeat</c> <c>CalendarPeriod.Monthly</c> within the period starting with the 2nd
            May 2008 ranging to the 2nd Aug. 2008 will return the following <c>DateTime</c> instances: 1st of June, 1st of July,
            1st of August. 
            
            Example 2: The parameters from example 1 but with reference 1st of Jan. 2008 will result into the same result.
            
            Example 3: The parameters from example 1 but with period 2nd of July to 31th of July will result into an empty list.</summary>
        </member>
        <member name="M:WX.Calendar.#ctor">
            <summary>Creates an empty calendar info.
            You may assign this to a calendar control.</summary>
        </member>
        <member name="M:WX.Calendar.LinkToControl(WX.CalendarCtrl)">
            <summary>Adds new listener on selecitons to the argument and returns the used event listener.</summary>
        </member>
        <member name="M:WX.Calendar.AddHoliday(System.DateTime,System.String)">
            <summary>Defines <c>day</c> to be a holiday of the provided <c>name</c>.
            </summary>
        </member>
        <member name="M:WX.Calendar.AddHoliday(System.DateTime)">
            <summary>Defines <c>day</c> to be a holiday.</summary>
        </member>
        <member name="M:WX.Calendar.AddHoliday(System.DateTime,WX.CalendarPeriod)">
            <summary>Defines <c>day</c> to be a holiday that will automatically be repeated periodically.</summary>
        </member>
        <member name="M:WX.Calendar.AddHoliday(System.DateTime,WX.CalendarPeriod,System.String)">
            <summary>Defines <c>day</c> to be a holiday of the provided name that will automatically be repeated periodically.</summary>
        </member>
        <member name="E:WX.Calendar.OnRequestFormat">
            <summary>Called on requesting the format of a particular day.</summary>
        </member>
        <member name="T:WX.Calendar.RequestFormatEventArgs">
            <summary>Argument of a <c>OnRequestFormat</c> event.
            This provides the <c>Day</c> whose presentation format is requested.
            Implementors may set <c>Name</c> and/or <c>Attr</c> that shall be used for presentation.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.CalendarCtrl" ignoriert -->
        <member name="M:WX.CalendarCtrl.GetAttr(System.Int32)">
            <summary>Gets the attributes of the provided day in month (1..31).</summary>
        </member>
        <member name="M:WX.CalendarCtrl.SetAttr(System.Int32,WX.CalendarDateAttr)">
            <summary>Sets the attributes of the provided day in month (1..31).</summary>
        </member>
        <member name="M:WX.CalendarCtrl.SetHoliday(System.Int32)">
            <summary>Declares the designated day in month (1..31) to be a holiday.</summary>
        </member>
        <member name="M:WX.CalendarCtrl.ResetAttr(System.Int32)">
            <summary>Resets the attributes of the designated day in month (1..31) to be a holiday.</summary>
        </member>
        <member name="P:WX.CalendarCtrl.SpecialDays">
            <summary>Returns the current definition of special days and holidays if present.
            Assigning a new calendar to this control will immediately highlight the specified special days
            like holidays etc. So, fill the Calendar first and then assign it to the control.</summary>
        </member>
        <member name="E:WX.CalendarCtrl.OnChangedDate">
            <summary>This will be called on setting <c>Date</c>.
            </summary>
        </member>
        <member name="P:WX.CalendarCtrl.Date">
            <summary>Get or set the currently selected date.
            You may use <c>OnSetDate</c> to be informed of changing this value,</summary>
        </member>
        <member name="T:WX.CalendarDateAttr">
            <summary>Defines the manner that particular days will be presented in CalendarCtrl.</summary>
        </member>
        <member name="T:WX.CalendarEvent">
            <summary>The wx.CalendarEvent class is used together with wx.CalendarCtrl.
            \image html calendar.png "The improved calender control."</summary>
        </member>
        <member name="T:WX.SplitterWindow">
             <summary>
             This class manages up to two subwindows.
             The current view can be split into two programmatically (perhaps from a menu command), and unsplit either 
             programmatically or via the wx.SplitterWindow user interface.
             </summary>
             <remarks>
             The following screenshot shows the appearance of a splitter window with a horizontal split.
            
             \image html splitter.png
             
             The style wx.WindowStyles.Splitter3D has been used to show a 3D border and 3D sash.
             </remarks>
        </member>
        <member name="M:WX.SplitterWindow.SplitHorizontally(WX.Window,WX.Window)">
            <summary>
            Initializes the top and bottom panes of the splitter window.
            The child windows are shown if they are currently hidden.
            
            Initially, the sash divides the control into two halfs.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.SplitHorizontally(WX.Window,WX.Window,System.Int32)">
            <summary>
            Initializes the top and bottom panes of the splitter window.
            The child windows are shown if they are currently hidden.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <param name="sashPos">The initial position of the sash. If this value is positive,
            it specifies the size of the top pane. If it is negative, it is absolute value gives the
            size of the bottom pane. Finally, specify 0 (default) to choose the default position
            (half of the total window width). </param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.SplitVertically(WX.Window,WX.Window)">
            <summary>
            Initializes the left and right panes of the splitter window.
            The child windows are shown if they are currently hidden.
            
            Sash divides the pane initially in the half.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.SplitVertically(WX.Window,WX.Window,System.Int32)">
            <summary>
            Initializes the left and right panes of the splitter window.
            The child windows are shown if they are currently hidden.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <param name="sashPos">The initial position of the sash. If this value is positive,
            it specifies the size of the left pane. If it is negative, it is absolute value gives the
            size of the right pane. Finally, specify 0 (default) to choose the default position
            (half of the total window width). </param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.Unsplit">
            <summary>
            Unsplits the window.
            This call will not actually delete the pane being removed; it calls OnUnsplit() which can be overridden
            for the desired behaviour. By default, the pane being removed is hidden.
            
            This will remove the right or bottom pane.
            </summary>
            <returns>true if successful, false otherwise (the window was not split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.Unsplit(WX.Window)">
            <summary>
            Unsplits the window.
            This call will not actually delete the pane being removed; it calls OnUnsplit() which can be overridden
            for the desired behaviour. By default, the pane being removed is hidden.
            </summary>
            <param name="toRemove">The pane to remove, or <c>null</c> to remove the right or bottom pane.</param>
            <returns>true if successful, false otherwise (the window was not split).</returns>
        </member>
        <member name="M:WX.SplitterWindow.SetSashPosition(System.Int32,System.Boolean)">
            <summary>
            Set the sash position.
            </summary>
            <see cref="M:wx.SplitterWindow.SashPosition"/>
        </member>
        <member name="P:WX.SplitterWindow.IsSplit">
            <summary>
            True iff the control is currently split.
            this shall be tested before using SplitHorizontally() or SplitVertically().
            </summary>
        </member>
        <member name="P:WX.SplitterWindow.SashPosition">
            <summary>
            Get or set the sash position.
            </summary>
        </member>
        <member name="P:WX.SplitterWindow.MinimumPaneSize">
            <summary>
            Gets or sets the minimum pane size.
            The default minimum pane size is zero, which means that either pane can be reduced to zero by
            dragging the sash, thus removing one of the panes. To prevent this behaviour
            (and veto out-of-range sash dragging), set a minimum size, for example 20 pixels.
            If the wxSP_PERMIT_UNSPLIT style is used when a splitter window is created, the
            window may be unsplit even if minimum size is non-zero.
            </summary>
        </member>
        <member name="P:WX.Pen.ThePenList">
            <summary>This is the synonym to wx.PenList.ThePenList.</summary>
        </member>
        <member name="P:WX.Pen.Colour">
            <summary>
            The colour of the pen. This will return exactly the instance that will be used
            in the brush.
            </summary>
        </member>
        <member name="T:WX.Pen.Styles">
            <summary>Styles for pens.</summary>
        </member>
        <member name="T:WX.MouseEvent">
            <summary>
            
            </summary>
        </member>
        <member name="M:WX.MouseEvent.ButtonDown">
            <summary>If the argument is omitted, this returns true if the event was a mouse button down event.
            Otherwise the argument specifies which button-down event was generated (see Button for the possible values).</summary>
        </member>
        <member name="M:WX.MouseEvent.ButtonDown(WX.MouseButton)">
            <summary>Returns true if the event was a mouse button down event.
            The argument specifies which button-down event was generated (see Button for the possible values).</summary>
        </member>
        <member name="M:WX.MouseEvent.LogicalPosition(WX.DC)">
            <summary>Returns the logical mouse position in pixels
            (i.e. translated according to the translation set for the DC, which usually indicates that the
            window has been scrolled).</summary>
        </member>
        <member name="P:WX.MouseEvent.IsButton">
            <summary>Returns true if the event was a mouse button event
            (not necessarily a button down event - that may be tested using ButtonDown).</summary>
        </member>
        <member name="P:WX.MouseEvent.Position">
            <summary>Returns the physical mouse position in pixels.
            Note that if the mouse event has been artificially generated from a special keyboard combination (e.g.
            under Windows when the "menu'' key is pressed), the returned position is <c>wxDefaultPosition</c>.
            
            Call LogicalPosition() if you want to have the position of teh mouse curser translated into the logical
            position within a device context.
            </summary>
        </member>
        <member name="P:WX.MouseEvent.X">
            <summary>Returns X coordinate of the physical mouse event position.</summary>
        </member>
        <member name="P:WX.MouseEvent.Y">
            <summary>Returns Y coordinate of the physical mouse event position.</summary>
        </member>
        <member name="T:WX.ComboPopup">
            <summary>This interface declares those methods which are required by popups of a <c>ComboCtrl</c>.
            Please note, that in contrast to the original  wxWidgets class hierarchy, this is  not intended as
            a base class that shall be inherited together with <c>wx.Control</c>. In contrast, the control shall be
            a member of this. Refer to wx.DatePicker for an example.
            </summary>
        </member>
        <member name="F:WX.ComboPopup._control">
            <summary>Load this with the popup control that will be shown on popup.
            This may either be set by a CTor or by an implementation of Create().</summary>
        </member>
        <member name="M:WX.ComboPopup.#ctor(WX.Window)">
            <summary>CTor already defining a control that will be poped up.
            \param control is the control that will be shown on popup. Please note, that this is required to implement 2 step contruction
                   since that parent will be delivered calling Create(), not earlier.</summary>
        </member>
        <member name="M:WX.ComboPopup.#ctor">
            <summary>CTor creating a sceleton without defining an instance for the popup window.
            If you use this, use Create() to create the <c>PopupControl</c>.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.Init">
            <summary>This is called immediately after construction finishes. m_combo member
            variable has been initialized before the call.</summary>
        </member>
        <member name="M:WX.ComboPopup.Create(WX.Window)">
            <summary>Create the popup child control.
            Implementors shall set <c>_control</c>.
            Return true for success.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.OnPopup">
            <summary>Called immediately after the popup is shown.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.OnDismiss">
            <summary>Called when popup is dismissed.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.SetStringValue(System.String)">
            <summary>Called just prior to displaying popup.
            Default implementation does nothing.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.GetStringValue">
            <summary>Gets displayed string representation of the value.</summary>
        </member>
        <member name="M:WX.ComboPopup.PaintComboControl(WX.DC,System.Drawing.Rectangle)">
            <summary>This is called to custom paint in the combo control itself (ie. not the popup).
            Default implementation draws value as string.</summary>
        </member>
        <member name="M:WX.ComboPopup.OnComboKeyEvent(WX.KeyEvent)">
            <summary>Receives key events from the parent wxComboCtrl.
            Events not handled should be skipped, as usual.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.OnComboDoubleClick">
            <summary>Implement if you need to support special action when user double-clicks on the parent wx.ComboCtrl.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.GetAdjustedSize(System.Int32,System.Int32,System.Int32)">
            <summary>Return final size of popup.
            Called on every popup, just prior to <c>OnShow</c>.
            </summary>
            <param name="minWidth"> is the preferred minimum width for window</param>
            <param name="prefHeight">is the preferred height. Only applies if larger than 0,</param>
            <param name="maxHeight"> is the max. height for window, as limited by screen size and should only be rounded down, if necessary.
            </param>
        </member>
        <member name="M:WX.ComboPopup.LazyCreate">
            <summary>Return true if you want delay call to Create until the popup is shown for the first time.
            It is more efficient, but note that it is often
            more convenient to have the control created immediately.
            Default returns false.
            </summary>
        </member>
        <member name="M:WX.ComboPopup.Dismiss">
            <summary>Hides the popup.</summary>
        </member>
        <member name="M:WX.ComboPopup.IsCreated">
            <summary>Returns true if Create() has been called.</summary>
        </member>
        <member name="P:WX.ComboPopup.PopupControl">
            <summary>The control that will be shown on popup.
            </summary>
        </member>
        <member name="P:WX.ComboPopup.ComboControl">
            <summary>This is the combo box that will popup this.
            </summary>
        </member>
        <member name="P:WX.ComboPopup.StringValue">
            <summary>Synonym for <c>GetStringValue() </c> and <c>SetStringValue() </c>. </summary>
        </member>
        <member name="T:WX.ComboCtrl">
            <summary>The generic combo control available since wxWidgets 2.8.
            A combo control is a generic combobox that allows totally custom popup.
            In addition it has other customization features. For instance, position and size of the dropdown button can be changed.
            
            <c>ComboCtrl</c> needs to be told somehow which control to use and this is done by <c>SetPopupControl() </c>.
            However, we need something more than just a <c>Control</c> in this method as, for example, we need to call
            <c> SetStringValue("initial text value") </c> and <c>Control</c> doesn't have such a method.
            So we also need a <c>ComboPopup</c>
            which is an interface that must be implemented by a control to be usable as a popup.
            
            Refer to wx.DatePicker for an example.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.#ctor">
            <summary>2-step construction: Step one before Create().</summary>
        </member>
        <member name="M:WX.ComboCtrl.Create(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String)">
            <summary>2-step construction: Step two after calling default CTor.
            Define the properties of this window.</summary>
        </member>
        <member name="M:WX.ComboCtrl.Create(WX.Window,System.Int32,WX.wxString,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,WX.wxString)">
            <summary>2-step construction: Step two after calling default CTor.
            Define the properties of this window.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.OnButtonClick">
            <summary>Override for totally custom combo action.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.ShowPopup">
            <summary>Shows the popup.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.HidePopup">
            <summary>Hides the popup.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.Copy">
            <summary>Calls wx.TextCtrl.Copy() of the associaed text control.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.Cut">
            <summary>Calls wx.TextCtrl.Cut() of the associaed text control.
            </summary>
        </member>
        <member name="M:WX.ComboCtrl.Paste">
            <summary>Calls wx.TextCtrl.Cut() of the associaed text control.
            </summary>
        </member>
        <member name="P:WX.ComboCtrl.IsPopupShown">
            <summary>This is <c>true</c> iff the popup is shown.
            Read only.</summary>
        </member>
        <member name="P:WX.ComboCtrl.PopupControl">
            <summary>Get or set the popup control.</summary>
        </member>
        <member name="P:WX.ComboCtrl.PopupWindow">
            <summary>Reads the window displaying the popup control.</summary>
        </member>
        <member name="P:WX.ComboCtrl.TextControl">
            <summary>Reads the text control that is used to display the combo box value.</summary>
        </member>
        <member name="P:WX.ComboCtrl.Button">
            <summary>Reads the button that opend the popup control.
            Please note, that this is not necessarily a Button or a BitmapButton.
            </summary>
        </member>
        <member name="T:WX.SizeEvent">
             <summary>
             A size event holds information about size change events.
            
             The EVT_SIZE handler function will be called when the window has been resized.
            
             You may wish to use this for frames to resize their child windows as appropriate.
            
             Note that the size passed is of the whole window: call wx.Window.GetClientSize for the area which may be used
             by the application.
            
             When a window is resized, usually only a small part of the window is damaged and you may only need to
             repaint that area. However, if your drawing depends on the size of the window, you may need to clear
             the DC explicitly and repaint the whole window. In which case, you may need to call wx.Window.Refresh to
             invalidate the entire window.
             </summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Enum)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry.
            </summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Enum,System.String,System.String)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry. The provided acceleration code will be appended
            to the name separated by a TAB character. This will enable the menu acceleration function
            of wxWidgets.
            </summary>
            <param name="entry">The command and the label of the new menu item</param>
            <param name="accelCode"> An acceleration code like "F1" or "Alt-X" designating a key
            that can be pressed to raise the command that is also triggered by this menu item.</param>
            <param name="help">A description of the command that will e.g. be displayed in status lines.</param>
        </member>
        <member name="M:WX.MenuBase.Append(System.Object,System.String)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c>
            as command identifier.
            </summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,System.String)">
            <summary>Adds a menu item with an integer value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Enum,System.String)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry.
            </summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Object,System.String,System.String)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c> as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,System.String,System.String)">
            <summary>Adds a menu item with an integer value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Object,System.String,System.String,WX.ItemKind)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c> as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,System.String,System.String,WX.ItemKind)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,WX.wxString,WX.wxString,WX.ItemKind)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Object,System.String,WX.Menu)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c>  as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,System.String,WX.Menu)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,System.String,WX.Menu,System.String)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.Append(System.Int32,WX.wxString,WX.Menu,WX.wxString)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:WX.MenuBase.AppendCheckItem(System.Enum)">
            <summary>
            Creates a new check item in the menu. The enumeration value will be used to derive
            the ID for events and to get a text label in the menu via translation.
            </summary>
            <param name="id">Events caused by this item will refer to ID <c>Convert.ToInt32(id)</c>.
            The check box will be labelled with <c>_(id)</c>.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendCheckItem(System.Enum,System.String)">
            <summary>
            Creates a new check item in the menu. The enumeration value will be used to derive
            the ID for events and to get a text label in the menu via translation.
            </summary>
            <param name="id">Events caused by this item will refer to ID <c>Convert.ToInt32(id)</c>.
            The check box will be labelled with <c>_(id)</c>.</param>
            <param name="helpText">Will appear in the status line if the mouse os over this check item.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendRadioItem(System.Enum)">
            <summary>
            Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked.
            </summary>
            <param name="id">ID of the menu command that will be raised on selection change. The translation of this enumeration constant defines the name of the menu entry.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendRadioItem(System.Enum,System.String)">
            <summary>
            Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked.
            </summary>
            <param name="id">ID of the menu command that will be raised on selection change. The translation of this enumeration constant defines the name of the menu entry.</param>
            <param name="help">A help text that will be displayed in the status line on selection.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendRadioItem(System.Int32,System.String)">
            <summary>
            Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked.
            </summary>
            <param name="itemid">ID of the menu command that will be raised on selection change.</param>
            <param name="text">The name of the menu item.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendRadioItem(System.Int32,System.String,System.String)">
            <summary>
            Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked.
            </summary>
            <param name="itemid">ID of the menu command that will be raised on selection change.</param>
            <param name="text">The name of the menu item.</param>
            <param name="help">A help text that will be displayed in the status line on selection.</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBase.AppendRadioItem(System.Int32,WX.wxString,WX.wxString)">
            <summary>
            Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked.
            </summary>
            <param name="itemid">ID of the menu command that will be raised on selection change.</param>
            <param name="text">The name of the menu item.</param>
            <param name="help">A help text that will be displayed in the status line on selection.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Menu.#ctor(System.Enum)">
            <summary>
            Creates a menu whose title is the translation of the provided
            enumeration constant.
            </summary>
            <param name="title">The title of the new menu.</param>
        </member>
        <member name="M:WX.Menu.#ctor(System.Enum,WX.WindowStyles)">
            <summary>
            Creates a menu whose title is the translation of the provided
            enumeration constant.
            </summary>
            <param name="title">The title of the new menu.</param>
            <param name="style">Style defining how to display the menu.</param>
        </member>
        <member name="T:WX.MemoryDC">
            <summary>
            A memory device context provides a means to draw graphics onto a bitmap.
            When drawing in to a mono-bitmap, using wxWHITE, wxWHITE_PEN and wxWHITE_BRUSH will draw the
            background colour (i.e. 0) whereas all other colours will draw the foreground colour (i.e. 1).
            </summary>
            <remarks>
            A bitmap must be selected into the new memory DC before it may be used for anything.
            Typical usage is as follows:
            <code>
            wx.MemoryDC temp_dc;
            temp_dc.SelectObject(test_bitmap);
            
            // We can now draw into the memory DC...
            // Copy from this DC to another DC.
            old_dc.Blit(250, 50, BITMAP_WIDTH, BITMAP_HEIGHT, temp_dc, 0, 0);
            </code>
            Note that the memory DC must be deleted (or the bitmap selected out of it) before a bitmap
            can be reselected into another memory DC.
            </remarks>
        </member>
        <member name="M:WX.MemoryDC.SelectObject(WX.Bitmap)">
            <summary>
            Selects the given bitmap into the device context, to use as the memory bitmap.
            Selecting the bitmap into a memory DC allows you to draw into the DC (and therefore the bitmap)
            and also to use wx.DC.Blit to copy the bitmap to a window.
            For this purpose, you may find wx.DC.DrawIcon easier to use instead.
            
            If the argument is wx.NullBitmap (or some other uninitialised wx.Bitmap) the current
            bitmap is selected out of the device context, and the original bitmap restored, allowing
            the current bitmap to be destroyed safely.
            
            Be careful to use this function and not SelectObjectAsSource when you want to modify the bitmap
            you are selecting otherwise you may incurr in some problems related to wx.Bitmap being a reference
            counted object (see reference counting overview).
            </summary>
            <param name="bitmap"></param>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEditFieldValueChangingEvent">
            <summary>This event will be raised whenever the value of a field is modified.
            Handlers may veto or change the value.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditFieldValueChangingEvent.Veto">
            <summary>Veto.
            The communicated change will be rolled back. If an alternative value has been proposed, this proposal will be removed and discarded.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditFieldValueChangingEvent.Change(System.Object)">
            <summary>Change the proposed value.
            A previous veto will be discarded.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditFieldValueChangingEvent.Vetoed">
            <summary>Returns whether a previous handler vetoed the change.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditFieldValueChangingEvent.Changed">
            <summary>Returns true iff event handlers proposed an alternative value to be set.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditFieldValueChangingEvent.Value">
            <summary>Use this to read the value that will be set with the field.
            Reads the <c>ChangedNewValue</c> if <c>Changed</c>, the <c>OriginalValue</c> if <c>Vetoed</c>, and the <c>OriginalNewValue</c> otherwise.</summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEditFieldValueChangingHandler">
            <summary>Handler for the MaskedEditFieldValueChangingEvent.</summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEditFieldValueChangedEvent">
            <summary>Evetns of this class will be fired after the value of a field changed.</summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEditFieldValueChangedHandler">
            <summary>Handler for the MaskedEditFieldValueChangedEvent.
            </summary>
        </member>
        <member name="T:WX.MaskedEdit.EditField">
            <summary>Base class of all field declarations.
            This is abstract. Use e.g. class EditIntField to create
            instances.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField._posStart">
            <summary>Textposition in the masked text.
            This will be maintained by the control.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField._posEnd">
            <summary>Textposition in the masked text.
            This will be maintained by the control.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.MinWidth">
            <summary>Minimal width of a field.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.MaxWidth">
            <summary>Maximal width of a field.
            All input exceeding this number of characters will discarded.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.EmptyChar">
            <summary>Leading characters if this kind will be ignored.</summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.TextAttributes">
            <summary>The text attributes to be used for this field if not <c>null</c>.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.Name">
            <summary>An optional name for this field.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.EditField.DisplayName">
            <summary>This will e.g. appear in the tooltip text if not empty.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.EditField.SetTextValue(System.String)">
            <summary>This will change <c>TextValue</c>.
            Setting this property will start interpretation of the string.
            The result is true on success, i.e. <c>TextValue</c> has been changed.
            This does not necessarily mean, that <c>TextValue</c> equals <c>newTextValue</c>
            because <c>TextValue</c> may contain leading <c>EmptyChar</c> etc.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.EditField.DeleteChar">
            <summary>Delete a character from the text input of the field and return <c>true</c> on success.</summary>
        </member>
        <member name="M:WX.MaskedEdit.EditField.AddChar(System.Char)">
            <summary>Adds a new character to the field assuming explicit input.</summary>
        </member>
        <member name="M:WX.MaskedEdit.EditField.RaiseOnChangedEvent(System.Object)">
            <summary>Helper for calling events after changing a value.
            This will test whether we have listeners to the event and create an event and fire it.
            The event as modified by the listeners will be returned. The result may be <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.PredefinedChoices">
            <summary>If this differs from <c>null</c>, than this property defines a number of predefined choices that may be for instance used in popup menus.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.TextValue">
            <summary>Returns or the text appearance of the current value.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.Object">
            <summary>This returns the data object of the field.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.EmphasizeLength">
            <summary>Result indicates, that the  n characters beginning with <c>EmphasizeStart</c> shall be emphasized.
            This is 0 by default => no emphasize.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.EmphasizeStart">
            <summary>If <c>EmphasizeLength</c> is larger than 0, then this is the first emphasized character.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.EditField.IsFull">
            <summary>Indicates with <c>true</c> that adding more characters will truncate elder input.
            </summary>
        </member>
        <member name="T:WX.MaskedEdit.EditIntField">
            <summary>Defines a text field containing an integer number.</summary>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.New(System.String)">
            <summary>Creates an instance of a particular name.
            This name may be used to identify the field in event handlers.</summary>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetIn(System.Int32,System.Int32)">
            <summary>Setting <c>MinValue</c> and <c>MaxValue</c>.</summary>
            <returns> this instance </returns>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetMinWidth(System.Int32)">
            <summary>Sets the <c>MinWidth</c>.
            </summary>
            <returns>this instance</returns>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetMaxWidth(System.Int32)">
            <summary>Sets the <c>MaxWidth</c>.
            </summary>
            <returns>this instance</returns>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetWidth(System.Int32)">
            <summary>Sets minimal and maximal width.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetEmptyChar(System.Char)">
            <summary>Sets the <c>EmptyChar</c> to the provided value and return <c>this</c>.
            </summary>
            <remarks>
            Samples:
            \li <c>StringField.New().SetEmptyChar(</c>'_')
            \li <c>StringField.New().SetEmptyChar(</c>'0')
            
            Use decimals es empty character if you want to prevent this field from returning result value <c>null</c>.
            </remarks>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetTextAttributes(WX.TextAttr)">
            <summary>Defines text and background colour.
            Provide <c>null</c> if you do not want to specify text attributes explicitely.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.EditIntField.SetDisplayName(System.String)">
            <summary>
            Changes property TooltipText and returns this.
            </summary>
            <param name="newDisplayName">Thsi will be used by the edit field to dispay ots purpose e.g. in tooltip
            texts.</param>
            <returns></returns>
            <see cref="!:DisplayName"/>
        </member>
        <member name="P:WX.MaskedEdit.EditIntField.Value">
            <summary>Return the value of this field.
            Setting the value will raise MaskedEditFieldValueChangingEvent and MaskedEditFieldValueChangedEvent(s).</summary>
        </member>
        <member name="P:WX.MaskedEdit.EditIntField.TooltipText">
            <summary>
            A tooltip text created from the <c>DisplayName</c> (or if empty from the <c>Name</c>).
            </summary>
        </member>
        <member name="T:WX.MaskedEdit.StringEditField">
            <summary>This is a field containing a string.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.StringEditField._objectConversion">
            <summary>If this is set, this.Object will be converted from the selected string.</summary>
        </member>
        <member name="F:WX.MaskedEdit.StringEditField.AllowedChars">
            <summary>Set this to a string of characters to constrain the used characters.
            If not <c>null</c> only characters mentioned in this string will be allowed in <c>value</c>.
            </summary>
        </member>
        <member name="F:WX.MaskedEdit.StringEditField.Choices">
            <summary>If this is non-null, then this is a number of choices the user may select.
            Insert an empty string (not <c>null)</c> to allow additionally free input.</summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.New">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.New(System.String)">
            <summary>Creates an instance of a particular name.
            This name may be used to identify the field in event handlers.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetWidth(10)</c> is equivalent to StringField.New().SetMinWidth(10).SetMaxWidth(10).
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetMinWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetMinWidth(10).SetMaxWidth(10)</c>
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetMaxWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetMinWidth(10).SetMaxWidth(10)</c>
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetIn(System.String)">
            <summary>Sets the <c>AllowedChars</c> to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().AllowedChars(</c>"abcdefghijklmnopqrstuvwxyz")
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetEmptyChar(System.Char)">
            <summary>Sets the <c>EmptyChar</c> to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetEmptyChar(</c>'_')
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetChoices(System.String[])">
            <summary>Sets availabel choices.
            Add an empty string to allow additionally free text input.
            Sample: <c>StringField.New().SetChoices(</c>"", "one choice", "another choice")
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetChoices(System.Type)">
            <summary>This will set the values of the provided enumeration type as choices.
            This will enumerate the values of the provided enumeration, translate them, and
            include them into the available choices.
            Note: If this has been called, this.Object will return instances of the <c>enumType</c>.
            Note, that this will raise exceptions, is <c>enumType</c> is not an enumeration type.
            </summary>
        </member>
        <member name="M:WX.MaskedEdit.StringEditField.SetTextAttributes(WX.TextAttr)">
            <summary>Defines text and background colour.
            Provide <c>null</c> if you do not want to specify e.g. the background explicitely.</summary>
        </member>
        <member name="P:WX.MaskedEdit.StringEditField.Value">
            <summary>Return the value of this field.
            Setting the value will raise MaskedEditFieldValueChangingEvent and MaskedEditFieldValueChangedEvent(s).
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.StringEditField.PredefinedChoices">
            <summary>This returns <c>Choices</c>.</summary>
        </member>
        <member name="P:WX.MaskedEdit.StringEditField.Object">
            <summary>This is the <c>Value</c> of this field, a string.
            However, if SetChoices() has been called with an enumeration type, this will
            return instances of this type instead.</summary>
        </member>
        <member name="P:WX.MaskedEdit.StringEditField.TextValue">
            <summary><c>Value</c> but expanded to <c>MinWidth</c> und trancated by <c>MaxWidth</c>.</summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEditService">
            <summary>Internal class providing service level for masked text edit.</summary>
        </member>
        <member name="F:WX.MaskedEdit.MaskedEditService._charsAddedToSelectedField">
            <summary>This will be used to count the number of characters that have been added to the current field.
            This will be compared to the maximal width in order to determine whether to switch to the next field.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.StepToFirstField">
            <summary>This is the action triggered by the "Home" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.StepToLastField">
            <summary>This is the action triggered by the "End" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.StepRight">
            <summary>This is the action triggered by the "Cursor right" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.
            Prerequisite: We have a current selection.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.StepLeft">
            <summary>This is the action triggered by the "Cursor left" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.
            Prerequisite: We have a current selection.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.RefreshValue">
            <summary>Updates the text content from the values of the fields-</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.OnChar(System.Object,WX.Event)">
            <summary>This will be called on adding a new character input to the currently selected field.
            This is made public to ease use of masked edits in tables.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.ShowError(WX.MaskedEdit.EditField,System.String)">
            <summary>This will be called by fields on rejecting input.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.ExpandText(System.String,WX.MaskedEdit.EditField[])">
            <summary>Return expanded copy of <c>textMask</c> referring to info from <c>fields</c> and update of positions in the <c>fields</c>.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEditService.SelectField(System.Int32)">
            <summary>Select field <c>i</c> presupposing that ExpandText() has been done.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditService.Count">
            <summary>Number of fields.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditService.Item(System.Int32)">
            <summary>Gets the field of index <c>i</c>.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEditService.TextMask">
            <summary>The text mask defining the format of the input.</summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedEdit">
            <summary>This is a masked edit control.
            Define a number of instances of EditField and a string mask.
            </summary>
            <remarks>
            \image html maskededit.png
            </remarks>
        </member>
        <member name="T:WX.TextCtrl">
             <summary>Control to display and edit text.</summary>
             <remarks>
             <list type="table">
             <item><term>TextProcessEnter</term><description>The control will generate the event wxEVT_COMMAND_TEXT_ENTER (otherwise pressing Enter key is either processed internally by the control or used for navigation between dialog controls).</description></item>
             <item><term>TextProcessTab</term><description>  The control will receive wxEVT_CHAR events for TAB pressed - normally, TAB is used for passing to the next control in a dialog instead. For the control created with this style, you can still use Ctrl-Enter to pass to the next control from the keyboard.  </description></item>
             <item><term>TextMultiline</term><description>  The text control allows multiple lines.  </description></item>
             <item><term>TextPassword</term><description>  The text will be echoed as asterisks.  </description></item>
             <item><term>TextReadonly</term><description>  The text will not be user-editable.  </description></item>
             <item><term>TextRich</term><description>  Use rich text control under Win32, this allows to have more than 64KB of text in the control even under Win9x. This style is ignored under other platforms.  </description></item>
             <item><term>TextRich2</term><description>  Use rich text control version 2.0 or 3.0 under Win32, this style is ignored under other platforms  </description></item>
             <item><term>TextAutoUrl</term><description>  Highlight the URLs and generate the wxTextUrlEvents when mouse events occur over them. This style is only supported for wxTE_RICH Win32 and multi-line wxGTK2 text controls.  </description></item>
             <item><term>TextNoHideSel</term><description>  By default, the Windows text control doesn't show the selection when it doesn't have focus - use this style to force it to always show it. It doesn't do anything under other platforms.  </description></item>
             <item><term>HScroll</term><description>  A horizontal scrollbar will be created and used, so that text won't be wrapped. No effect under wxGTK1.  </description></item>
             <item><term>TextLeft</term><description>  The text in the control will be left-justified (default).  </description></item>
             <item><term>TextCentre</term><description>  The text in the control will be centered (currently wxMSW and wxGTK2 only).  </description></item>
             <item><term>TextRight</term><description>  The text in the control will be right-justified (currently wxMSW and wxGTK2 only).  </description></item>
             <item><term>TextDontWrap</term><description>  Same as wxHSCROLL style: don't wrap at all, show horizontal scrollbar instead.  </description></item>
             <item><term>TextCharWrap</term><description>  Wrap the lines too long to be shown entirely at any position (wxUniv and wxGTK2 only).  </description></item>
             <item><term>textWordWrap </term><description> Wrap the lines too long to be shown entirely at word boundaries (wxUniv and wxGTK2 only).  </description></item>
             <item><term>textBestWrap </term><description> Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default).  </description></item>
             <item><term>TextCapitalize </term><description> On PocketPC and Smartphone, causes the first letter to be capitalized.  </description></item>
             </list>
             
             Note that alignment styles (wxTE_LEFT, wxTE_CENTRE and wxTE_RIGHT) can be changed dynamically after control creation
             on wxMSW and wxGTK. wxTextCtrlReadonly, wxTE_PASSWORD and wrapping styles can be dynamically changed under wxGTK but
             not wxMSW. The other styles can be only set during control creation.
            
             wx.TextCtrl text format
            
             The multiline text controls always store the text as a sequence of lines separated by \n characters, i.e. in the
             Unix text format even on non-Unix platforms. This allows the user code to ignore the differences between the 
             platforms but at a price: the indices in the control such as those returned by GetInsertionPoint or GetSelection
             can not be used as indices into the string returned by GetValue as they're going to be slightly off for platforms
             using "\r\n" as separator (as Windows does), for example.
            
             Instead, if you need to obtain a substring between the 2 indices obtained from the control with the help of the
             functions mentioned above, you should use GetRange. And the indices themselves can only be passed to other methods,
             for example SetInsertionPoint or SetSelection.
            
             To summarize: never use the indices returned by (multiline) wxTextCtrl as indices into the string it contains, but
             only as arguments to be passed back to the other wx.TextCtrl methods.
            
             wx.TextCtrl styles
            
             Multi-line text controls support the styles, i.e. provide a possibility to set colours and font for individual
             characters in it (note that under Windows wxTE_RICH style is required for style support). To use the styles you
             can either call SetDefaultStyle before inserting the text or call SetStyle later to change the style of the text
             already in the control (the first solution is much more efficient).
            
             In either case, if the style doesn't specify some of the attributes (for example you only want to set the text
             colour but without changing the font nor the text background), the values of the default style will be used for
             them. If there is no default style, the attributes of the text control itself are used.
            
             So the following code correctly describes what it does: the second call to SetDefaultStyle doesn't change the 
             text foreground colour (which stays red) while the last one doesn't change the background colour (which stays grey):
            
             <code>
             text.SetDefaultStyle(wxTextAttr(wx.Colour.Red));
             text.AppendText("Red text\n");
             text.SetDefaultStyle(wx.TextAttr(null, wx.Colour.LightGrey));
             text.AppendText("Red on grey text\n");
             text.SetDefaultStyle(wxTextAttr(wx.Colour.Blue);
             text.AppendText("Blue on grey text\n");
             </code>
             
             Event handling
            
             The following commands are processed by default event handlers in wxTextCtrl: Cut, Copy, Paste,
             Undo, Redo. The associated UI update events are also processed automatically, when the control has
             the focus.
            
             To process input from a text control, use these event handler macros to direct input to member functions
             that take a wxCommandEvent argument.
             <list type="table">
             <item><term>EvtText(id, func)</term><description>Respond to a wxEVT_COMMAND_TEXT_UPDATED event, generated when the text changes. Notice that this event will be sent when the text controls contents changes - whether this is due to user input or comes from the program itself (for example, if SetValue() is called); see ChangeValue() for a function which does not send this event.</description></item>
             <item><term>EvtTextEnter(id, func)</term><description>Respond to a wxEVT_COMMAND_TEXT_ENTER event, generated when enter is pressed in a text control (which must have wxTE_PROCESS_ENTER style for this event to be generated).</description></item>
             <item><term>EvtTextUrl(id, func)</term><description>A mouse event occurred over an URL in the text control (wxMSW and wxGTK2 only) </description></item> 
             <item><term>EvtTextMaxLen(id, func)</term><description>User tried to enter more text into the control than the limit set by SetMaxLength.  </description></item>
             </list>
             </remarks>
        </member>
        <member name="M:WX.TextCtrl.AppendFormat(System.String,System.Object[])">
            <summary>This appends the expanded <c>format</c> to the text as presented by this control.
            The format string is due to <c>string.Format()</c>.</summary>
        </member>
        <member name="M:WX.TextCtrl.AppendText(System.String)">
            <summary>This appends <c>text</c> to the text presented in the control.
            Cf. AppendFormat().</summary>
        </member>
        <member name="M:WX.TextCtrl.AppendText(WX.wxString)">
            <summary>This appends <c>text</c> to the text presented in the control.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEdit.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String,WX.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
            
        </member>
        <member name="M:WX.MaskedEdit.MaskedEdit.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.String,WX.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEdit.#ctor(WX.Window,System.String,WX.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEdit.OnChar(System.Object,WX.Event)">
            <summary>
            Call this if you use this control in a grid cell editor immediately
            after receiving a keyboard event. This method will process this event.
            </summary>
            <param name="sender">The grid cell editor or another source of the event.</param>
            <param name="evt">The key event</param>
            <see cref="M:WX.MaskedEdit.MaskedEditService.OnChar(System.Object,WX.Event)"/>
            <seealso cref="!:wx.KeyEvent"/>
        </member>
        <member name="M:WX.MaskedEdit.MaskedEdit.SelectField(System.Int32)">
            <summary>
            Thsi will select the input field of the given index.
            </summary>
            <param name="i">Designates the index field that shall be selected.</param>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEdit.Count">
            <summary>Number of fields.
            </summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedEdit.Item(System.Int32)">
            <summary>Gets the field of index <c>i</c>.
            </summary>
        </member>
        <member name="T:WX.MaskedEdit.Tokenizer">
            <summary>This class receives a string and a number of separators and will enumerate over all parts of the received string, that are separated by one of the separator.
            </summary>
        </member>
        <member name="T:WX.MaskedEdit.MaskedDateTimeEditService">
            <summary>Service class for DateTime input.</summary>
            <remarks>
            This will manage a masked input if a DateTime. Configure the mask using
            the format strings
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            
            This will use string from the definition of the current culture <c>CultureInfo.CurrentCulture.DateTimeFormat</c>.
            The current  wxWidgets locale does not influence this.
            </remarks>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.EditWildcard(System.Char,System.Int32)">
            <summary>This will return the edit field for wildcard <c>c</c> and <c>cardinality</c>.
            Example: "yyyy" => <c>c</c>='y', <c>cardinality</c>=4 => "{yyyy}".</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.StdMaskToEditMask(System.String)">
            <summary>Turns a standard date mask for example from <c>System.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c> into a string mask for this control.
            Sample: "yyyyMMdd" => "{yyyy}{MM}{dd}".</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.StdMasksToEditMask(System.String)">
            <summary>Turns .NET standard mask into an edit mask as used by the DateTime mask edit control.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.IntToString(System.Int32,System.Char,System.Int32)">
            <summary>This will add a prefix to the string form of <c>number</c> consisting of <c>emptyChar</c> in such a way that the result is of length <c>length</c>.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.ExpandFormatString(System.String,System.DateTime)">
            <summary>Produces a string output of <c>data</c> according to a format string that is compatible to the format specifications of this control.
            This expand the following format strings using <c>data</c>:
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c></summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.CreateMaskEdit(WX.TextCtrl,System.String)">
            <summary>This will transform a <c>DateTimeFormatInfo</c> format string into a format string applicable to this.
            This will always use the current culture info for text patterns.
            
            This will create</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.UpdateFieldValues(WX.MaskedEdit.EditField)">
            <summary>Writes the current value into the fields.
            \param protected is a field that will not be updated</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnEditValueChanged(System.Object,WX.MaskedEdit.MaskedEditFieldValueChangedEvent)">
            <summary>Will update all filds if one changed.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.ResetCurrentValue">
            <summary>Helper to find a standard for the current value of required but not set.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnOverflowField(System.Object,WX.MaskedEdit.EditIntField.OverflowEvent)">
            <summary>Called on overflow in day/month input.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnUnderflowField(System.Object,WX.MaskedEdit.EditIntField.UnderflowEvent)">
            <summary>Called on overflow in day/month input.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnChangingLongYear(System.Object,WX.MaskedEdit.MaskedEditFieldValueChangingEvent)">
            <summary>Called if a field on the full year has changed.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnChangingShortYear(System.Object,WX.MaskedEdit.MaskedEditFieldValueChangingEvent)">
            <summary>Called if a field on the final two digits of the year has changed.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.Select(System.Int32)">
            <summary>Select the edit field of the provided index.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.GetNearest(System.Int32)">
            <summary>Returns the index of the edit field that is as near as possible to the provided text position.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.GetNearest(System.Drawing.Point)">
            <summary>Returns the index of the edit field that is as near as possible to the provided window position.</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.OnChar(System.Object,WX.Event)">
            <summary>Directly calls this method of the masked edit.
            Refer to MaskedEditService.OnChar().</summary>
        </member>
        <member name="M:WX.MaskedEdit.MaskedDateTimeEditService.#ctor(WX.TextCtrl,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>* \param ctrl is the text control that will be used for input.
            \param startValue is the optional initial value.
            \param mask is the string mask. This may be an arbitrary string with format specifiers as listed in the
                   documentation of this class (in curly brackets).
            \param minValue is optional minimal acceptable value.
            \param maxValue is optional maximal acceptable value.
            \param allowNull is true if the user may defer or abort input.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.AMDesignator">
            <summary>This will return an AM designator even iff the current culture does not define one.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.PMDesignator">
            <summary>This will return an AM designator even iff the current culture does not define one.</summary>
        </member>
        <member name="E:WX.MaskedEdit.MaskedDateTimeEditService.OnValueChanged">
            <summary>This will be called immediately after the value has been changed.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.Value">
            <summary>Get or set the current value.
            This may be <c>null</c> of this allows empty input.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.TextMask">
            <summary>Returns the text mask defining the format of the text presentation.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.Count">
            <summary>Returns the number of input fields.</summary>
        </member>
        <member name="P:WX.MaskedEdit.MaskedDateTimeEditService.Item(System.Int32)">
            <summary>Returns the edit field at the provided position.
            Use a number between 0 and this.Count. Otherwise, this will raise exceptions.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="T:WX.MaskedEdit.DateTimeEdit">
            <summary>This is a masked edit control for DateTime input.
            This will manage a masked input if a DateTime.
            </summary>
            <remarks>
            Configure the mask using
            the format strings
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            
            This will use string from the definition of the current culture <c>CultureInfo.CurrentCulture.DateTimeFormat</c>.
            The current  wxWidgets locale does not influence this.
            </remarks>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>CTor creating a <c>DateTime</c> edit.
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of the class for further remarks on this.
            \param minValue is an optional lower bound or the input.
            \param maxValue is an optional upper bound of the input.
            \param allowNull indicates with <c>true</c> that this may return a <c>null</c>, i.e. that the input is optional.
            \param style this will accept all styles that also fit wx.TextCtrl. We recomment <c>wx.WindowStyles.BorderSunken</c>.
            
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.#ctor(WX.Window,System.Drawing.Point,System.Drawing.Size,WX.WindowStyles,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>CTor creating a <c>DateTime</c> edit.
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of the class for further remarks on this.
            \param minValue is an optional lower bound or the input.
            \param maxValue is an optional upper bound of the input.
            \param allowNull indicates with <c>true</c> that this may return a <c>null</c>, i.e. that the input is optional.
            
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.#ctor(WX.Window,System.DateTime)">
            <summary>CTor creating a <c>DateTime</c> edit reading a date in localized standard format.
            \param startValue is an optional value that will be displayed on start.</summary>
        </member>
        <member name="F:WX.MaskedEdit.DateTimeEdit.OnValueChanged">
            <summary>This event fires after changing the value of this control.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.Select(System.Int32)">
            <summary>Select the edit field of the provided index.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.GetNearest(System.Int32)">
            <summary>Returns the index of the edit field that is as near as possible to the provided text position.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.GetNearest(System.Drawing.Point)">
            <summary>Returns the index of the edit field that is as near as possible to the provided window position.</summary>
        </member>
        <member name="M:WX.MaskedEdit.DateTimeEdit.OnChar(System.Object,WX.Event)">
            <summary>Directly calls this method of the masked edit.
            Refer to MaskedEditService.OnChar().</summary>
        </member>
        <member name="P:WX.MaskedEdit.DateTimeEdit.Value">
            <summary>Get or set the value.
            The result may be <c>null</c> if this allows empt input.</summary>
        </member>
        <member name="P:WX.MaskedEdit.DateTimeEdit.TextMask">
            <summary>Returns the text mask defining the format of the text presentation.</summary>
        </member>
        <member name="P:WX.MaskedEdit.DateTimeEdit.Count">
            <summary>Returns the number of input fields.</summary>
        </member>
        <member name="P:WX.MaskedEdit.DateTimeEdit.Item(System.Int32)">
            <summary>Returns the edit field at the provided position.
            Use a number between 0 and this.Count. Otherwise, this will raise exceptions.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="T:WX.DataFormatId">
            <summary>
            Enumeration of standard formats of data obejcts.
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_INVALID">
            <summary>
            An invalid format - used as default argument for functions taking a wxDataFormat argument sometimes  
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_TEXT">
            <summary>Text format (string).  
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_BITMAP">
            <summary>
            A bitmap (wx.Bitmap)  
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_METAFILE">
            <summary>
            A metafile (wx.Metafile, Windows only)  
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_FILENAME">
            <summary>
            A list of filenames  
            </summary>
        </member>
        <member name="F:WX.DataFormatId.wxDF_HTML">
            <summary>
            An HTML string. This is only valid when passed to wxSetClipboardData when compiled with Visual C++ in non-Unicode mode  
            </summary>
        </member>
        <member name="T:WX.DataFormat">
             <summary>
             A wx.DataFormat is an encapsulation of a platform-specific format handle which is used by the system for the
             clipboard and drag and drop operations. The applications are usually only interested in, for example, pasting
             data from the clipboard only if the data is in a format the program understands and a data format is something
             which uniquely identifies this format.
            
             On the system level, a data format is usually just a number (CLIPFORMAT under Windows or "Atom" under X11, 
             for example) and the standard formats are, indeed, just numbers which can be implicitly converted to wx.DataFormat.
             
             As mentioned above, these standard formats may be passed to any function taking wx.DataFormat argument because
             wx.DataFormat has an implicit conversion from them.
            
             Aside the standard formats, the application may also use custom formats which are identified by their names
             (strings) and not numeric identifiers. Although internally custom format must be created (or registered)
             first, you shouldn't care about it because it is done automatically the first time the wx.DataFormat object
             corresponding to a given format name is created. The only implication of this is that you should avoid having
             global wx.DataFormat objects with non-default constructor because their constructors are executed before the
             program has time to perform all necessary initialisations and so an attempt to do clipboard format registration
             at this time will usually lead to a crash!
             </summary>
        </member>
        <member name="M:WX.DataFormat.#ctor(System.String)">
            <summary>
            Creates an application specific data format that is described by a name rather than by a number. 
            </summary>
            <param name="id">The name of the data format.</param>
        </member>
        <member name="M:WX.DataFormat.op_Implicit(WX.DataFormat)~System.String">
            <summary>
            Conversion to string by Id. this will fail if the converted format is a standard format.
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:WX.DataFormat.op_Implicit(System.String)~WX.DataFormat">
            <summary>
            Creates a new instance of an application specific DataFormat of the converted name.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:WX.DataFormat.op_Implicit(WX.DataFormat)~WX.DataFormatId">
            <summary>
            Conversion to string by Type. this will fail if the converted format is a standard format.
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:WX.DataFormat.op_Implicit(WX.DataFormatId)~WX.DataFormat">
            <summary>
            Creates a new instance of an application specific DataFormat of the converted name.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="P:WX.DataFormat.IsStandard">
            <summary>
            True iff this is a standard format, i.e. this format is identified by its type.
            Otherwise, this format has an <c>Id</c>.
            </summary>
            <seealso cref="P:WX.DataFormat.Id"/>
            <seealso cref="P:WX.DataFormat.Type"/>
        </member>
        <member name="P:WX.DataFormat.Id">
            <summary>
            Get or set the ID of the data format is this is application sepcific.
            Getting the ID of a standard format will result into a System.NotSupportedException.
            </summary>
            <seealso cref="P:WX.DataFormat.IsStandard"/>
            <exception cref="T:System.NotSupportedException">Will be thrown if this is a standard format.</exception>
        </member>
        <member name="M:WX.Choice.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,System.String[],WX.WindowStyles)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:WX.Choice.#ctor(WX.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,System.String[],WX.WindowStyles,System.String)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="P:WX.Choice.CurrentSelection">
            <summary>Read-only property returning the index of the current selection.
             Unlike ControlWithItems.Selection() which only returns the accepted selection value,
             i.e. the selection in the control once the user closes the dropdown
             list, this function returns the current selection. That is, while
             the dropdown list is shown, it returns the currently selected item
             in it. When it is not shown, its result is the same as for the other
             function.
            </summary>
        </member>
        <member name="T:WX.CheckBoxState">
            <summary>
            Possible states of a check in a wx.CheckBox.
            </summary>
        </member>
        <member name="T:WX.CheckBox">
            <summary>
            A checkbox is a labelled box which by default is either on (checkmark is visible) or off (no checkmark).
            Optionally (when the wxCHK_3STATE style flag is set) it can have a third state, called the mixed or undetermined state.
            Often this is used as a "Does Not Apply" state.
            
            Uses style WindowStyles.CHK_2STATE, WindowStyles.CHK_3STATE, and WindowStyles.CHK_ALLOW_3RD_STATE_FOR_USER.
            </summary>
        </member>
        <member name="P:WX.CheckBox.Value">
            <summary>
            This is the 2-state-value.
            Asserts if the control is in 3-state mode.
            </summary>
        </member>
        <member name="P:WX.CheckBox.ThreeStateValue">
            <summary>
            This is the 3-state-value.
            Asserts if the control is in 2-state mode.
            </summary>
        </member>
        <member name="M:WX.XmlResource.SetSubclassDefaults">
            <summary>Sets the default assembly/namespace based on the assembly from
            		   which this method is called (i.e. your assembly!).
            		 
            		   Determines these by walking a stack trace. Normally 
            		   Assembly.GetCallingAssembly should work but in my tests it 
            		   returned the current assembly in the static constructor above.</summary>
        </member>
        <member name="T:WX.ListItemMask">
            <summary>Indicates relevant members of a wx.ListItem.
            Instances of wx.ListItem may be masked, i.e. only some of their
            properties may be valid. These flags define which properties
            of the item are valid and shall be used and which properties
            are irrelevant and shall be ignored.</summary>
        </member>
        <member name="F:WX.ListItemMask.None">
            <summary>Nothing is valid.</summary>
        </member>
        <member name="F:WX.ListItemMask.STATE">
            <summary>wx.ListItem.State</summary>
        </member>
        <member name="F:WX.ListItemMask.TEXT">
            <summary>wx.ListItem.Text</summary>
        </member>
        <member name="F:WX.ListItemMask.IMAGE">
            <summary>wx.ListItem.Image</summary>
        </member>
        <member name="F:WX.ListItemMask.DATA">
            <summary>wx.ListItem.Data</summary>
        </member>
        <member name="F:WX.ListItemMask.ITEM">
            <summary>wx.ListItem.Item</summary>
        </member>
        <member name="F:WX.ListItemMask.WIDTH">
            <summary>wx.ListItem.Width</summary>
        </member>
        <member name="F:WX.ListItemMask.FORMAT">
            <summary>wx.ListItem.Format</summary>
        </member>
        <member name="F:WX.ListItemMask.ALL">
            <summary>Denotes all properties of list items.</summary>
        </member>
        <member name="T:WX.ListItemState">
            <summary>Flags for wx.ListCtrl.GetNextItem()</summary>
        </member>
        <member name="T:WX.ListItem">
            <summary>Representation of an item in wx.ListCtrl or wx.ListView.</summary>
        </member>
        <member name="M:WX.ListItem.#ctor(System.String)">
            <summary>Generating an item representing the following text.
            </summary>
        </member>
        <member name="M:WX.ListItem.#ctor(System.String,WX.ListColumnFormat)">
            <summary>Generating an item of the provided text and the specified alignment.</summary>
            <param name="align"> is a constant like wx.ListCtrl.wxLIST_FORMAT_CENTRE
            </param>
        </member>
        <member name="P:WX.ListItem.Align">
            <summary>A constant like wx.ListColumnFormat.CENTRE.</summary>
        </member>
        <member name="P:WX.ListItem.Data">
            <summary>Get or set the client data that is associated with this list item.
            Please note, that the list item will take ownership of the C++ instance of the client data.
            So, this will raise an exception, if the client data is already in use elsewhere.</summary>
        </member>
        <member name="T:WX.ListColumnFormat">
            <summary>Format for list columns.
            This will be used in wx.ListCtrl.Arrange() and wx.ListItem.Align</summary>
        </member>
        <member name="T:WX.ListHitTest">
            <summary>Flags that may result from wx.ListCtrl.HitTest().</summary>
        </member>
        <member name="T:WX.ListCtrl">
            <summary>The list control.
            This is appropriate to display also large lists of data.
            \image html listctrlsmall.png "The list control in report mode."</summary>
        </member>
        <member name="M:WX.ListCtrl.OnGetItemText(System.Int32,System.Int32)">
            <summary>Overload this to provide the name of a virtually represented item.
            The default implementation returns an empty string. So, don't be surprised if
            you get an empty list because you didn't implement this.</summary>
        </member>
        <member name="M:WX.ListCtrl.OnGetItemImage(System.Int32)">
            <summary>Return the index of the icon of the designated item in the used image list.
            Overload this for virtual lists.
            
            This standard implementation will return an undefined index (-1)
            for "do no show any item image".</summary>
        </member>
        <member name="M:WX.ListCtrl.OnGetItemColumnImage(System.Int32,System.Int32)">
            <summary>Return the index of the icon of the designated item and the designated column in the used image list.
            Overload this for virtual lists.
            
            This standard implementation will return an undefined index (-1)
            for "do no show any item image".</summary>
        </member>
        <member name="M:WX.ListCtrl.GetItem(WX.ListItem)">
            <summary>Assigns the item corresponding to the ID, column, and property mask of <c>info</c> to <c>info</c>.
            This is for compatibility to  wxWidgets only. Use the indexer if you prefer
            a more convenient and more standard way to ask for items.
            
            <c>info</c> will be loaded with all properties of item sharing ID and column
            with <c>info</c> as designated by <c>info.Mask</c>.
            </summary>
        </member>
        <member name="M:WX.ListCtrl.SetItem(WX.ListItem)">
            <summary>Assigns item <c>info</c> to the control.
            This will change the properties of the item of this control sharing the ID
            with <c>info</c>. The method will select those properties of <c>info</c> that are
            compatible with the property mask of <c>info</c>.
            This is for compatibility to  wxWidgets only. Use the indexer if you prefer
            the standard way to set for items.
            </summary>
        </member>
        <member name="M:WX.ListCtrl.GetItemState(System.Int32,WX.ListItemState)">
            <summary>Item state. Only the bits of the mask will be queried.</summary><remarks>
                     * \verbatim
                     if (listCtrl.GetItemState(3, ListItemState.SELECTED)==ListItemState.SELECTED)
                        System.Diagnostics.Trace.WriteLine("Item 3 has been selected.");
                     \endverbatim
                     * </remarks>
        </member>
        <member name="M:WX.ListCtrl.IsSetItemStateFlag(System.Int32,WX.ListItemState)">
            <summary>True iff all <c>flags</c> have been set for item <c>item</c>.
                     * </summary>
                     * <remarks>
                     * Is equivalent to 
                     * \verbatim
                     this.GetItemState(item, flags)==flags
                     \endverbatim
                     * </remarks>
        </member>
        <member name="M:WX.ListCtrl.SetImageList(WX.ImageList,WX.wxImageList)">
            <summary>Defines the image list to be used by instances of wx.ImageItem added to this list.</summary>
            <param name="which"> defines which of the internal image lists will be set, e.g. by wx.wxImageList.wxIMAGE_LIST_SMALL.
            </param>
        </member>
        <member name="M:WX.ListCtrl.EnsureVisible(System.Int32)">
            <summary>Ensures visibility of the designated item.</summary>
        </member>
        <member name="M:WX.ListCtrl.AppendItemRow(WX.ListItem[])">
            <summary>This will change the Id of the provided items to the number of known items and then insert them.
            This is a convenience method to append items at the end of the current item list without regarding
            the ID of the items.</summary>
        </member>
        <member name="M:WX.ListCtrl.InsertItemRow(WX.ListItem[])">
            <summary>This will insert a new item assuming each of the arguments to represent a column value.
            The first column item will be used for column 0, the second for column 1, and so forth.
            The method will adjust the column attribute of the arguments.</summary>
        </member>
        <member name="M:WX.ListCtrl.InsertItem(WX.ListItem)">
            <summary>Inserts an item and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:WX.ListCtrl.InsertItem(System.Int32,System.String)">
            <summary>Inserts an item and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:WX.ListCtrl.InsertItem(System.Int32,System.Int32)">
            <summary>Inserts an item presenting an image and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:WX.ListCtrl.InsertItem(System.Int32,System.String,System.Int32)">
            <summary>Inserts an item presenting image and text label and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:WX.ListCtrl.ScrollList(System.Int32,System.Int32)">
            <summary>Scrolls the list control.
             If in icon, small icon or report view mode, <c>dx</c> specifies the number of
             pixels to scroll. If in list view mode, <c>dx</c> specifies the number of columns
             to scroll. <c>dy</c> always specifies the number of pixels to scroll vertically.
            
             \b NB: This method is currently only implemented in the Windows version.
             
             Try EnsureVisible().</summary>
        </member>
        <member name="M:WX.ListCtrl.SortItems(WX.ListCtrl.wxListCtrlCompare,System.Int32)">
            <summary>Sort the contained list items with respect to <c>fn</c>.
            Refer to remarks on <c>wxListCtrlCompare</c>.
            </summary>
        </member>
        <member name="M:WX.ListCtrl.SortItemsAccordingToClientData(System.Collections.IComparer)">
            <summary>Sort according to the order of client data as specified by the comparer.
            This assumes that all items have assigned client data assigned and that this
            data implements System.IComparable. Missing or non-comparable client data 
            will be replaced by the item's name.</summary>
        </member>
        <member name="M:WX.ListCtrl.GetEnumerator">
            <summary>Returns an enumeration of all nodes.
            Refer to ListCtrlEnumerator.</summary>
        </member>
        <member name="P:WX.ListCtrl.SelectedItems">
            <summary>Returns a list of selected items.</summary>
        </member>
        <member name="P:WX.ListCtrl.Item(System.Int32)">
            <summary>Gets and sets the item at the designated position.
            If you assign an item using this indexer, the ID of this item
            will change to <c>index</c>. The mask will also be set to wx.ListItemMask.ALL.
            </summary>
        </member>
        <member name="P:WX.ListCtrl.ViewRect">
            <summary>This only works in icon mode and returns an unspecific reactangle otherwise.</summary>
        </member>
        <member name="T:WX.ListCtrl.NEXT">
            <summary>Flags for GetNextItem()</summary>
        </member>
        <member name="T:WX.ListCtrl.SymbolicColumnWidth">
            <summary>These are optional symbolic specifications of the column width.
            Refer to wx.ListCtrl.SetColumnWidth().</summary>
        </member>
        <member name="F:WX.ListCtrl.SymbolicColumnWidth.AutoSize">
            <summary>This will resize the column to the length of its longest item.</summary>
        </member>
        <member name="F:WX.ListCtrl.SymbolicColumnWidth.AutoSizeUseHeader">
            <summary>This will resize the column to the length of the header (Win32) or 80 pixels (other platforms).</summary>
        </member>
        <member name="T:WX.ListCtrl.wxListCtrlCompare">
            <summary>The corresponding  wxWidgets function type uses <c>int</c> data to designate items and sort data.
             However, C typically identifies <c>int</c> and <c>long</c> on 32 bit architectures. Apparently, C# does not so.
             It is apparently unwise to use <c>long</c> in native C interfaces since this data type does not have
             a standard size_t.
            </summary>
        </member>
        <member name="T:WX.ListCtrl.SortCallback">
            <summary>This internal class converts from <c>cbSortItems</c> to <c>wxListCtrlCompare</c>.
            </summary>
        </member>
        <member name="T:WX.ListCtrl.ItemDataComparer">
            <summary>A class comparing the client data of items.</summary>
        </member>
        <member name="M:WX.ListCtrl.ItemDataComparer.Compare(WX.ClientData,WX.ClientData,System.Int32)">
            <summary>Expects the objects to be indices of items in the control and compares associated client data using the comparer.</summary>
        </member>
        <member name="M:WX.ListCtrl.ItemDataComparer.Compare(System.Object,System.Object)">
            <summary>Expects the objects to be instances of ClientData.</summary>
        </member>
        <member name="T:WX.ListCtrl.ItemEnumerator">
            <summary>Enumerator on list items.
            This is an alternative, more C# like interface to wx.ListCtrl.GetNextItem().
            </summary>
        </member>
        <member name="M:WX.ListCtrl.ItemEnumerator.#ctor(WX.ListCtrl)">
            <summary>Iterates all nodes.
            </summary>
        </member>
        <member name="M:WX.ListCtrl.ItemEnumerator.#ctor(WX.ListCtrl,WX.ListItemState)">
            <summary>Iterates all nodes complying with <c>stateFilter</c>.
            </summary>
        </member>
        <member name="P:WX.ListEvent.Data">
            <summary>Returns the client data that has been associated with the item.</summary>
        </member>
        <member name="T:WX.Fullscreen">
            <summary> Flags for Frame.ShowFullScreen.
                 </summary>
        </member>
        <member name="F:WX.Fullscreen.None">
            <summary>
            Retain to normal style.
            </summary>
        </member>
        <member name="F:WX.Fullscreen.All">
            <summary>
            No menubar, toolbar, statusbar, border, and caption.
            </summary>
        </member>
        <member name="T:WX.SystemObjectClientData">
            <summary>Generate an instance of this class to use an System.Object as client data of choices etc.
             This simply generates an instance of ClientData, which holds a new instance of <c>wxClientData</c>.
             Of course, that <c>wxClientData</c> does not hold any data, but when .NET code refers to client data
             of a Choice or another control, the selector will use this pointer to a <c>wxClientData</c> to
             identify this instance via <c>Object.FindObject()</c>.
            </summary>
        </member>
        <member name="F:WX.Aui.AuiNotebookOption.LEFT">
            <summary>
            not implemented yet
            </summary>
        </member>
        <member name="F:WX.Aui.AuiNotebookOption.RIGHT">
            <summary>
            not implemented yet
            </summary>
        </member>
        <member name="T:WX.Archive.ZipStream">
            <summary>Internal base class for writing or reading into a ZIP stream.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipStream.SetLength(System.Int64)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipStream.Length">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipStream.Position">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveEntry">
            <summary>Describes an entry of an archive.</summary><remarks>
            An entry is a file included into an archive. Instances of this class
            are used as a key to denote particular files for reading and on the
            other hand provide meta information on the file as far as this
            information has been accessable.
            
            Generate instances by wx.ArchiveInput.
            
            \ref archive_formats_such_as_zip</remarks>
        </member>
        <member name="M:WX.Archive.ArchiveEntry.TypeFromName(System.String)">
            <summary>Conludes the archive type from the file name.
             Uses Zip by default.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveEntry.TypeFromName(System.Uri)">
            <summary>Conludes the archive type from the file name.
             Uses Zip by default.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.DateTime">
            <summary>Modifcation time.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.InternalName">
            <summary>The internal representation of the file name of this entry.
             Use this to implement portable comparisons.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.Name">
            <summary>The file name of this entry in native format.
             This can be read and set.
             
             If this is a directory entry, (i.e. if IsDir() is true) then
             Name() returns the name with a trailing path separator.
             Similarly, setting a name with a trailing path separator
             sets IsDir().
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.IsDir">
            <summary>True iff this represents a directory.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.Offset">
            <summary>Returns a numeric value unique to the entry within the archive.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveEntry.Size">
            <summary>The size of the entry's data in bytes.
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveEntry.ArchiveType">
            <summary>
            The type of the archive - compression mode.
            </summary>
        </member>
        <member name="F:WX.Archive.ArchiveEntry.ArchiveType.Zip">
            <summary>
            Uses Zip compression
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveOutput">
            <summary>Writing into an archive file type supported by  wxWidgets.</summary><remarks>
              wxWidgets supports reading, analyzing, and writing archive files. Currently
             only ZIP archives are supported. Corresponding features are only partially
             supported by the standard .NET framework since 2.0.
             
             The interface of this class differs strongly from the  wxWidgets API since
             this API shall be extendable to use standard .NET framework classes where
             possible. Additionally, we cannot inherit from both, wx.Object and Stream.
             
             \ref archive_formats_such_as_zip
            </remarks>
        </member>
        <member name="F:WX.Archive.ArchiveOutput._streamOnEntry">
            <summary>Stream for writing into an entry.
             This is <c>null</c> if entry is closed.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.#ctor(System.Uri)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.#ctor(System.Uri,WX.Archive.ArchiveEntry.ArchiveType)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.PutNextEntry(System.String)">
            <summary>Sets Out() to a fill a new entry of the provided name.
             If Out() has been already non-null before, the previous stream
             on the entry will be closed.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.CopyEntry(WX.Archive.ArchiveEntry,WX.Archive.ArchiveInput)">
            <summary>* Takes ownership of entry and uses it to create a new entry in the archive. Entry is then opened in the input stream stream and its contents copied to this stream.
             For archive types which compress entry data, CopyEntry() is likely to be much more efficient than transferring the data using Read() and Write() since it will copy them without decompressing and recompressing them.
             entry must be from the same archive file that stream is accessing. For non-seekable streams, entry must also be the last thing read from stream.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.CopyArchiveMetaData(WX.Archive.ArchiveInput)">
            <summary>* Some archive formats have additional meta-data that applies to the
             archive as a whole. For example in the case of zip there is a
             comment, which is stored at the end of the zip file.
             CopyArchiveMetaData() can be used to transfer such information
             when writing a modified copy of an archive.
            
             Since the position of the meta-data can vary between the various
             archive formats, it is best to call CopyArchiveMetaData() before
             transferring the entries. The wx.ArchiveOutput will then
             hold on to the meta-data and write it at the correct point in the
             output file.
            
             When the input archive is being read from a non-seekable stream,
             the meta-data may not be available when CopyArchiveMetaData()
             is called, in which case the two streams set up a link and 
             transfer the data when it becomes available.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveOutput.Close">
            <summary>This closes the whole archive and returns true in case of success.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveOutput.Out">
            <summary>This is the stream to write into the current entry of the archive.
             This is <c>null</c> if we do not have an opened entry.
             Entries can be opened by PutNextEntry().
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveOutput.ZipOutStream">
            <summary>Internal class for writing into a ZIP stream on an entry in the archive.
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveInput">
            <summary>Reading from an archive file whose type is supported by wxWidgets.
              wxWidgets currently supports reading, analyzing, and writing archive files
             of ZIP archives. Corresponding features are only partially
             supported by the .NET framework.
             
             The interface of this class differs strongly from the  wxWidgets API since
             this API shall be extendable to use standard .NET framework classes where
             possible.
            </summary>
        </member>
        <member name="F:WX.Archive.ArchiveInput._streamOnEntry">
            <summary>Stream for writing into an entry.
             This is <c>null</c> if entry is closed.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.#ctor(WX.FileSys.wxInputStreamWrapper,WX.Archive.ArchiveEntry.ArchiveType)">
            <summary>Creates an archive input representation reading compressed data from the provided stream.
            Please note, that this instance will take ownership of the native code instance wrapped by
            the <c>wxInputStreamWrapper</c>.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.#ctor(System.IO.Stream,WX.Archive.ArchiveEntry.ArchiveType)">
            <summary>Generate an instance reading compressed data from the provided stream.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.#ctor(System.IO.Stream)">
            <summary>Generate an instance reading compressed data from the provided stream.
             By default this will interpret the data as a ZIP archive.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.#ctor(System.Uri)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.#ctor(System.Uri,WX.Archive.ArchiveEntry.ArchiveType)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.GetNextEntry">
            <summary>
            Closes the current entry if one is open, then reads the meta-data for
            the next entry and returns it in a wxArchiveEntry object, giving away
            ownership. Reading <c>this.In</c> then returns the entry's
            data. If all entries have already been enumerated calling this method, 
            the result will be <c>null</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Archive.ArchiveInput.OpenEntry(WX.Archive.ArchiveEntry)">
            <summary>Closes the current entry if one is open, then opens the entry specified</summary><remarks>
             by the wxArchiveEntry object.
            
             <c>entry</c> must be from the same archive file that this wx.ArchiveInput is reading,
             and it must be reading it from a seekable stream.
            
             \ref looking_up_an_archive_entry_by_name</remarks>
        </member>
        <member name="M:WX.Archive.ArchiveInput.Close">
            <summary>This closes In() if we have an open entry.
            </summary>
        </member>
        <member name="M:WX.Archive.ArchiveInput.GetInternalName(System.String)">
            <summary>Returns the internal representation of <c>localFilename</c> in the current type of archive.
             Note, that instances of this class may wrap archives of different type, so the internal
             representation depends on the archive type.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveInput.In">
            <summary>This is the stream to read the current entry from.
             This is <c>null</c> if all entries are closed (none has been opened).
            </summary>
        </member>
        <member name="T:WX.Archive.ArchiveInput.ZipInStream">
            <summary>Internal class for writing into a ZIP stream on an entry in the archive.
            </summary>
        </member>
        <member name="P:WX.Archive.ArchiveInput.ZipInStream.CanSeek">
            <summary>Returns <c>true</c> iff you may seek this stream.
            This method currently relies on <c>IsSeekable()</c> if the archive
            stream. Apparently, the ZIP streams do not implement this method
            although they implement <c>Seek()</c>. Anyway, this will return <c>false</c>
            to enable particular heuristics in the IOStreamFSHandler.
            
            Image handlers of  wxWidgets want to seek.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:WX.Archive.ZipResource" ignoriert -->
        <member name="F:WX.Archive.ZipResource._archiveNameToDerivates">
            <summary>This maps a KeyArchiveName to a list of derived archive names on the mentioned locale.
            </summary>
        </member>
        <member name="F:WX.Archive.ZipResource._archives">
            <summary>This maps the local file name to the resource archive.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.ComputeDerivates(System.String,System.String,System.String)">
            <summary>Searches all derivates of <c>archiveName</c> whether they are an archive or a directory.
             Returns the name of the first existing derivate.
             \param archiveName is a filename of an archive. On missing extension, _stdSubdir() will be
             added. Note, that tis filename will be extended, so existance of this file is not required.
             \param additionalPrefix is a directory name that is additionally used as a prefix for resource archives.
             (In addition to AddCatalogLookupPrefix()).
             \param canonicalName is the canonical name of a locale. This method will search the resource
             for this locale.
             
             Extends _archiveNameToDerivates() in such a way that it containes all derivates if the provided <c>archiveName</c>.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.InitFromArchive(System.String,System.IO.Stream)">
            <summary>Initializes _dirName or _src and _internalNameToEntry from the archive returned by FindArchive().
             Main purpose: Cache archive entries if required. Possibly, resources cannot be loaded because
             the archive has not been found. In this case, do not throw an exception put set all
             possible sources <c>_dirName</c> and <c>_src</c> to <c>null</c>.
             srcStream may be <c>null</c>. Then it will be generated from the name that will
             be interpreted as a file name.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.#ctor(System.String,System.IO.Stream)">
            <summary>Loads an archive.
             This will call InitFromArchive(). All entries will be read and cached.
             srcStream may be <c>null</c>. Then it will be generated from the <c>archiveName</c> that will
             be interpreted as a file name. If read from the local file system (with <c>srcStream</c> equals
             <c>null)</c>, <c>archiveName</c> may either be a filename of a directory.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.AddCatalogLookupPrefix(System.String)">
            <summary>Add a prefix to be lookup path for loading archives with resources.
             Similar to wx.Locale.AddCatalogLookupPrefix().
             The message catalog files will be looked up under
             <c>prefix/LANG/zrs</c>,
             <c>prefix/LANG</c>, and <c>prefix</c>
             (in this order) where LANG is the canonical name of a locale.
            
             <c>prefix</c> will be expanded using the code base path of the calling assembly
             if necessary. So, the meaning of <c>prefix</c> never relies on the CWD but always
             on the position of the assemblies.
            
             This only applies to subsequent instance creations.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.GetDerivatedArchiveNames(System.String)">
            <summary>Returns the file names derivated from <c>archiveName</c> of the current <c>wx.Locale</c>.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.GetDerivatedArchiveNames(System.String,System.String)">
            <summary>Returns the file names derivated from <c>archiveName</c> assuming the locale <c>canonicalName</c>.
             Use the empty string to denote the neutral locale.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.GetDerivatedResourceNames(System.String)">
            <summary>Returns the resource names derivated from <c>resourceName</c> of the current <c>wx.Locale</c>.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.GetDerivatedResourceNames(System.String,System.String)">
            <summary>Returns the resource names derivated from <c>resourceName</c> assuming locale <c>canonicalName</c>.
             Use the empty string to denote the neutral locale.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.FindResource(System.Reflection.Assembly,System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            
             Non-rooted paths will be rooted with reference to the code base of <c>callingAssembly</c>.
             </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.FindResource(System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            
             Non-rooted paths will be rooted with reference to the code base of the calling assembly.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.ResourceFileCanSeek(System.String,System.String)">
            <summary>Some kinds of data, especially images, require data sources that can seek positions in the stream.
            This will call ResourceFile() and then, if the result cannot seek, load the source directly into
            a memory stream.</summary>
        </member>
        <member name="M:WX.Archive.ZipResource.ResourceFileAppropriateType(System.String,System.String)">
            <summary>This method will produce a stream that can seek (cf. ResourceFileCanSeek) if this seems to be appropriate referring to the mime type.
            At least images need streams as data source that can seek. This method will call ResourceFile() and analyze
            the mime type of the result. If considered to be appropriate, the content of the resource stream will
            be copied into a System.IO.MemoryStream in order to get a stream that can seek positions.
            Refer also to ResourceFileCanSeek().</summary>
        </member>
        <member name="M:WX.Archive.ZipResource.FindResourceFile(System.String,System.String)">
            <summary>Finds a FSFile instance containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.FindResource(System.String,System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name suitable for the specified locale from the provided archive.
            \param archiveName is a filename describing the archive where the resource has been compiled in. This may also be the name of a resource.
            This method will generate derivates from this name as described below.
            \param resourceName is a native filename (according to the conventions of class Path) describing
            the resource. This method will generate derivates from this name as described below.
            \param canonicalName is the canonical name of the locale that the required resource has to comply with.
            If a locale specific resource cannot be found, the method will load a neutral version. If this is <c>null</c>
            or empty, this method will immediately search for a neutral resource.
            
            If the resources cannot be found, the manifest of the calling assembly will be searched.
            
            This method will return a <c>null</c> if the desired resource cannot be find.</summary>
        </member>
        <member name="M:WX.Archive.ZipResource.FindResourceFile(System.String,System.String,System.String)">
            <summary>Finds a FSFile instance containing a resource of the provided name from the provided archive of a provided locale (culture).
             Refer to FindResource(string, string, string) for details.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipResource.LastFoundResourceName">
            <summary>The last name of a resource that has been found by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipResource.LastSearchedArchiveName">
            <summary>The last name of a resource that has been tried to be loaded by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipResource.LastFoundArchiveName">
            <summary>The last name of a resource that has been found by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:WX.Archive.ZipResource.LastFoundArchive">
            <summary>The last ZipResource found by FindResource().
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.KeyArchiveName.#ctor(System.String,System.String)">
            <summary>Generates a key for the archive and the neutral locale.
            </summary>
        </member>
        <member name="M:WX.Archive.ZipResource.KeyArchiveName.#ctor(System.String,System.String,System.String)">
            <summary>Generates a key for the derivatives of <c>archiveName</c> with the specified locale.
            </summary>
        </member>
        <member name="M:WX.ToolBarTool.Toggle">
            <summary>
            Toggles the tool.
            </summary>
        </member>
        <member name="M:WX.ToolBarTool.Toggle(System.Boolean)">
            <summary>
            Toggles a tool on or off. This does not cause any event to get emitted.
            Only applies to a tool that has been specified as a toggle tool.
            </summary>
            <param name="toggle">If true, toggles the tool on, otherwise toggles it off.</param>
            <seealso cref="!:GetToolState"/>
        </member>
        <member name="T:WX.ToolBar">
             <summary>
             You may also create a toolbar that is managed by the frame, by calling wx.Frame.CreateToolBar(). Under Pocket PC,
             you should always use this function for creating the toolbar to be managed by the frame, so that wxWidgets can use
             a combined menubar and toolbar. Where you manage your own toolbars, create a wxToolBar as usual.
            
             The meaning of a "separator" is a vertical line under Windows and simple space under GTK+.
             </summary>
             <remarks>
             The toolbar family of classes allows an application to use toolbars in a variety of configurations and styles.
            
             The toolbar is a popular user interface component and contains a set of bitmap buttons or toggles.
             A toolbar gives faster access to an application's facilities than menus, which have to be popped up and
             selected rather laboriously.
             
             For each platform, the symbol wxToolBar is defined to be one of the specific toolbar classes.
            
             A toolbar might appear as a single row of images under the menubar, or it might be in a separate frame layout
             in several rows and columns. The class handles the layout of the images, unless explicit positioning is requested.
            
             A tool is a bitmap which can either be a button (there is no 'state', it just generates an event when clicked) or
             it can be a toggle. If a toggle, a second bitmap can be provided to depict the 'on' state; if the second bitmap is
             omitted, either the inverse of the first bitmap will be used (for monochrome displays) or a thick border is drawn
             around the bitmap (for colour displays where inverting will not have the desired result).
            
             The Windows-specific toolbar classes expect 16-colour bitmaps that are 16 pixels wide and 15 pixels high. If you
             want to use a different size, call SetToolBitmapSize as the demo shows, before adding tools to the button bar.
             Don't supply more than one bitmap for each tool, because the toolbar generates all three images (normal,
             depressed and checked) from the single bitmap you give it.
             </remarks>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,System.String,WX.Bitmap)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Enum,WX.Bitmap)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An enumeration value, that defines tool id and label of the new tool.
            The conversion to integer is a kay by which the tool may be identified in subsequent operations.
            The translation will be used as label.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,System.String,WX.Bitmap,WX.Bitmap,WX.ItemKind,System.String,System.String,WX.ClientData)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="bmpDisabled">The bitmap used when the tool is disabled. If it is equal to wx.NullBitmap,
            the disabled bitmap is automatically generated by greing the normal one.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,WX.wxString,WX.Bitmap,WX.Bitmap,WX.ItemKind,WX.wxString,WX.wxString,WX.ClientData)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="bmpDisabled">The bitmap used when the tool is disabled. If it is equal to wx.NullBitmap,
            the disabled bitmap is automatically generated by greing the normal one.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,System.String,WX.Bitmap,System.String,WX.ItemKind)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,WX.wxString,WX.Bitmap,WX.wxString,WX.ItemKind)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns></returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Int32,WX.Bitmap,WX.Bitmap,System.Boolean,WX.ClientData,System.String,System.String)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns></returns>
        </member>
        <member name="M:WX.ToolBar.AddTool(System.Enum,WX.Bitmap,System.String)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An enumeration value, that defines tool id and label of the new tool.
            The conversion to integer is a kay by which the tool may be identified in subsequent operations.
            The translation will be used as label.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="shortHelpString">A short help string.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:WX.ToolBar.Realize">
            <summary>
            This function should be called after you have added tools.
            </summary>
        </member>
        <member name="T:WX.SystemColour">
            <summary>
            Colour descriptor for SystemSettings.GetColour().
            </summary>
        </member>
        <member name="T:WX.SystemSettings">
            <summary>
            SystemSettings allows the application to ask for details about the system. This can include settings such as standard colours, fonts, and user interface element sizes.
            </summary>
        </member>
        <member name="M:WX.SystemSettings.GetColour(WX.SystemColour)">
            <summary>
            Returns the colour that is used by the operating system for the purpose as indicated by the argument.
            A display of the system table is available at <c>helpview.exe</c> from the "about box".
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:WX.StaticText">
            <summary>This displays a static text field.
            These controls consume wx.WindowStyles.ST_NO_AUTORESIZE and the flags on alignment.</summary>
        </member>
        <member name="T:WX.StaticBoxSizer">
            <summary>
            A BoxSizer surrounded by a static box.
            </summary>
        </member>
        <member name="M:WX.StaticBoxSizer.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="M:WX.StaticBoxSizer.#ctor(WX.StaticBox,WX.Orientation)">
            <summary>Creates a layout resuing a predefined static box.</summary>
        </member>
        <member name="M:WX.StaticBoxSizer.#ctor(WX.Orientation,WX.Window)">
            <summary>Creates an instance of the provided orientation without a a label.</summary>
        </member>
        <member name="M:WX.StaticBoxSizer.#ctor(WX.Orientation,WX.Window,System.String)">
            <summary>Creates an instance of the provided orientation with the specified label.</summary>
        </member>
        <member name="M:WX.StaticBoxSizer.#ctor(WX.Orientation,WX.Window,WX.wxString)">
            <summary>Creates an instance of the provided orientation with the specified label.</summary>
        </member>
        <member name="T:WX.PrintPreview">
            <summary>
            Objects of this class manage the print preview process.
            The object is passed a wxPrintout object, and the wx.PrintPreview object itself is passed to a wx.PreviewFrame object.
            Previewing is started by initializing and showing the preview frame. Unlike wx.Printer.Print, flow of control
            returns to the application immediately after the frame is shown.
            </summary>
            <remarks>
            \image html printpreview.png
            </remarks>
        </member>
        <member name="T:WX.MenuBar">
            <summary>
            Class of manu bars. Assign instances to wx.Frame.MenuBar.
            </summary>
        </member>
        <member name="M:WX.MenuBar.Append(WX.Menu,System.String)">
            <summary>
            Appends a menu to the menu bar.
            </summary>
            <param name="menu">The menu</param>
            <param name="title">The title of the added menu in the menu bar</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBar.Append(WX.Menu,WX.wxString)">
            <summary>
            Appends a menu to the menu bar.
            </summary>
            <param name="menu">The menu</param>
            <param name="title">The title of the added menu in the menu bar</param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBar.Append(WX.Menu)">
            <summary>
            Appends the menu using its title.
            </summary>
            <param name="menu"></param>
            <returns></returns>
        </member>
        <member name="M:WX.MenuBar.Append(WX.Menu,System.Enum)">
            <summary>
            Appends a menu to the menu bar.
            </summary>
            <param name="menu">The menu</param>
            <param name="title">The added menu will have the translation of this value as title.</param>
            <seealso cref="M:wx.Object._"/>
            <returns></returns>
        </member>
        <member name="T:WX.Globalization.CultureName">
            <summary>This class represent a normalized name of a culture like de-DE or en-GB.
             The name is composed of at most three components: Language, country, and special.
            </summary>
        </member>
        <member name="M:WX.Globalization.CultureName.#ctor(System.String,System.String,System.String)">
            <summary>A culture name specifying all three levels.
            \param lang defines the language in canonical form, e.g. "en" or "de".
            \param country define the country like "GB" or "US". Use "" as indifferent input.
            \param special is another additional specifiyer. Use "" as indifferent input.</summary>
        </member>
        <member name="M:WX.Globalization.CultureName.FromString(System.String)">
            <summary>Creates an instance from a canonical name like "de-DE" or "de_DE".</summary>
        </member>
        <member name="T:WX.Globalization.IDictionary">
            <summary>An interface for entities allwoing to translate a string.</summary>
        </member>
        <member name="M:WX.Globalization.IDictionary.GetTranslation(WX.Globalization.CultureName,System.String)">
            <summary>This will return a translation for <c>original</c> in the designated <c>culture</c>.
            </summary>
        </member>
        <member name="T:WX.Globalization.Dictionary">
            <summary>A dictionary containing translations into several languages.
            </summary>
        </member>
        <member name="M:WX.Globalization.Dictionary.#ctor(WX.Globalization.CultureName,System.String,System.String,System.String[])">
            <summary>This is a dictionary containing translation into <c>culture</c>.
            </summary>
            <param name="original">provides the original that shall be translated.</param>
            <param name="translation">is the translation into the specified culture.</param>
            <param name="pairs"> is an optional sequence of an even number of strings. The first one is an original term, the second
                   is the translation of the first, the third is an original term, the forth is the translation of the forth,
                   and so on. If this is an odd number of arugments, the last string will be silently ignored.</param>
        </member>
        <member name="M:WX.Globalization.Dictionary.Add(WX.Globalization.CultureName,System.String,System.String)">
            <summary>This will add <c>translation</c> as translation of <c>original</c> into <c>culture</c>.
            This will raise an argument exception, or <c>original</c> already is translated into <c>culture</c>.
            </summary>
            <param name="culture">The culture in which to translate.</param>
            <param name="original">The original term in the invariant culture.</param>
            <param name="translation">The translation of the original term into the specified culture.</param>
            <see cref="M:WX.Globalization.Dictionary.SetTranslation(WX.Globalization.CultureName,System.String,System.String)"/>
            <exception cref="T:System.ArgumentException">This will be thrown if this dictionary already knows a translation of the term into the specified culture.</exception>
        </member>
        <member name="M:WX.Globalization.Dictionary.AddRange(WX.Globalization.Dictionary)">
            <summary>This will add all translation of <c>alternativeTranslations</c> into this.</summary>
        </member>
        <member name="M:WX.Globalization.Dictionary.GetTranslation(WX.Globalization.CultureName,System.String)">
            <summary>Get or set a translation into the provided culture.
            Gets a translation that is specific to the provided culture  or <c>null</c> if this translation does not exist for the specified culture.
            </summary><remarks>
            Example: "reden" is "de" translation of "talk". "snacken" is a more specific translation into "de-DE-KUESTE".
            <code>
            this.GetTranslation(CultureName.FromString("de"), "talk")
            </code>
            will return "reden",
            <code>
            this.GetTranslation(CultureName.FromString("de-DE-KUESTE"), "talk")
            </code>
            will return "snacken", and
            <code>
            this.GetTranslation(CultureName.FromString("de-DE"), "talk")
            </code>
            will return <c>null</c>.
            </remarks>
            <param name="culture">Name of the culture.</param>
            <param name="original">The original term as spelled in the invariant culture.</param>
            <param name="translation">The translation of the original term into the specified culture.</param>
        </member>
        <member name="M:WX.Globalization.Dictionary.GetTranslation(System.String)">
            <summary>This will translate <c>original</c> into the current culture according to <c>System.Globalization.CultureInfo.CurrentCulture </c>.
            </summary>
        </member>
        <member name="M:WX.Globalization.Dictionary.SetTranslation(WX.Globalization.CultureName,System.String,System.String)">
            <summary>
            Defines the translation of a term in the invariant culture into another culture.
            </summary>
            <param name="culture">The culture in which to translate.</param>
            <param name="original">The original term in the invariant culture.</param>
            <param name="translation">The translation into the specified culture.</param>
            <see cref="M:WX.Globalization.Dictionary.GetTranslation(WX.Globalization.CultureName,System.String)"/>
        </member>
        <member name="M:WX.Globalization.Dictionary.Translate(WX.Globalization.CultureName,System.String)">
            <summary>Tries to translate into <c>culture</c>.
            If special culture name component is set, try to find a translation referring to the full culture name.
            If otherwise or not successful country name component is known, try to find a translation referring to language and culture.
            If failed, try to find a translation into the language as named by <c>culture</c>.
            If even this failed, return <c>null</c>.
            </summary>
            <see cref="M:WX.Globalization.Dictionary.GetTranslation(WX.Globalization.CultureName,System.String)"/>
        </member>
        <member name="T:WX.Globalization.StringInCultures">
            <summary>Instances of this classhold translations of one string.</summary>
        </member>
        <member name="M:WX.Globalization.StringInCultures.#ctor(System.String,System.String[])">
            <summary>Creates an instance comprising several translations.</summary><remarks>
                     * \param original is the original string.
                     * \param pairs is a sequence of an even number of strings. The first is the canonical name, the second is the
                     *    translation of <c>original</c> into the locale according to the first string. The third is the canonical name, the forth is the
                     *    translation of <c>original</c> into the locale according to the third string, and so on.
                     * 
                     * Example:
                     * \code
                     StringInCultures("talk", "de", "reden")
                     \endcode
                     * </remarks>
        </member>
        <member name="M:WX.Globalization.StringInCultures.GetTranslation(WX.Globalization.CultureName)">
            <summary>
            Returns the translation of the original term into the provided culture if this exists and <c>null</c> otherwise.
            </summary>
            <param name="culture">Specifies the culture in which to translate.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Globalization.StringInCultures.SetTranslation(WX.Globalization.CultureName,System.String)">
            <summary>
            This defines a translation of the term represented by this instance into the specified culture.
            </summary>
            <param name="culture">The culture of the provided translation.</param>
            <param name="translation">the translation into the specified culture.</param>
        </member>
        <member name="M:WX.Globalization.StringInCultures.Add(WX.Globalization.CultureName,System.String)">
            <summary>
            Add the provided translation to the translation managed by this instance.
            </summary>
            <param name="culture">The culture in which to translate.</param>
            <param name="translation">The translation into the specified culture.</param>
            <exception cref="T:System.ArgumentException">This instance already knows a translation into the specified culture.</exception>
        </member>
        <member name="M:WX.Globalization.StringInCultures.Translate(WX.Language)">
            <summary>Translate into the language as specified by the provided canonical language.
            If the original cannot be translated into the specified culture, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.Globalization.StringInCultures.Translate(System.String)">
            <summary>Translate into the language as specified by the provided canonical name.
            If the original cannot be translated into the specified culture, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.Globalization.StringInCultures.Translate(WX.Globalization.CultureName)">
            <summary>This returns the translation of the original string into <c>culture</c>.
            If the original cannot be translated into <c>culture</c>, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.Globalization.StringInCultures.Translate">
            <summary>This will translate into the current culture according to <c>System.Globalization.CultureInfo.CurrentCulture</c>.
            </summary>
        </member>
        <member name="P:WX.Globalization.StringInCultures.DefaultTranslation">
            <summary>This instance holds the default translation of this string.</summary>
        </member>
        <member name="P:WX.Globalization.StringInCultures.Cultures">
            <summary>This instance holds translations into this cultures.</summary>
        </member>
        <member name="T:WX.Globalization.TypeNameTranslationsAttribute">
            <summary>Use this attribute to provide translations of a class or type name using reflection.
            These names will for instance be used by <c>wx.Object._(Type)</c>.
            </summary>
        </member>
        <member name="M:WX.Globalization.TypeNameTranslationsAttribute.#ctor(WX.Globalization.StringInCultures)">
            <summary>Argument is the name of the type in neutral representation and arbitrary translations.</summary>
        </member>
        <member name="M:WX.Globalization.TypeNameTranslationsAttribute.#ctor(System.String,System.String[])">
            <summary>Creates an instance comprising several translations.</summary><remarks>
                     * \param neutralName is the name in the neutral locale.
                     * \param sequenceOfLocaleTranslationPairs is a sequence of an even number of strings. The first is the canonical name, the second is the
                     *    translation of <c>original</c> into the locale according to the first string. The third is the canonical name, the forth is the
                     *    translation of <c>original</c> into the locale according to the third string, and so on.
                     * 
                     * Example:
                     * \code
                     [TypeNameTranslationsAttribute("Employee", "de", "Mitarbeiter")]
                     class EmployeeDate
                     {
                        ...
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:WX.Globalization.TypeNameTranslationsAttribute.Name">
            <summary>Readonly access to the human readable name of the class or type and its translations.</summary>
        </member>
        <member name="P:WX.Globalization.TypeNameTranslationsAttribute.NeutralName">
            <summary>
            The default translation of the entity is the name in the neutral culture.
            </summary>
        </member>
        <member name="T:WX.Globalization.EnumValueTranslationsAttribute">
            <summary>Use this class to amend enumerations with translations of their value.</summary>
                 * <remarks>
                 * These translations will for instance be used by <c>wx.Object._(Enum)</c>.
                 * Example:
                 \code
                 [EnumValueTranslations(80, "Times")]
                 [EnumValueTranslations(81, "Sans Serif")]
                 [EnumValueTranslations(90, "True Type", "de", "Schreibmaschine")]
                 [EnumValueTranslations(91, "Courier", "de", "Kurier")]
                 enum FontFamily
                 {
                    Times=80,
                    SansSerif,
                    TrueType=90,
                    Courier,
                 }
                 \endcode
                 * The translation refers to the enumeration using the value. This class assumes <c>int</c>
                 * values.
                 * </remarks>
        </member>
        <member name="M:WX.Globalization.EnumValueTranslationsAttribute.#ctor(System.Int32,System.String,System.String[])">
            <summary>Defines a neutral name and translations for an enumeration value.</summary>
            <param name="enumIntValue"> designates the enumeration value providing its cast to <c>int</c>. </param>
            <param name="neutral"> is a neutral name that will be used when translating into unknown languages.</param>
            <param name="sequenceOfLocaleTranslationPairs"> is a sequence of pairs of canonical locale names and translations.</param>
        </member>
        <member name="P:WX.Globalization.EnumValueTranslationsAttribute.Name">
            <summary>Readonly access to the human readable name of the class or type and its translations.</summary>
        </member>
        <member name="P:WX.Globalization.EnumValueTranslationsAttribute.NeutralName">
            <summary>
            The default translation of the enumeration value is the name in the invariant culture.
            </summary>
        </member>
        <member name="T:WX.Globalization.PotWriter">
            <summary>
            Class to write POT entries. This class provides a text writer like interface to write 
            POT entries. You may create a file providing a file name to the ctor. This file will be created
            including a POT header in UTF-8 character coding. All internal streams will be closed on
            dispose.
            </summary>
        </member>
        <member name="M:WX.Globalization.PotWriter.#ctor(System.String)">
            <summary>
            Creates an instance that will open a file of the provided name.
            If the extension of the provided name is neither .po nor .pot, this will
            add esxtension .pot.
            </summary>
            <param name="potFileName"></param>
        </member>
        <member name="M:WX.Globalization.PotWriter.WriteHeader">
            <summary>
            This will write the header information.
            </summary>
        </member>
        <member name="M:WX.Globalization.PotWriter.WriteEntry(System.String,System.String,System.String)">
            <summary>
            Creates a new entry. If the provided key has already been used, this will return false.
            </summary>
            <param name="key">The key that will be used to identify the translation.</param>
            <param name="translation">The translation.</param>
            <param name="remark">An optional remark (use empty string if not needed). Provide a text that
            can help translator. This text will be visible in poEdit.</param>
            <returns></returns>
        </member>
        <member name="T:WX.Globalization.ExtractTranslationsOfTypesAndEnumValues">
            <summary>
            Looks for the attributes EnumValueTranslationsAttribute in TypeNameTranslationsAttribute in one
            or more assemblies and creates GetText entries in a POTWriter that can be used to provide translations
            for marked classes and enumeration constants.
            </summary>
        </member>
        <member name="M:WX.Globalization.ExtractTranslationsOfTypesAndEnumValues.ExtractTranslationsOfType(WX.Globalization.PotWriter,System.Reflection.Assembly)">
            <summary>
            Extract enumeration constants and tpye name that shall be translated and creates corresponding
            PO entries in the POT file writer.
            </summary>
            <param name="writer">The new entries will be written into this stream.</param>
            <param name="assemblyWhereToExtractTypeNamesAndEnumerationsFrom">Extract type names and enumerations that shall be translated from this assembly.</param>
        </member>
        <member name="M:WX.Globalization.ExtractTranslationsOfTypesAndEnumValues.ExtractTranslationsOfType(System.Reflection.Assembly)">
            <summary>
            This method will create a POT file using the base name of the code base file of the assembly.
            Thus, translations of wx.PackageBuilder.exe will be stored in ex.PackageBuilder.pot.
            </summary>
            <param name="assemblyWhereToExtractTypeNamesAndEnumerationsFrom">Extract type names and enumerations that shall be translated from this assembly.</param>
        </member>
        <member name="T:WX.Html.Help.HtmlBookRecord">
            <summary>Instances of this class represent hyper text books to be read from a file system.
             Refer to class HtmlHelpData.
             Instances of this class shall never be generated by the user.  WX.Net generates
             them if necessary. All instances will be deleted virtually by their containers.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlBookRecord.GetFullPath(WX.wxString)">
            <summary>Returns full filename of <c>page</c> (which is part of the book),
             i.e. with book's <c>BasePath</c> prepended. If page is already absolute
             path, <c>BasePath</c> is  not prepended.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlBookRecord.Title">
            <summary>Get and Set the title.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlBookRecord.Start">
            <summary>Get and set the start.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlBookRecord.BasePath">
            <summary>Get and set the base path.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlBookRecord.ContentsStart">
            <summary>Use SetContentsRange() to set this property.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlBookRecord.ContentsEnd">
            <summary>Use SetContentsRange() to set this property.
            </summary>
        </member>
        <member name="T:WX.Html.Help.IConstList">
            <summary>A simple interface characterizing constant lists.
            This interface IList declares a subset of the methods of IList.</summary>
        </member>
        <member name="T:WX.Html.Help.ConstListIterator">
            <summary>A simple enumerator for read-only instances of IList.
            This simply iterates incrementing an index.</summary>
        </member>
        <member name="T:WX.Html.Help.HtmlBookRecords">
            <summary>This is simply a collection of instance of HtmlBookRecord.
             This is a particular class for some technical reasons.
             Avoid to use empty arrays of this kind.
             
             As wx.HtmlBookRecord, this is a const class that does not allow
             to modify the value.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlBookRecords.#ctor(System.IntPtr)">
            <summary>Instances of this type will typically generated by Object.FindObject().
             Reason: Instances of this class appear as output of a selector of HtmlHelpData.
             
             Although an implementor of IList, this class does not support making changes
             (adding or removing items).
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlBookRecords.HasFile(System.String)">
            <summary>Returns <c>true</c> iff this set of bookmarks contains an entry of the provided file.</summary>
        </member>
        <member name="M:WX.Html.Help.HtmlBookRecords.FindPage(System.String)">
            <summary>Finds the index of the provided page (URL) in the list of bookmarks.
            This will return -1 if the provided page does not have a bookmark.</summary>
        </member>
        <member name="T:WX.Html.Help.HtmlHelpDataItem">
            <summary>Instances of this class are used to represent items of content or index.
             Refer to class HtmlHelpData.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpDataItem.Name">
            <summary>The name of the item.
             Remark on the implementation: This method currently always returns the same instance.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpDataItem.Page">
            <summary>The page containing this item.
             Remark on the implementation: This method currently always returns the same instance.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpDataItem.FullPath">
            <summary>The full path of the page containing this item.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpDataItem.IndentedName">
            <summary>Returns the item's name indented with spaces (if it has level larger than 1, the first level).
            </summary>
        </member>
        <member name="T:WX.Html.Help.HtmlHelpDataItems">
            <summary>This is simply a collection of instance of HtmlHelpDataItem.
             This is a particular class for some technical reasons.
             Avoid to use empty arrays of this kind.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpDataItems.#ctor(System.IntPtr,System.Boolean)">
            <summary>Instances of this type will be copied on generation.
             Although an implementor of IList, this class does not support making changes
             (adding or removing items).
            </summary>
        </member>
        <member name="T:WX.Html.Help.HtmlSearchStatus">
            <summary>State information of a search action.
             Note: This is about searching for pages containing a particular
             text rather than searching a single page.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlSearchStatus.#ctor(WX.Html.Help.HtmlHelpData,System.String,System.Boolean,System.Boolean)">
            <summary>Constructor: Supply HtmlHelpData instance, the keyword and (optionally) the title of the book to search.
             By default, all books are searched.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlSearchStatus.#ctor(WX.Html.Help.HtmlHelpData,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>Constructor: Supply HtmlHelpData instance, the keyword and (optionally) the title of the book to search.
             By default, all books are searched.
            </summary>
        </member>
        <member name="M:WX.Html.Help.HtmlSearchStatus.Search">
            <summary>do the next iteration.</summary>
        </member>
        <member name="T:WX.Html.Help.HtmlHelpData">
            <summary>This class represents the content of a help controller.
             This class is required for all alternative implementations of HTB-browsers (extending HtmlHelpController).
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:WX.Html.Help.HtmlHelpData.SetTempDir(System.String)" ignoriert -->
        <member name="M:WX.Html.Help.HtmlHelpData.AddBook(System.String)">
            <summary>Adds new book. <c>book</c> is the location (filename) of an <c>.htb</c> file (stands for "html book").
            See documentation for details. The  wxWidgets documentation claims <c>book</c> to be
            a URL. Do not take this too serious. This means a URL in the sence of  wxWidget's file
            handlers. Consider the following example running with 2.6.4:
            <list type="bullet">
            <item> <c> @"c:\\directory\file.htb"</c> is not a URL but will work.</item>
            <item> <c> @"file:///directory/file.htb"</c> is a URL but will fail.</item>
            </list>
            Returns success.</summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpData.FindPageByName(System.String)">
            <summary>returns URL of page on basis of (file)name</summary>
        </member>
        <member name="M:WX.Html.Help.HtmlHelpData.FindPageById(System.Int32)">
            <summary>returns URL of page on basis of MS id</summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpData.BookRecords">
            <summary>Public read-only property to get an array of descriptors for contained books.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpData.BookRecordsCount">
            <summary>Number of included books.</summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpData.ContentsCount">
            <summary>Number of content items.</summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpData.ContentsArray">
            <summary>Public read-only property to get an array of descriptors for items of the table of contents.
            </summary>
        </member>
        <member name="P:WX.Html.Help.HtmlHelpData.IndexArray">
            <summary>Public read-only property to get an array of descriptors for items of the index.
            </summary>
        </member>
        <member name="T:WX.StockCursor">
            <summary>
            ID of builtin cursors.
            </summary>
            <see cref="T:WX.Cursor"/>
        </member>
        <member name="F:WX.StockCursor.MOVEHORIZONTALLINE">
            <summary>
            Extra cursor in WX.Net used by the extended grid control.
            </summary>
        </member>
        <member name="F:WX.StockCursor.MOVEVERTICALLINE">
            <summary>
            Extra cursor in WX.Net used by the extended grid control.
            </summary>
        </member>
        <member name="T:WX.Cursor">
            <summary>
            A cursor is a small bitmap usually used for denoting where the mouse pointer is, with a picture that
            might indicate the interpretation of a mouse click. As with icons, cursors in X and MS Windows are
            created in a different manner. Therefore, separate cursors will be created for the different
            environments. Platform-specific methods for creating a wxCursor object are catered for, and this
            is an occasion where conditional compilation will probably be required (see wxIcon for an example).
            </summary>
            <remarks>
            A single cursor object may be used in many windows (any subwindow type). The WX.Net convention is to
            set the cursor for a window, as in X, rather than to set it globally as in MS Windows.
            </remarks>
        </member>
        <member name="M:WX.Cursor.SafeNew(System.IntPtr)">
            <summary>
            A CTor that creates a <c>null</c> if the arg is a IntPtr.Zero.
            </summary>
            <param name="arg">Native cursor pointer.</param>
        </member>
        <member name="M:WX.Cursor.#ctor(WX.Image)">
            <summary>
            Constructs a cursor from a wxImage. If the cursor is monochrome on the current platform, colors with the RGB elements all greater than 127 will be foreground, colors less than this will be background. The mask (if any) will be used to specify the transparent area.
            
            In wxMSW the foreground will be white and the background black. If the cursor is larger than 32x32 it is resized.
            
            In wxGTK, colour cursors and alpha channel are supported (starting from GTK+ 2.2). Otherwise the two most frequent colors will be used for foreground and background. In any case, the cursor will be displayed at the size of the image.
            
            In wxMac, if the cursor is larger than 16x16 it is resized and currently only shown as black/white (mask respected).
            </summary>
            <param name="image">The image that will be displayed as a mouse cursor.</param>
        </member>
        <member name="T:WX.WizardEvent">
            <summary>wx.WizardEvent class represents an event generated by the wizard:
            this event is first sent to the page itself and, if not processed there, goes up the window hierarchy as usual.
            
            \li <c>EVT_WIZARD_PAGE_CHANGED(id</c>, func)  The page has been just changed (this event can not be vetoed).  
            \li <c>EVT_WIZARD_PAGE_CHANGING(id</c>, func)  The page is being changed (this event can be vetoed).  
            \li <c>EVT_WIZARD_CANCEL(id</c>, func)  The user attempted to cancel the wizard (this event may also be vetoed).  
            \li <c>EVT_WIZARD_HELP(id</c>, func)  The wizard help button was pressed.  
            \li <c>EVT_WIZARD_FINISHED(id</c>, func)  The wizard finished button was pressed</summary>
        </member>
        <member name="M:WX.WizardEvent.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="P:WX.WizardEvent.Direction">
            <summary>Return the direction in which the page is changing:
            for <c>EVT_WIZARD_PAGE_CHANGING</c>, return true if we're going forward or false otherwise and for
            <c>EVT_WIZARD_PAGE_CHANGED</c> return true if we came from the previous page and false if we returned from the next one.</summary>
        </member>
        <member name="P:WX.WizardEvent.Page">
            <summary>Returns the wx.WizardPage which was active when this event was generated.</summary>
        </member>
        <member name="F:WX.WindowVariant.wxWINDOW_VARIANT_NORMAL">
            <summary>Normal size</summary>
        </member>
        <member name="F:WX.WindowVariant.wxWINDOW_VARIANT_SMALL">
            <summary>Smaller size (about 25 % smaller than normal)</summary>
        </member>
        <member name="F:WX.WindowVariant.wxWINDOW_VARIANT_MINI">
            <summary>Mini size (about 33 % smaller than normal)</summary>
        </member>
        <member name="F:WX.WindowVariant.wxWINDOW_VARIANT_LARGE">
            <summary>Large size (about 25 % larger than normal)</summary>
        </member>
        <member name="T:WX.BackgroundStyle">
            <summary>The background style indicates whether background colour
            should be determined by the system (System),
            be set to a specific colour (Colour),
            or should be left to the application to implement (Custom).</summary>
        </member>
        <member name="F:WX.BackgroundStyle.System">
            <summary>
            Background is fully defined by the system (themes, etc.).
            </summary>
        </member>
        <member name="F:WX.BackgroundStyle.Colour">
            <summary>
            Background colour is defined by the corresponding property of the window.
            </summary>
        </member>
        <member name="F:WX.BackgroundStyle.Custom">
            <summary>
            Background will be painted by this window. This mode enables the implementation of
            flicker free background painting.
            </summary>
        </member>
        <member name="M:WX.Utils.Exit">
            <summary>Exits application after calling wx.App.OnExit().
            Should only be used in an emergency: normally the top-level frame should be deleted (after deleting all
            other frames) to terminate the application. See wx.CloseEvent and wx.App.</summary>
        </member>
        <member name="M:WX.Utils.wxSleep(System.Int32)">
            <summary>
            Sleeps for the specified number of seconds.
            This is deprecated. Use System.Threading.Thread.Sleep() instead.
            </summary>
            <param name="num">Number of seconds to sleep.</param>
        </member>
        <member name="M:WX.Utils.wxYield">
             <summary>
             Calls wx.App.Yield.
            
             This function is kept only for backwards compatibility. Please use the wx.App.Yield method instead in any new code.
             </summary>
        </member>
        <member name="T:WX.BusyInfo">
            <summary>
            This class makes it easy to tell your user that the program is temporarily busy. Just create a wx.BusyInfo object
            within a <c>using</c> scope block, a message window will be shown.
            </summary>
            <remarks>
            For example:
            <code>
            using (wx.BusyInfo wait=new wx.BusyInfo("Please wait, working..."))
            {
              for (int i = 0; i &lt; 100000; i++)
              {
                DoACalculation();
              }
            </code>
            It works by creating a window in the constructor, and deleting it in the destructor (on dispose).
            You may also want to call wx.App.TheApp.Yield() to refresh the window periodically (in case it had been obscured
            by other windows, for example) like this:
            
            <code>
            using (wx.BusyInfo wait=new wx.BusyInfo("Please wait, working..."))
            {
              for (int i = 0; i &lt; 100000; i++)
              {
                DoACalculation();
                if ( !(i &amp; 1000) )
                   wx.App.TheApp.SafeYield();
              }
            }
            </code>
            but take care to not cause undesirable reentrancies when doing it (see wx.App.Yield() for more details).
            </remarks>
            <seealso cref="!:wx.App.Yield"/>
        </member>
        <member name="M:WX.BusyInfo.#ctor(System.String)">
            <summary>
            Constructs a busy info window as child of parent and displays msg in it.
            </summary>
            <param name="message">The message that will be shown while active.</param>
        </member>
        <member name="M:WX.BusyInfo.#ctor(System.String,WX.Window)">
             <summary>
             Constructs a busy info window as child of parent and displays msg in it.
            
             NB: If parent is not NULL you must ensure that it is not closed while the busy info is shown.
             </summary>
             <param name="message">The message that will be shown while active.</param>
        </member>
        <member name="M:WX.BusyInfo.#ctor(WX.wxString,WX.Window)">
             <summary>
             Constructs a busy info window as child of parent and displays msg in it.
            
             NB: If parent is not NULL you must ensure that it is not closed while the busy info is shown.
             </summary>
             <param name="message">The message that will be shown while active.</param>
        </member>
        <member name="T:WX.DirSelector">
            <summary>
             Pops up a directory selector dialog. The arguments have the same meaning as those of wx.DirDialog.DirDialog().
             The message is displayed at the top, and the default_path, if specified, is set as the initial selection.
            
             The application must check for an empty return value (if the user pressed Cancel).
            
             </summary>
             <remarks>
              For example:
             <code>
             string dir = new wx.DirSelector("Choose a folder").Value;
             if ( !dir.empty() )
             {
               ...
             }
             </code>
             </remarks>
        </member>
        <member name="M:WX.DirSelector.#ctor">
            <summary>
            Starts an instance with message string _("Select a file").
            </summary>
        </member>
        <member name="M:WX.DirSelector.#ctor(System.String)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
        </member>
        <member name="M:WX.DirSelector.#ctor(System.String,System.String)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
        </member>
        <member name="M:WX.DirSelector.#ctor(System.String,System.String,WX.WindowStyles)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="message">Message string</param>
            <param name="flags">The window styles</param>
        </member>
        <member name="M:WX.DirSelector.#ctor(System.String,System.String,WX.WindowStyles,WX.Window)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.DirSelector.#ctor(System.String,System.String,WX.WindowStyles,WX.Window,System.Drawing.Point)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
        </member>
        <member name="M:WX.DirSelector.#ctor(WX.wxString,WX.wxString,WX.WindowStyles,WX.Window,System.Int32,System.Int32)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="x">The x-coordinate of this dialog</param>
            <param name="y">The y-coordinate of this dialog</param>
        </member>
        <member name="P:WX.DirSelector.Value">
            <summary>
            the selected file or the empty string if the user cancelled the input.
            This, use something like the following to deal with cancelations.
            <code>
            string result=new DirSelector(..).Value;
            if (result.Length == 0)
                return; // cancelled input.
            </code>
            </summary>
        </member>
        <member name="T:WX.FileSelector">
            <summary>Asks for a file name opening a file selector dialog.
             Especially relevant flags (on wx.WindowStyles) start with prefix FD_.
             </summary>
             <remarks>
             Pops up a file selector box. In Windows, this is the common file selector dialog. In X, this is a file selector
             box with the same functionality. The path and filename are distinct elements of a full file pathname. If path
             is empty, the current directory will be used. If filename is empty, no default filename will be supplied.
             The wildcard determines what files are displayed in the file selector, and file extension supplies a type extension
             for the required filename. Flags may be a combination of wx.WindowStyles.FileDlgOpen, wx.WindowStyles.FileDlgSave,
             wx.WindowStyles.FileDlgOverwritePrompt, or wx.WindowStyles.FileDlgFileMustExist. Note that .wx.WindowStyles.FD_MULTIPLE
             can only be used with wx.FileDialog and not here as this function only returns a single file name.
            
             Both the Unix and Windows versions implement a wildcard filter. Typing a filename containing wildcards (*, ?) in 
             the filename text item, and clicking on Ok, will result in only those files matching the pattern being displayed.
            
             The wildcard may be a specification for multiple types of file with a description for each, such as:
             <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.
            
             The application must check for an empty return value (the user pressed Cancel). For example:
             <code>
             wxString filename = wxFileSelector("Choose a file to open");
             if ( !filename.empty() )
             {
                 // work with the file
                 ...
             }
             //else: cancelled by user
             </code>
             </remarks>
             <seealso cref="T:WX.DirSelector"/>
        </member>
        <member name="M:WX.FileSelector.#ctor">
            <summary>
            Starts an instance with message string _("Select a file").
            </summary>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles,WX.Window)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles,WX.Window,System.Drawing.Point)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
        </member>
        <member name="M:WX.FileSelector.#ctor(WX.wxString,WX.wxString,WX.wxString,WX.wxString,WX.wxString,WX.WindowStyles,WX.Window,System.Int32,System.Int32)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="x">The x-coordinate of this dialog</param>
            <param name="y">The y-coordinate of this dialog</param>
        </member>
        <member name="M:WX.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:WX.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:WX.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles,WX.Window)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:WX.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,WX.WindowStyles,WX.Window,System.Drawing.Point)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="P:WX.FileSelector.Value">
            <summary>
            the selected file or the empty string if the user cancelled the input.
            This, use something like the following to deal with cancelations.
            <code>
            string result=fileselector.Value;
            if (result.Length == 0)
                return; // cancelled input.
            </code>
            </summary>
        </member>
        <member name="T:WX.ByteBuffer">
            <summary>This is an internal class representing a byte buffer.
             This class is applied sometimes when <c>wxWidgets</c> expects a void* buffer.
            </summary>
        </member>
        <member name="M:WX.ByteBuffer.#ctor(System.Int32)">
            <summary>Generates an instance capable of holding at most <c>size</c> bytes.
            </summary>
        </member>
        <member name="M:WX.ByteBuffer.#ctor(System.IntPtr,WX.Object.StorageMode,System.Boolean)">
            <summary>This is a CTor where callers can set memOwn. 
            This is for the construction of temporarily needed wrappers.
            </summary>
            <param name="cInstance">Pointer to the native instance of the byte buffer</param>
            <param name="memOwn">True iff the native buffer shall be destroyed on disposing this</param>
            <param name="mode">You can switch here whether the instance of this wrapper shall be registered or not.
            Please keep in mind, that each native instance must have at most one wrapper. So, if the native instance
            may be returned by some other function calls, you should register in order to prevent WX.Net from
            creating two or more wrappers of the same C++ data.</param>
        </member>
        <member name="M:WX.ByteBuffer.SafeNew(System.Byte[])">
            <summary>Creates an instance copying the data from <c>bytes</c> or resturns <c>null</c> in case of argument <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.ByteBuffer.Reserve(System.Int32)">
            <summary>
            Reserves the specified amount of bytes in the buffer.
            This removes all preexisting content. The number of filled bytes will be resetted.
            </summary>
            <param name="newsize">The numbe of bytes that shall be reserved.</param>
            <returns>The number of bytes reserved by this instance after this call.</returns>
        </member>
        <member name="P:WX.ByteBuffer.Item(System.Int32)">
            <summary>Generates the filled byte at the provided index or 0 if the index is too large.</summary>
        </member>
        <member name="P:WX.ByteBuffer.SizeReserved">
            <summary>This is the number of bytes that can be stored within this index.</summary>
        </member>
        <member name="P:WX.ByteBuffer.SizeFilled">
            <summary>This is the number of bytes that have been written into this instance.</summary>
        </member>
        <member name="P:WX.ByteBuffer.Data">
            <summary>
            Get or set the encapsulated data. The getter will crreate a new instance on every call.
            </summary>
        </member>
        <member name="P:WX.ByteBuffer.PtrToBuffer">
            <summary>Returns a pointer to the internally represented <c>char</c>[] buffer.
            Please note, that this buffer is not terminated by a 0.</summary>
        </member>
        <member name="T:WX.IntBuffer">
            <summary>
            This wrapps a native int[] array.
            </summary>
        </member>
        <member name="P:WX.IntBuffer.CArrayPtr">
            <summary>
            Gets the pointer to the native C/C++ array.
            </summary>
        </member>
        <member name="T:WX.ArrayInt">
            <summary>Wrapper around the  wxWidgets array of integer numbers.</summary>
        </member>
        <member name="M:WX.ArrayInt.SafeNew(System.IntPtr)">
            <summary>Creates a new ArrayInt. However, if <c>ptr</c> is <c>IntPtr.Zer</c>, then the result is <c>null</c>.</summary>
        </member>
        <member name="M:WX.ArrayInt.Alloc(System.Int32)">
            <summary>
            Preallocates a number of elements.
            </summary>
            <param name="n">The number of elements that will probably have to be stored.</param>
        </member>
        <member name="T:WX.ArrayIntPtr">
            <summary>This is a wrapper for a simple <c>void**</c> array.
            This will be used for instance to pass client data to choice dialogs.</summary>
        </member>
        <member name="T:WX.ArrayString">
            <summary>A wrapper for  wxWidgets arrays of string.
            This is used for internal purposes. However, just like wxString this has been
            left public to allow extreme non-functional optimizations reducing conversions
            between arrays of .NET strings and this.</summary>
        </member>
        <member name="M:WX.ArrayString.#ctor(System.Collections.IEnumerable)">
            <summary>Generates an instance comprising the items of the argument.
            All items of the argument shall be strings. Otherwise, this method
            will throw an dynamic type error.
            The argument may also be <c>null</c>. In this case, this is equivalent to
            the default constructor (generate an instance of size 0).</summary>
        </member>
        <member name="M:WX.ArrayString.SafeNewFrom(System.Collections.IEnumerable)">
            <summary>This is a safe alternative for the corresponding CTor.
            Safe means here: If the argument is <c>null</c>, the result is also <c>null</c> without
            any exceptions.</summary>
        </member>
        <member name="M:WX.ArrayString.Sort(System.Boolean)">
            <summary>Sorts the entry (optionally in reversed order).
            </summary>
        </member>
        <member name="M:WX.ArrayString.Add(System.Collections.IEnumerable)">
            <summary>This will add the elements of the collection.
             This will throw an exception of the collection contains non-strings.
            </summary>
        </member>
        <member name="M:WX.ArrayString.Index(System.String)">
            <summary>This will return the first index of string <c>lookForThisEntry</c> or -1 is this string is not in the array.</summary>
        </member>
        <member name="M:WX.ArrayString.Index(WX.wxString,System.Boolean,System.Boolean)">
            <summary>Search the element in the array, starting from the beginning if <c>bFromEnd</c> is false or from end otherwise.
             If <c>bCase</c>, comparison is case sensitive (default), otherwise the case is ignored.
            
             This function uses linear search for <c>ArrayString</c> and binary search for <c>SortedArrayString</c>,
             but it ignores the <c>bCase</c> and <c>bFromEnd</c> parameters in the latter case.
            
             Returns index of the first item matched or -1 if there is no match.
            </summary>
        </member>
        <member name="P:WX.ArrayString.Item(System.Int32)">
            <summary>Access string <c>num</c> of the array.
             Will cause an assert error on illegal indices.
            </summary>
        </member>
        <member name="T:WX.wxSize">
            <summary>This will produce or wrap a <c>wxSize</c> object.
            Use instances of this class, to pass <c>wxSize</c> objects to the C DLL.</summary>
        </member>
        <member name="M:WX.wxSize.#ctor(System.Drawing.Size)">
            <summary>Convert an instance from a C# standard size.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:WX.wxSize.SafeNew(System.Drawing.Size)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:WX.wxRect">
            <summary>This will produce or wrap instances of  wxWidgets <c>wxRect</c>.
            Never use <c>System.Drawing.Rectangle</c> with <c>wx-c.dll</c>. Always rely to instances of this class instead.
            </summary>
        </member>
        <member name="M:WX.wxRect.#ctor(System.Drawing.Rectangle)">
            <summary>Convert an instance from a C# standard rectangle.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:WX.wxRect.SafeNew(System.Drawing.Rectangle)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:WX.wxPoint">
            <summary>This will produce or wrap instances of  wxWidgets <c>wxPoint</c>.
            Never use <c>System.Drawing.Point</c> with <c>wx-c.dll</c>. Always rely to instances of this class instead.
            </summary>
        </member>
        <member name="M:WX.wxPoint.#ctor(System.Drawing.Point)">
            <summary>Convert an instance from a C# standard rectangle.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:WX.wxPoint.SafeNew(System.Drawing.Point)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:WX.StatusBar">
            <summary>Class for the status bar.
            Style flags (cf. wx.WindowStyles) of static  texts (starting with ST_) and status bars
            (starting with SB_) apply to this class of windows.</summary>
        </member>
        <member name="T:WX.Language">
            <summary>
            Enumeration of langiages.
            </summary>
        </member>
        <member name="F:WX.Language.wxLANGUAGE_Default">
            <summary>
            user's default language as obtained from the operating system 
            </summary>
        </member>
        <member name="F:WX.Language.wxLANGUAGE_UNKNOWN">
            <summary>
            returned by Locale.GetSystemLanguage() if it fails to detect the default language 
            </summary>
        </member>
        <member name="T:WX.LocaleInitFlags">
            <summary>Flags for initializing instances of Locale.
            Please note that wxLOCALE_CONV_ENCODING() shall be avoided on unicode builds.</summary>
            
        </member>
        <member name="F:WX.LocaleInitFlags.wxLOCALE_LOAD_Default">
            <summary>Load the message catalog for the given locale containing the translations of standard wxWidgets messages automatically.</summary>
        </member>
        <member name="F:WX.LocaleInitFlags.wxLOCALE_CONV_ENCODING">
            <summary>This will cause wxWidgets to convert all imported
            catalogs into the current standard encoding (like western-1259-1).
            Since this is always wrong on unicode builds, this flag will silently
            be ignored then.</summary>
        </member>
        <member name="T:WX.Locale">
            <summary>This class wrapps <c>wxLocale</c>.</summary>
        </member>
        <member name="M:WX.Locale.Init">
            <summary>
            Initializes this locale with the users default language as obtained from the operating system.
            </summary>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:WX.Locale.Init(WX.Language)">
            <summary>
            Initializes this locale with the provided language.
            </summary>
            <param name="language">Language to be used for translation.</param>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:WX.Locale.Init(WX.Language,WX.LocaleInitFlags)">
            <summary>
            Initializes this locale with the provided language.
            </summary>
            <param name="language">Language to be used for translation.</param>
            <param name="flags">Flags</param>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:WX.Locale.AddCatalog(System.String)">
            <summary>Add a catalog for use with the current locale: it is searched for in standard places
             (current directory first, then the system one), but you may also prepend additional directories
             to the search path with AddCatalogLookupPathPrefix().</summary>
             <remarks> All loaded catalogs will be used for message lookup by GetString() for the current locale.
            
             Returns true if catalog was successfully loaded, false otherwise (which might mean that the catalog is not
             found or that it isn't in the correct format).
             </remarks>
             <param name="szDomain">Descriptor of the domain that is covered by the requested catalog, i.e. the basename
              of the catalog file.</param>
        </member>
        <member name="M:WX.Locale.AddCatalog(System.String,WX.Language,System.String)">
            <summary>Add a catalog for use with the current locale: it is searched for in standard places
             (current directory first, then the system one), but you may also prepend additional directories
             to the search path with AddCatalogLookupPathPrefix().</summary>
             <remarks> All loaded catalogs will be used for message lookup by GetString() for the current locale.
            
             Returns true if catalog was successfully loaded, false otherwise (which might mean that the catalog is not
             found or that it isn't in the correct format).
             </remarks>
             <param name="szDomain">Descriptor of the domain that is covered by the requested catalog, i.e. the basename
              of the catalog file.</param>
              <param name="msgIdLanguage">The target language of translations from this catalog.</param>
              <param name="msgIdCharset">msgIdCharset lets you specify the charset used for msgids in sources in case they use
              8-bit characters (e.g. German or French strings). This argument has no effect in Unicode build, because literals
              in sources are Unicode strings; you have to use compiler-specific method of setting the right charset when
              compiling with Unicode.</param>
        </member>
        <member name="M:WX.Locale.AddCatalogLookupPathPrefix(System.String)">
             <summary>
             Add a prefix to the catalog lookup path: the message catalog files will be looked up under
             prefix/(CANONICAL_LANGUAGE_STRING)/LC_MESSAGES, prefix/(CANONICAL_LANGUAGE_STRING) and prefix (in this order).
            
             This only applies to subsequent invocations of AddCatalog().
             </summary>
             <param name="prefix">New prefix directories where to search for language catalogs.</param>
        </member>
        <member name="M:WX.Locale.GetLanguageInfo(WX.Language)">
            <summary>
            Information struct on the language as designated by the argument.
            </summary>
            <param name="lang">The language designator. Language.wxLANGUAGE_Default will
            be replaced by the system language.
            </param>
            <returns>Language information</returns>
        </member>
        <member name="M:WX.Locale.GetLanguageName(WX.Language)">
            <summary>
            Long name of the language as designated by the argument (e.g. "German").
            </summary>
            <param name="lang">The language designator. Language.wxLANGUAGE_Default will
            be replaced by the system language.
            </param>
            <returns>Language information</returns>
        </member>
        <member name="P:WX.Locale.CanonicalName">
            <summary>
            Canonical name of the language that is used by this locale. Examples: "en", "de-de".
            </summary>
        </member>
        <member name="P:WX.Locale.SystemEncodingName">
             <summary>
             Tries to detect the name of the user's default font encoding.
             This string isn't particularly useful for the application as its form is platform-dependent and so you
             should probably use GetSystemEncoding() instead.
            
             Returns a user-readable string value or an empty string if it couldn't be determined.
             </summary>
        </member>
        <member name="P:WX.Locale.SystemLanguage">
            <summary>
            Tries to detect the user's default language setting.
            Returns wxLanguage.LANGUAGE_UNKNOWN if the language-guessing algorithm failed.
            </summary>
        </member>
        <member name="T:WX.Graph.View.INodeAppearance">
            <summary>
            Implementors of this interface provide the data that will be used to display graph nodes.
            </summary>
        </member>
        <member name="M:WX.Graph.View.INodeAppearance.GetSize(WX.DC,WX.ImageList)">
            <summary>
            The size of the node. 
            Layout algorithms will reserve free space of this size.
            </summary>
            <param name="dc">The device context that shall display the node. Use this context to determine
            text sizes.</param>
            <param name="images">The list of images that is available to display nodes. This can be <c>null</c> if not available.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Graph.View.INodeAppearance.Draw(WX.DC,WX.ImageList,System.Drawing.Point)">
            <summary>
            This will be called to draw the node.
            </summary>
            <param name="dc">The device context that shall display the node</param>
            <param name="pos">The upper left position of the free space that has been reserved by the layout algorithm.</param>
            <param name="images">The list of images that is available to display nodes. This can be <c>null</c> if not available.</param>
        </member>
        <member name="M:WX.Graph.View.INodeAppearance.GetDockingPoints(System.Drawing.Point)">
            <summary>
            If drawn by Draw() at the provided position, this returns a collection of positions that can be used
            as start or end of drawn edges.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="E:WX.Graph.View.INodeAppearance.OnChange">
            <summary>
            Call this if something changed. The graph views will update
            the display of this node.
            </summary>
        </member>
        <member name="T:WX.Graph.View.LabelledNode">
            <summary>
            Use In
            </summary>
        </member>
        <member name="M:WX.Graph.View.LabelledNode.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new instance that will display the provided text label.
            </summary>
            <param name="label">The text label that shall be displayed</param>
        </member>
        <member name="M:WX.Graph.View.LabelledNode.#ctor(System.String,System.Int32,WX.Direction)">
            <summary>
            Creates a new instance that will display a text label and an image from an image list.
            </summary>
            <param name="label">The text label. If this is empty, the node will be </param>
            <param name="imageIndex">The index of the image that shall be displayed.</param>
            <param name="direction">The direction defines, whether the label shall be displayd above, below, on the left, or on the right side of the image.</param>
        </member>
        <member name="M:WX.Graph.View.LabelledNode.GetDockingPoints(System.Drawing.Point)">
            <summary>
            If drawn by Draw() at the provided position, this returns a collection of positions that can be used
            as start or end of drawn edges.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.Label">
            <summary>
            Get or set the label.
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.ImageIndex">
            <summary>
            Get or set the index of the image that shall be displayed. If this is -1, no image will be displayed.
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.DrawBorderBox">
            <summary>
            Set or get a Boolean flag that is true iff the graph node shall be surrounded by a box.
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.Padding">
            <summary>
            Defines a number of pixels that shall be left blank between image and label (if both are given) and between
            image and label and the surrounding box (if one shall be drawn),
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.Direction">
            <summary>
            This direction defines the position of the text label relatively to the image.
            If this is Direction.Up, the text label will be directly above the image.
            If this is Direction.Down, the text label will be directly below the image.
            If the direction is Direction.wxLEFT or Direction.Right, the text label will
            be on the left side of the image, or right side respectively. If the label is
            left and up, the label will be positioned relatively to the upper left corner of
            the image. The other directions are accordingly. In case of Direction.All, 
            the text will be positioned in the center of the image.
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.Foreground">
            <summary>
            The foreground/text colour that will be used to draw the node label.
            If you assign a colour to this, please note: The assigned instance will get readonly.
            </summary>
        </member>
        <member name="P:WX.Graph.View.LabelledNode.Background">
            <summary>
            The background colour that will be used to draw the node. this can be <c>null</c>.
            In that case, the background will be filly transparent.
            If you assign a colour to this, please note: The assigned instance will get readonly.
            </summary>
        </member>
        <member name="T:WX.Graph.View.LayoutedNode">
            <summary>
            Associates a node appearance with a position.
            Instances of this class implement the data of the nodes of the
            classes LayoutedDAG and LayoutedTree.
            </summary>
        </member>
        <member name="T:WX.Graph.View.LayoutedTree">
            <summary>
            This class implements a tree layout.
            </summary>
        </member>
        <member name="T:WX.Graph.View.LayoutedDAG">
            <summary>
            This class implements a layout for directed acyclic graphs.
            The layout is specialized on acyclic graphs but will also display
            graphs with cycles. However, there should not be too many cycles to
            make this algorithm work.
            </summary>
        </member>
        <member name="T:WX.Font">
            <summary>
            The wx font model.
            </summary>
            <remarks>
            \image html fontsmall.png
            </remarks>
        </member>
        <member name="M:WX.Font.#ctor(WX.Font)">
            <summary>Copy CTor.</summary>
        </member>
        <member name="M:WX.Font.ToString">
            <summary>This shows face name and point size.</summary>
        </member>
        <member name="P:WX.Font.TheFontList">
            <summary>Returns <c>wx.FontList.TheFontList</c>.
            </summary>
        </member>
        <member name="P:WX.Font.NullFont">
            <summary>
            A font without any properties.
            </summary>
        </member>
        <member name="T:WX.FileSys.wxInputStreamWrapper">
            <summary>Analogously to class wxString, this class wraps wxInputStream.
             Anatomy: This inherits from wx.Object and is, thus, a WX.Net wrapper class.
             Constructors either are required by wx.Object to implement the FindObject service
             or they pass a System.IO.Stream. This instance then serves as a wxWidgets fassade
             to the stream that you originally provided. On instance creation, this instance
             sets callback to implement a wxInputStream using the framework stream as source.
             
             However, instances of this class may occur in another state: Without a framework
             stream as source. In that case, the instance simply wrapps a fully functional
             wxWidgets input stream without setting callbacks.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStreamWrapper.#ctor(System.IO.Stream)">
            <summary>Generates a new  wxWidgets <c>wxInputStream</c> instance whose basic functions refer to methods of <c>src</c>.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStreamWrapper.#ctor(System.IntPtr)">
            <summary>Generates an instance wrapping a fully functional  wxWidgets <c>wxInputStream</c>.</summary>
        </member>
        <member name="M:WX.FileSys.wxInputStreamWrapper.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStreamWrapper.LastReadFromSrc">
            \name Implementations of Delegates
        </member>
        <member name="M:WX.FileSys.wxInputStreamWrapper.GetLength">
            <summary>In contrast to property Length this does not throw exceptions but returns -1.
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStreamWrapper.Src">
            <summary>This is the C# stream that is used as data source.
             Depending of the mode of this implementation this may either be a standard System.IO.Stream
             providing data for an internal <c>wxInputStream</c> or an instance of class wxInputStream
             wrapping a  wxWidgets input stream.
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStreamWrapper.CanSeek">
            <summary>This returns whether a seek operation failed in the past or the wrapped stream does not provide a current position.</summary>
        </member>
        <member name="P:WX.FileSys.wxInputStreamWrapper.Length">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStreamWrapper.Position">
            <summary>This will throw an <c>NotSupportedException</c> iff the wrapped <c>wxInputStream</c> does not support the analogous operation.
            </summary>
        </member>
        <member name="T:WX.FileSys.wxInputStream">
            <summary>This is a .NET framework stream wrapping a  wxWidgets <c>wxInputStream</c>.
             The wrapper of a <c>wxInputStream</c> falls into 2 parts. This is the instance that directly
             inherits from Stream and, thus, provides a fassades compliant to the standard .NET framework.
             Class <c>wxInputStreamWrapper</c> inherits from <c>wx.Object</c> instead and wrapps the pointer
             to a  wxWidgets stream.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStream.#ctor(System.IntPtr)">
            <summary>Receives an IntPtr to a <c>wxInputStream</c>.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStream.SetLength(System.Int64)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:WX.FileSys.wxInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>This is not implemented.
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStream.CanSeek">
            <summary>Tests whether this can tell and
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStream.CanWrite">
            <summary>This is false.</summary>
        </member>
        <member name="P:WX.FileSys.wxInputStream.Length">
            <summary>This typically returns the length of the stream in position units.
            </summary>
        </member>
        <member name="P:WX.FileSys.wxInputStream.Position">
            <summary>This is supported if the source supports <c>TellI</c> and <c>SeekI</c>.
            </summary>
        </member>
        <member name="T:WX.FileSys.FSFile">
            <summary>This is a wrapper to <c>wxFSFile</c>.
             Purpose: Provide some additional information on a file read through
             the <c>wxWidgets</c> file system. Unfortunately, the known characteristics of a <c>wxWidgets</c> file
             differ strongly from the <c>FileInfo</c> class: Instances of this class know s stream
            </summary>
        </member>
        <member name="M:WX.FileSys.FSFile.#ctor(System.IntPtr)">
            <summary>This CTor receives an IntPtr of a <c>wxFSFile</c>.
            </summary>
        </member>
        <member name="M:WX.FileSys.FSFile.#ctor(WX.FileSys.wxInputStreamWrapper,System.String,System.String,System.String,System.DateTime)">
            <summary>This creates a file descriptor reading content from the provided stream.
            Please note, that this will try to take ownership of the <c>wxObject</c> of <c>streamWrapper</c>.
            This will raise an exception, if this operation fails.</summary>
        </member>
        <member name="M:WX.FileSys.FSFile.#ctor(System.IO.Stream,System.String,System.String,System.String,System.DateTime)">
            <summary>This creates a file descriptor reading content from the provided stream.</summary>
        </member>
        <member name="M:WX.FileSys.FSFile.ToString">
            <summary>A comprehensable text description of this file.
            </summary>
        </member>
        <member name="P:WX.FileSys.FSFile.Anchor">
            <summary>The "anchor" part of a hyper link.
            Returns anchor (if present). Usually an anchor is presented only if the MIME type is 'text/html'. But it may have
            some meaning with other files; for example myanim.avi#200 may refer to position in animation
            or reality.wrl#MyView may refer to a predefined view in VRML.</summary>
            <remarks>
            The term of anchor can be easily explained using few examples:
            <list type="table">
            <item><term>index.htm#anchor</term><description>'anchor' is anchor</description></item>
            <item><term>index/wx001.htm</term><description>NO anchor here!</description></item>
            <item><term>archive/main.zip#zip:index.htm#global</term><description>'global'</description></item>
            <item><term>archive/main.zip#zip:index.htm</term><description>NO anchor here!</description></item>
            </list>
            </remarks>        
        </member>
        <member name="P:WX.FileSys.FSFile.Location">
             <summary>The "location" of the source of the stream data.</summary><remarks>
             This is the full location description of the file, e.g.
             <code>
             http://www.wxwidgets.org
             http://www.ms.mff.cuni.cz/~vsla8348/wxhtml/archive.zip#zip:info.txt
             file:/home/vasek/index.htm
             relative-file.htm
             </code>
            </remarks>*/
        </member>
        <member name="P:WX.FileSys.FSFile.MimeType">
            <summary>The mime type description (in text form).</summary>
        </member>
        <member name="P:WX.FileSys.FSFile.Stream">
            <summary>A stream for receiving the data.
            </summary>
        </member>
        <member name="F:WX.FileSys.KindOfFile.Indifferent">
            <summary>Either a directory or usual data file, I don't mind.
            </summary>
        </member>
        <member name="F:WX.FileSys.KindOfFile.wxFILE">
            <summary>Operate on data files only.</summary>
        </member>
        <member name="F:WX.FileSys.KindOfFile.wxDIR">
            <summary>Operate on directories only.</summary>
        </member>
        <member name="T:WX.FileSys.FileSystemHandler">
            <summary>This class wrapps  wxWidgets class <c>wxFileSystemHandler</c> and all inheritors.
             Investigate the documetnation of subclasses for details on predefined file system
             handlers. For instance class IOStreamFSHandler enables the implementation of  wxWidgets
             file system handlers as streams of the .NET framework.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.OpenFile(WX.FileSys.FileSystem,System.String)">
            <summary>Returns an instance of FSFile that provides a stream over the data as denoted by <c>location</c>.
             \param location absolute location of the desired data.
             \param fs is the parent file system. This parameter still exists maybe because of historical reasons.
             The manual 2.6.3. refers to <c>wxZipFSHandler</c> as a reference for using this parameter but this
             class in the meanwhile explicitely refers to a freshly created file system to avoid infinite recursions
             (as the remark says).
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.CanOpen(System.String)">
            <summary>The handler identifies himself with result <c>true</c> to be appropriate to deal with a file at the provided location.</summary><remarks>
                     * Example: A handler for the HTTP protocol over the internet could answer here with
                     * \code
                     return this.GetProtocol(location) == "http";
                     \endcode
                     * 
                     * Please note, that this method should also work with the allowed wildcards, since this method
                     * also works as a filter for FindFirst().
                     *</remarks>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.FindFirst(System.String,WX.FileSys.KindOfFile)">
            <summary>Returns the first matching filename or an empty string if nothing matches.
             This will only be called if the <c>wildcard</c> can be opened (CanOpen()).
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.FindNext">
            <summary>Returns the next filename matching with the constraints of the previous FindFirst() or an empty string if nothing matches.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.GetAnchor(System.String)">
            <summary>Returns the anchor if present in the location.
             Example:
             <code>
             GetAnchor("index.htm#chapter2") == "chapter2"
             </code>
            
             Note: the anchor is NOT part of the left location.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.GetProtocol(System.String)">
            <summary>Returns the protocol string extracted from location. 
                      * Example: <c>GetProtocol("file:myzipfile.zip#zip:index.htm") == "zip"</c>
                     *</summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.GetLeftLocation(System.String)">
            <summary>Returns the left location string extracted from location. 
             Example:
             <c>
             GetLeftLocation("file:myzipfile.zip#zip:index.htm") == "file:myzipfile.zip"
             </c>
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.GetRightLocation(System.String)">
            <summary>Returns the right location string extracted from location. 
            Example : 
            <c>
            GetRightLocation("file:myzipfile.zip#zip:/index.htm") == "/index.htm"
            </c>
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.GetMimeTypeFromExt(System.String)">
            <summary>Returns the MIME type based on extension of location.
             (While FSFile.MimeType returns real MIME type - either extension-based or queried
             from HTTP.) However, particular handlers may use this to generate an FSFile of 
             an appropriate mime type if nothing particular is known on such things.
            
             Example : 
             <code>
             this.GetMimeTypeFromExt("index.htm") == "text/html"
             </code>
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystemHandler.MimeTypeFromExt(System.String)">
            <summary>A static public version of GetMimeTypeFromExt() running on a particular, transparently generated instance.
             This method may be changed in order to add some support for additional types.
            </summary>
        </member>
        <member name="T:WX.FileSys.FileSystem">
            <summary>This wrapps <c>wxFileSystem</c> but concentrates on the methods that are not already implemented in the .NET framework.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.#ctor">
            <summary>The  wxWidgets file system uses instances created by the default constructor as handles for accessing files systems of various types through something like an URL.
             File system are implemented by a handler (refer to class FileSystemHandler). This wrapper to the .NET framework also
             allows file system handlers to be written in C# or another CRL language.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.AddHandler(WX.FileSys.FileSystemHandler)">
            <summary>Adds the provided instance as a handler to the handler list.
             Refer for instance to <c>MemoryFSHandler</c> for a wrapper to a standard
              wxWidgets resource handler. Note, that all inheritors of FileSystemHandler may
             be used here.
            
             The native object wrapped by <c>handler</c> will be owned by the singleton managing file system handlers.
             This will raise an exception, if te handler instance is already shared by another object.
             
             Please refer also to CleanUpHandlers().
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.CleanUpHandlers">
            <summary>Clean up all installed file handlers.
             Calling this method is unfortunately necessary on shutting down applications
             installing some kinds of file system handlers by using AddHandler(). The reason
             is:  wxWidgets will delete the C++ instances of installed file system handlers
             on shutting down. However,  wxWidgets can of course not delete the corresponding
             .NET instances. These may also try to delete C++ instances on being disposed. So,
             we will likely to get access violations.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.ChangePathTo(System.String,System.Boolean)">
            <summary>Sets the current location.</summary><remarks>
                     * <c>location</c> parameter passed to OpenFile is relative to this path.
                     * \b Caution!
                     * Unless <c>is_dir</c> is true the location parameter is not the directory name but
                     * the name of the file in this directory. All these commands change the path to
                     * "dir/subdir/":
                     * \code
                    FileSystem fs=new FileSystem();
                    fs.ChangePathTo("dir/subdir/xh.htm");
                    fs.ChangePathTo("dir/subdir", true);
                    fs.ChangePathTo("dir/subdir/", true);
                    \endcode
                    * \param location the new location. Its meaning depends on the value of <c>is_dir</c>
                    * \param is_dir if <c>true</c> location is new directory. If false (default) location
                    *  is file in the new directory.
                    *
                    * Example:
                    \code
              f = fs -> OpenFile("hello.htm"); // opens file 'hello.htm'
              fs -> ChangePathTo("subdir/folder", true);
              f = fs -> OpenFile("hello.htm"); // opens file 'subdir/folder/hello.htm' !!
                   \endcode
                     *</remarks>
        </member>
        <member name="M:WX.FileSys.FileSystem.FindFirst(System.String,WX.FileSys.KindOfFile)">
            <summary>Returns name of the first filename (within filesystem's current path) that matches wildcard.
              <c>flags</c> may be one of KindOfFile.wxFILE (only files), KindOfFile.wxDIR (only directories)
             or KindOfFile.Indifferent (both).
             
             Returns filename or empty string if no more matching file exists.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.FindNext">
            <summary>Finds the next filename matching constraints of the previous FindFirst().
             Returns filename or empty string if no more matching file exists.
            </summary>
        </member>
        <member name="M:WX.FileSys.FileSystem.OpenFile(System.String)">
            <summary>Opens the file and returns a <c>FSFile</c> object or <c>null</c> if failed.
             It first tries to open the file in relative scope (based on value passed to
             ChangePathTo() method) and then as an absolute path.
            </summary>
        </member>
        <member name="P:WX.FileSys.FileSystem.Path">
            <summary>Returns the path according to ChangePathTo().
             Setting this value is synonym to ChangePathTo(). 
            </summary>
        </member>
        <member name="T:WX.FileSys.ZipFSHandler">
            <summary>A wrapper to <c>wxZipFSHandler</c>. 
            This is a handler for FileSystem that can deal with Zip archives.
            In contrast to most other handlers, this one uses first and second part locations where
            the first part describes the archive file and the second part describes the archived file.
            </summary>
            <remarks>
            Example: 
            <code>
            "file:ZipFile.zip#anHTMLIndex.htm#aChapterInThisIndex"
            </code>
            </remarks>
        </member>
        <member name="M:WX.FileSys.ZipFSHandler.#ctor">
            <summary>
            Creates a handler of a file system that can deal with Zip archives.
            In contrast to most other handlers, this one uses first and second part locations where
            the first part describes the archive file and the second part describes the archived file.
            </summary>
        </member>
        <member name="T:WX.FileSys.InternetFSHandler">
            <summary>A wrapper to <c>wxInternetFSHandler</c>.
             Instances of this class provide a handler for FileSystem to deal with FTP and HTTP files.
            </summary>
        </member>
        <member name="T:WX.FileSys.MemoryFSHandler">
            <summary>This FileSystem handler can store arbitrary data in memory stream and make them
             accessible via URL. It is particularly suitable for storing bitmaps from resources
             or included XPM files so that they can be used with wx.HTML.
            
             Filenames are prefixed with <c> "memory:"</c>, e.g. <c>"memory:myfile.html"</c>.
            </summary>
        </member>
        <member name="M:WX.FileSys.MemoryFSHandler.Add(System.String,WX.Image,WX.BitmapType)">
            <summary>Adds an image as a file of the specified type.
             Please note, that the type argument shall be something like 
             <c>wx.BitmapType.wxBITMAP_TYPE_PNG</c> that  wxWidgets can save.
            </summary>
        </member>
        <member name="M:WX.FileSys.MemoryFSHandler.Add(System.String,WX.Bitmap,WX.BitmapType)">
            <summary>Adds an image as a file of the specified type.
             Please note, that the type argument shall be something like 
             <c>wx.BitmapType.wxBITMAP_TYPE_PNG</c> that  wxWidgets can save.
            </summary>
        </member>
        <member name="T:WX.FileSys.IOStreamFSHandler">
            <summary>Class of  wxWidgets file system handlers that are implemented by a <c>System.IO.Stream</c>. 
            Generate an instance of this class and install this (call FileSystemHandler.AddHandler)
            to provide the ability to deal with the following protocols:
            <list type="bullet"> 
            <item> <c>file:file</c> and <c>dotnetfile:file</c> implemented by a FileStream.</item>
            <item> <c>rs:file</c> or <c>rs:assembly.filename//file </c> tries to find the provided file name in the manifest
                and returns (if possible) a stream over the data of a resource file. Source assembly <c>assembly.filename</c> will be loaded by
                Assembly.LoadFile(). If the source assembly is omitted,
                this will refer to the entry assembly. You may also use the long protocol name <c>resource:file</c>.</item>
            <item> <c>zrs:archivefile//resourcefile</c> loads resource <c>resourcefile</c> from
                the ZRS archive <c>archivefile</c> (refer to class ZipResource). Long protocol name
                <c>zipresource:archivefile//resourcefile</c> also works.
            </item>
            </list>
            </summary>>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.#ctor">
            <summary>Creates a file system handler providing the ability to deal with the following protocols:
            <list type="bullet"> 
            <item> <c>file:file</c> and <c>dotnetfile:file</c> implemented by a FileStream.</item>
            <item> <c>rs:file</c> or <c>rs:assembly.filename//file </c> tries to find the provided file name in the manifest
                and returns (if possible) a stream over the data of a resource file. Source assembly <c>assembly.filename</c> will be loaded by
                Assembly.LoadFile(). If the source assembly is omitted,
                this will refer to the entry assembly. You may also use the long protocol name <c>resource:file</c>.</item>
            <item> <c>zrs:archivefile//resourcefile</c> loads resource <c>resourcefile</c> from
                the ZRS archive <c>archivefile</c> (refer to class ZipResource). Long protocol name
                <c>zipresource:archivefile//resourcefile</c> also works.
            </item>
            </list>
            </summary>>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.GetFirstFilename(System.String)">
            <summary>Returns the primary file.
            First and second file names complete standard  wxWidgets elements of
            file system names (protocol, left location, right location, anchor).
            Both filenames are subelements of the right location spanning over the filename
            right from the protocol and left from the (optional) anchor.
            If this filename contains a double slash (//), the filename left from this separator
            is called first filename and the filename on the right is called second filename.
            The first name is optional (i.e. is empty if the whole file name is without
            a double slash).
            </summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.DoFindFirst(System.IntPtr,WX.FileSys.KindOfFile)">
            <summary>Currently not supported.</summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.DoFindNext">
            <summary>Currently not supported.</summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.OpenFile(WX.FileSys.FileSystem,System.String)">
            <summary>Returns an instance of FSFile that provides a stream over the data as denoted by <c>location</c>.
             \param location absolute location of the desired data.
             \param fs is the parent file system.
             The manual 2.6.3. refers to <c>wxZipFSHandler</c> as a reference for using this parameter but this
             class in the meanwhile explicitely refers to a freshly created file system to avoid infinite recursions
             (as the remark says). I found out that this parameter contains the path.
            </summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.CanOpen(System.String)">
            <summary>The handler identifies himself with result <c>true</c> to be appropriate to deal with a file at the provided location.
             
            </summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.FindFirst(System.String,WX.FileSys.KindOfFile)">
            <summary>Returns the first matching filename or an empty string if nothing matches.
             This will only be called if the <c>wildcard</c> can be opened (CanOpen()).
            </summary>
        </member>
        <member name="M:WX.FileSys.IOStreamFSHandler.FindNext">
            <summary>Returns the next filename matching with the constraints of the previous FindFirst() or an empty string if nothing matches.
            </summary>
        </member>
        <member name="T:WX.wxString">
            <summary>Wrapper for the  wxWidgets string class <c>wxString</c>.</summary>
             <remarks>
             Objectives: 
             \li Several <c>WX.Net</c> implementations interchange string data with the used  wxWidgets library.
                 Conversion from .NET strings to  wxWidgets strings shall be hidden. .NET implementations shall
                 be able to use something like a lazy conversion: Simply getting a string from one method of
                  wxWidgets and sending it to another shall be possible without conversion to .NET strings.
             \li  wxWidgets class might be compiled in Unicode or ANSI mode. This shall be hidden completely to
                 the <c>WX.Net</c> implementation.
            
             The changed implementation follows the guidelines of the  wxWidgets manual for implementations.
             The internal character encoding within the .NET framework is uniquely defined to UTF 16.
             The used constructors and selectors use an explicit conversion as argument (on the <c>wx-c</c> side)
             to convert from or to this encoding. So, the interface provided by <c>wx-c</c> is always UTF 16 whether
             the library is able to represent such strings internally or not.
             An <c>MarshalAsAttribute</c> is used to define a more verbatim marshalling scheme on DLL import.
            
             So, any kind of conversion is done by  wxWidgets (if necessary) and not by the .NET framework.
             
             Refer to wxWCharBuffer and DisposableStringBox for remarks on helper classes for dealing with strings.
              </remarks>
        </member>
        <member name="M:WX.wxString.SafeNew(System.String)">
            <summary>This will safely create an instance of wx.wxString without throwing exceptions on argument <c>null</c>.
            Instead the method will return result <c>null</c> on argument <c>null</c>.
            </summary>
        </member>
        <member name="M:WX.wxString.ToString">
            <summary>Conversion of <c>wxString</c> into a string.
             This method works different on Unicode- and ANSI-builds of  wxWidgets.
             On Unicode builds we can directly refer to the internal buffer using
             the indexer of this class. Otherwise we read a wxWCharBuffer and convert this.
            
             Special case: PNET with internal UTF8 character encoding if <c>WXNET_INTERNAL_USE_UTF8</c>.
             In this case, we always have to decode.
            </summary>
        </member>
        <member name="P:WX.wxString.Item(System.Int32)">
            <summary>Get the n-th character.
            Returns a 2 byte UTF16 character. Only <c>get</c> implemented.
            Undefined positions will result in a 0.
            This works perfect on a Unicode build (ReflectConfig.CheckUseUnicode)
            since internal characer encoding of <c>wxString</c> is the same as the encoding
            in C#. On ANSI builds this will return blanks as replacemetns of non-ascii
            characters.
            
            Correction: Microsoft and Mono use UTF16 as internal string representation just
            like <c>wxWidgets</c> with wide character Unicode support compiled in. However, PNET
            seems to use UTF 8 instead. If this assumes internal UTF 8 strings, this method
            will return ASCII only.</summary>
        </member>
        <member name="P:WX.wxString.Length">
            <summary>Returns the length of the encapsulated string.</summary>
        </member>
        <member name="T:WX.wxWCharBuffer">
            <summary>This is a wrapper for the  wxWidgets class of the same type.
             This class is required for interchanging strings with ANSI builds of  wxWidgets.
             In such situations, we have to request the <c>wxString</c>, that internally holds an
             ANSI representation, into a wide character UTF-16 string buffer.
            </summary>
        </member>
        <member name="M:WX.wxWCharBuffer.ToString">
            <summary>Conversion into a string.
            Copies character by character into a .NET string.</summary>
        </member>
        <member name="T:WX.DisposableStringBox">
            <summary>This is a box for instances of wxString that calls wxString.Dispose() on deletion of the box and deletes the string instance.
            Use this class to pass instances of wxString from C# callbacks implementing virtual methods.
            Refer to <c>wx.ListCtrl.OnDoGetItemText()</c> for an example.</summary>
        </member>
        <member name="P:WX.DisposableStringBox.InstancesCount">
            <summary>This is the number of valid string instances.</summary>
        </member>
        <member name="T:WX.StyledText.StcStyleCollection">
            <summary>Parameters referring to a particular lexer.
            You may collect all style properties referring to a particular type of text within an instance
            of this type and apply this styles to a wx.StyledText.StyledTextCtrl if appropriate.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.#ctor(System.String,WX.StyledText.LexerId)">
            <summary>Creates a new set of properties.</summary>
            <param name="languageName">defines the name of the programming language. This will be used in lists to identify this style properties.</param>
            <param name="stylesForLexer"> defines the used lexer that will analyse the language.</param>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.DeactivateFor(WX.StyledText.StyledTextCtrl)">
            <summary>Deactivates this style for the provided control.
            From calling this method on, this style will not react on events sent from <c>stc</c> (e.g. for folding).
            Run this if you want to use another style in <c>stc</c> in order to avoid side-effects between both.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.Apply(WX.StyledText.StyledTextCtrl)">
            <summary>This will apply the represented settings to the provided styled text editor.
            This method activated this style i.e. all events from the <c>destination</c> will be processed.
            Do not forget do Deactivate() this if the control loads another style.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.OnFoldMarginClick(System.Object,WX.Event)">
            <summary>This will fold or unfold the clicked region.
            The sender probably is a styled text control where this configuration has been applied to.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.WriteXml(System.Xml.XmlWriter)">
            <summary>Writes all properties into <c>stc_styles</c> tag.</summary>
        </member>
        <member name="T:WX.StyledText.StcStyleCollection.TextProperties">
            <summary>Records the text properties that may be associated with styles.
            Please note, that each property might be <c>null</c> is not defined.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.TextProperties.#ctor(WX.StyledText.LexerStates,System.String)">
            <summary>Use predefined settings or derive heuristically a default text property from the state name.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.TextProperties.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.TextProperties.ReadXml(System.Xml.XmlReader)">
            <summary></summary>
        </member>
        <member name="M:WX.StyledText.StcStyleCollection.TextProperties.WriteXml(System.Xml.XmlWriter)">
            <summary>write properties into a <c>stc_textproperties</c> tag.</summary>
        </member>
        <member name="T:WX.StyledText.StcStyleConfiguration">
            <summary>Stores a full set of configurations.
            This creates a default set of styles for some programming languages and manages them.
            You may add or remove instances of StcStyleCollection as you like. This class also assigns
            styles to text files referring to their name in the file system. 
            Use instances of this class as a database of styles defining the way that text files are
            presented in a wx.StyledText.StyledTextCtrl.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleConfiguration.ForFilename(System.String)">
            <summary>Returns the styles appropriate to a file names <c>filename</c>.
            This will look for a matching suffix property of a contained style description.
            This will return the first style without suffix constraint if none of the contained
            description matches the file name.</summary>
        </member>
        <member name="M:WX.StyledText.StcStyleConfiguration.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:WX.PageSetupDialog.ShowModal">
            <summary>Shows the dialog, returning wx.Window.Ok if the user pressed OK, and wx.Window.CANCEL otherwise.
            Please note, that this is not a wx.Dialog.</summary>
        </member>
        <member name="T:WX.PrintDialog">
            <summary>
            The printer dialog. This does not work in Linux/GTK 
            (cf. bug tracker "printing sample crashes" ID: 3037944).
            All declarations are available. But ctors will throw System.NotSupportedException.
            </summary>
            <remarks>
            \image html printpreview.png
            </remarks>
        </member>
        <member name="M:WX.PrintDialog.#ctor(System.IntPtr)">
            <summary>
            Creates an instance of the dialog.
            </summary>
            <exception cref="T:System.NotSupportedException">Will be thrown on Linux since this dialog 
            crashes. Cf bug tracker "printing sample crashes" ID: 3037944)</exception>
        </member>
        <member name="M:WX.PrintDialog.#ctor(WX.Window)">
            <summary>
            Creates an instance of the dialog.
            </summary>
            <param name="parent">The parent window</param>.
            <exception cref="T:System.NotSupportedException">Will be thrown on Linux since this dialog 
            crashes. Cf bug tracker "printing sample crashes" ID: 3037944)</exception>
        </member>
        <member name="M:WX.PrintDialog.#ctor(WX.Window,WX.PrintDialogData)">
            <summary>
            Creates an instance of the dialog.
            </summary>
            <param name="parent">The parent window</param>.
            <param name="data">The initially displayed configuration.</param>
            <exception cref="T:System.NotSupportedException">Will be thrown on Linux since this dialog 
            crashes. Cf bug tracker "printing sample crashes" ID: 3037944)</exception>
        </member>
        <member name="M:WX.PrintDialog.#ctor(WX.Window,WX.PrintData)">
            <summary>
            Creates an instance of the dialog.
            </summary>
            <param name="parent">The parent window</param>.
            <param name="data">The initially displayed configuration.</param>
            <exception cref="T:System.NotSupportedException">Will be thrown on Linux since this dialog 
            crashes. Cf bug tracker "printing sample crashes" ID: 3037944)</exception>
        </member>
        <member name="M:WX.PrintDialog.ShowModal">
            <summary>Shows the dialog, returning wx.Window.Ok if the user pressed OK, and wx.Window.CANCEL otherwise.
            Please note, that this is not a wx.Dialog.</summary>
        </member>
        <member name="T:WX.MiniFrame">
            <summary>A miniframe is a frame with a small title bar.
            It is suitable for floating toolbars that must not take up too much screen area.</summary>
        </member>
        <member name="T:WX.Log">
            <summary>Wrapper of the  wxWidgets log class.
            Refer to LogTraceListener for System.Diagnostics.Trace support.</summary>
        </member>
        <member name="F:WX.Log._enabled">
            <summary>
            The redundant managed flag that implements disabling of the protocol.
            </summary>
        </member>
        <member name="M:WX.Log.SetActiveTarget(WX.TextCtrl)">
            <summary>at the moment only TextCtrl</summary>
        </member>
        <member name="M:WX.Log.AddTraceMask(System.String)">
            <summary>Add the mask to the list of allowed masks for LogTrace().</summary>
        </member>
        <member name="M:WX.Log.RemoveTraceMask(System.String)">
            <summary>Remove the mask from the list of allowed masks for LogTrace().
            See also: AddTraceMask().</summary>
        </member>
        <member name="M:WX.Log.IsAllowedTraceMask(System.String)">
            <summary>True if mask <c>tmask</c> is in TraceMasks().
            This means that output with this mask will be logged.</summary>
        </member>
        <member name="M:WX.Log.LogTrace(System.String,System.String,System.Object[])">
            <summary>Trace functions only do something in debug build and expand to nothing in the release one.
            The reason for making it a separate function from it is that usually there are a lot of trace
            messages, so it might make sense to separate them from other debug messages.
            
            For the second function (taking a string mask), the message is logged only if the mask has been previously enabled by the call to AddTraceMask or by setting WXTRACE environment variable. The predefined string trace masks used by wxWidgets are:
            \li <c>wxTRACE_MemAlloc</c>: trace memory allocation (new/delete) 
            \li <c>wxTRACE_Messages</c>: trace window messages/X callbacks 
            \li <c>wxTRACE_ResAlloc</c>: trace GDI resource allocation 
            \li <c>wxTRACE_RefCount</c>: trace various ref counting operations 
            \li <c>wxTRACE_OleCalls</c>: trace OLE method calls (Win32 only)</summary>
        </member>
        <member name="P:WX.Log.IsEnabled">
            <summary>Read whether this is enabled or not and enable or disable assigning <c>true</c> or
            <c>false</c> respectively.</summary>
            <remarks>By the way - this will manage two flags for enable /diable: On in the native wxWidgets 
            implementations and one in the managed code. Goal: If logging is disabled, WX.Net will not
            even call the native DLL functions.</remarks>
        </member>
        <member name="P:WX.Log.Timestamp">
            <summary>Gets or sets the timestamp format prepended by the default log targets to all messages.
            The string may contain any normal characters as well as % prefixed
            format specificators, see strftime() manual for details.
            Passing a <c>null</c> value (not empty string) to this function disables
            message timestamping.</summary>
        </member>
        <member name="T:WX.LogTraceListener">
            <summary>This class integrates  wxWidget's Log into .NET's trace capability.
             Add an instance of this listener to the Trace and all output to the Trace log
             will also appear in listeners to  wxWidget's Log.
            </summary>
        </member>
        <member name="M:WX.LogTraceListener.#ctor">
            <summary>This will post all messages to the Trace as Log.eLogLevel.xLOGMESSAGE().
            </summary>
        </member>
        <member name="P:WX.LogTraceListener.Level">
            <summary>Returns the log level.
            </summary>
        </member>
        <member name="P:WX.CheckListBox.ItemHeight">
            <summary>Returns the item height.
            This is not supported for <c>wx.ReflectConfig.CheckWxMAC</c>.
            </summary>
        </member>
        <member name="T:WX.FindReplaceFlags">
            <summary>Flags for wx.FindReplaceData.Flags and wx.FindDialogEvent.Flags.</summary>
        </member>
        <member name="F:WX.FindReplaceFlags.None">
            <summary>Useful for initialization: No flag set.</summary>
        </member>
        <member name="F:WX.FindReplaceFlags.DOWN">
            <summary>Flag for the wx.FindReplaceDialog.
            downward search/replace selected (otherwise - upwards)</summary>
        </member>
        <member name="F:WX.FindReplaceFlags.WHOLEWORD">
            <summary>Flag for the wx.FindReplaceDialog.
            whole word search/replace selected</summary>
        </member>
        <member name="F:WX.FindReplaceFlags.MATCHCASE">
            <summary>Flag for the wx.FindReplaceDialog.
            case sensitive search/replace selected (otherwise - case insensitive)</summary>
        </member>
        <member name="T:WX.FindDialogEvent">
            <summary>Event issued by the wx.FindReplaceDialog to start a search process.
            Use the folloing functions to define event handlers:
            \li wx.EvtHandler.EVT_FIND() to find a first occurance of the searched string (user pressed RETURN in text field),
            \li wx.EvtHandler.EVT_FIND_NEXT() to find the next occurance of the searched string (user pressed button),
            \li wx.EvtHandler.EVT_FIND_REPLACE() to replace strings,
            \li wx.EvtHandler.EVT_FIND_REPLACE_ALL() to replace all occurances of a string,
            \li wx.EvtHandler.EVT_FIND_CLOSE() to handle the closing of the dialog.
            
            You may specify the identifier of the find dialog if you use more than one dialog of
            this type.</summary>
        </member>
        <member name="T:WX.FindReplaceData">
            <summary>Data model of the wx.FindReplaceDialog.</summary>
        </member>
        <member name="T:WX.Display">
            <summary>Use static method GetDisplay() to generate instances.
             Please note, that this method will generate at most on instance for each display.
             
             Currently, this class causes access violations with Windows.
            </summary>
        </member>
        <member name="F:WX.Display.wxNOT_FOUND">
            <summary>Symbolic constant used by all Find()-like functions returning positive
            		  * integer on success as failure indicator. While this is global in
            		  * wxWidgets it makes more sense to be in each class that uses it??? 
            		  * Or maybe move it to Window.cs.
                     *</summary>
        </member>
        <member name="M:WX.Display.GetDisplays">
            <summary>The array of all Displays indexed by display number.
            These are all instance of this class that should ever live.</summary>
        </member>
        <member name="M:WX.Display.GetDisplay(System.Int32)">
            <summary>Returns the representation of the desired display.
            </summary>
            <remarks>
            \return null iff the index is too large.
            </remarks>
        </member>
        <member name="M:WX.Display.GetModes">
            <summary>
            An array of available VideoModes for this display.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Display.GetModes(WX.VideoMode)">
            <summary>An array of the VideoModes that match mode.
                    * A match occurs when
            		* the resolution and depth matches and the refresh frequency in 
            		* equal to or greater than mode.RefreshFrequency.</summary>
        </member>
        <member name="M:WX.Display.GetFromPoint(System.Drawing.Point)">
            <summary>
            Returns the index of the display displaying the specified point or
            -1 if no such display exists.
            </summary>
            <param name="pt">The point to display</param>
            <returns>The index of a display or -1.</returns>
        </member>
        <member name="M:WX.Display.GetFromWindow(WX.Window)">
            <summary>This returns the display that shows <c>window</c>.
            This will throw an exception of this is not Windows.
            </summary>
        </member>
        <member name="M:WX.ComboBox.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,System.String[],WX.WindowStyles)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:WX.ComboBox.#ctor(WX.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,System.String[],WX.WindowStyles,System.String)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:WX.ComboBox.SetSelection(System.Int32,System.Int32)">
            <summary>Refer to ControlWithItems for the method receiving only one index.
            </summary>
        </member>
        <member name="M:WX.TextAttr.#ctor(WX.Colour,WX.Colour)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for the <c>colText</c> if you only want to specify the background colour.</summary>
        </member>
        <member name="M:WX.TextAttr.#ctor(WX.Colour,WX.Colour,WX.Font)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for unspecific properties.</summary>
        </member>
        <member name="M:WX.TextAttr.#ctor(WX.Colour,WX.Colour,WX.Font,WX.TextAttrAlignment)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for unspecific properties.</summary>
        </member>
        <member name="P:WX.TextAttr.Flags">
            <summary>Returns or sets a bitlist indicating which attributes will be set.</summary>
        </member>
        <member name="T:WX.TextAttr.Attr">
            <summary>These are the bits used in property Flags.</summary>
        </member>
        <member name="T:WX.StyledText.WhiteSpaceModes">
            <summary>Modes for displaying the white space character.</summary>
        </member>
        <member name="T:WX.StyledText.EOLModes">
            <summary>Enumeration to represent line ending mode.</summary>
        </member>
        <member name="T:WX.StyledText.CaseForce">
            <summary>Modes to enforce lower or upper case letters.</summary>
        </member>
        <member name="F:WX.StyledText.CaseForce.MIXED">
            <summary>Display letter in original case.</summary>
        </member>
        <member name="F:WX.StyledText.CaseForce.UPPER">
            <summary>Enforce upper case letters.</summary>
        </member>
        <member name="F:WX.StyledText.CaseForce.LOWER">
            <summary>Enforce lower case latters.</summary>
        </member>
        <member name="T:WX.StyledText.Mark">
            <summary>Shapes used for outlining column.
            Refer to MarkerDefine().</summary>
        </member>
        <member name="F:WX.StyledText.Mark.BACKGROUND">
            <summary>Invisible mark that only sets the line background color.</summary>
        </member>
        <member name="T:WX.StyledText.MarkNum">
            <summary>Markers used for outlining column (wrt folding).
            Refer to MarkerDefine().</summary>
        </member>
        <member name="F:WX.StyledText.MarkNum.FOLDER">
            <summary>Designates a region that can be hidden in a folder.</summary>
        </member>
        <member name="F:WX.StyledText.MarkNum.FOLDEROPEN">
            <summary></summary>
        </member>
        <member name="T:WX.StyledText.MarginMask">
            <summary>The displayed symbol when MarginType.Symbol.</summary>
        </member>
        <member name="T:WX.StyledText.MarginType">
            <summary>Type of a margin.
            Defines whether a margin shall present symbols, line numbers, etc.</summary>
        </member>
        <member name="T:WX.StyledText.LexerId">
            <summary> For SciLexer.h: specifying lexer implementations.
            These are the available lexicographic analysis methods as provided by the used Scintilla implementation.</summary> 
        </member>
        <member name="T:WX.StyledText.Keywords">
            <summary>This is an enumeration of designatros for keyword sets.
            Keyword sets are parameters to some LexerStates.</summary>
        </member>
        <member name="T:WX.StyledText.LexerStates">
            <summary>These are the lexicographic states that will be assigned by the Scintilla lexers (refer to LexerId).
            Styles in range 32..37 are predefined for parts of the UI and are not used as normal styles.
            Styles 38 and 39 are for future use. Styles up to 127 may be used.
            
            Some style are defined w.r.t. sets of keywords.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.LAST_PREDEFINED">
            <summary>First definitley unused style index.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.Default">
            <summary> General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.LINENUMBER">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.BRACELIGHT">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.BRACEBAD">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.CONTROLCHAR">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.INDENTGUIDE">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.CALLTIP">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_Default">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_COMMENTLINE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_NUMBER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_STRING">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_CHARACTER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_WORD">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.
            
            Uses keyword list Keywords.PY_WORD.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_TRIPLE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_TRIPLEDOUBLE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_CLASSNAME">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_DEFNAME">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.
            
            Uses Keywords.PY_DEFNAME.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_OPERATOR">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_IDENTIFIER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_COMMENTBLOCK">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.PY_STRINGEOL">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_Default">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENT">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENTLINE">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENTDOC">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_NUMBER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_WORD">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            Uses Keywords.C_WORD.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_STRING">
            <summary>Lexical state for SCLEX_CPP
             Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            </summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_CHARACTER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_UUID">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_PREPROCESSOR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_OPERATOR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_IDENTIFIER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_STRINGEOL">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_VERBATIM">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_REGEX">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENTLINEDOC">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_WORD2">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            This will use Keywords.C_WORD2.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENTDOCKEYWORD">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            This style covers keyword in comments introduced by '\' or '@'. Typically, these
            are keywords referring to common document extractors like <c>doxygen</c> or <c>javadoc</c>.
            
            This will use Keywords.C_COMMENTDOCKEYWORD.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.C_COMMENTDOCKEYWORDERROR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_Default">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_TAG">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_TAGUNKNOWN">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_ATTRIBUTE">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_ATTRIBUTEUNKNOWN">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_NUMBER">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_DOUBLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SINGLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_OTHER">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_ENTITY">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_TAGEND">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_XMLSTART">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_XMLEND">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SCRIPT">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_ASP">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_ASPAT">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_CDATA">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_QUESTION">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_VALUE">
            <summary>Lexical state for wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_XCCOMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.XCODE.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_Default">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_COMMAND">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_1ST_PARAM">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_DOUBLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_SIMPLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_ERROR">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_SPECIAL">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_ENTITY">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_1ST_PARAM_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.H_SGML_BLOCK_Default">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJ_START">
            \name Embedded Javascript 
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_START">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_Default">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_COMMENT">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_COMMENTLINE">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_COMMENTDOC">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_NUMBER">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_WORD">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_KEYWORD">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_DOUBLESTRING">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_SINGLESTRING">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_SYMBOLS">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_STRINGEOL">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HJA_REGEX">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.HB_START">
            \name Embedded VBScript 
        </member>
        <member name="F:WX.StyledText.LexerStates.HBA_START">
            \name ASP VBScript 
        </member>
        <member name="F:WX.StyledText.LexerStates.HP_START">
            \name Embedded Python 
        </member>
        <member name="F:WX.StyledText.LexerStates.HPA_START">
            \name ASP Python 
        </member>
        <member name="F:WX.StyledText.LexerStates.HPHP_Default">
            \name PHP 
        </member>
        <member name="F:WX.StyledText.LexerStates.PL_Default">
            \name Lexical states for SCLEX_PERL 
        </member>
        <member name="F:WX.StyledText.LexerStates.B_Default">
            \name Lexical states for SCLEX_VB, SCLEX_VBSCRIPT 
        </member>
        <member name="F:WX.StyledText.LexerStates.PROPS_Default">
            \name Lexical states for SCLEX_PROPERTIES 
        </member>
        <member name="F:WX.StyledText.LexerStates.L_Default">
            \name Lexical states for SCLEX_LATEX 
        </member>
        <member name="F:WX.StyledText.LexerStates.LUA_Default">
            \name Lexical states for SCLEX_LUA 
        </member>
        <member name="F:WX.StyledText.LexerStates.ERR_Default">
            \name Lexical states for SCLEX_ERRORLIST 
        </member>
        <member name="F:WX.StyledText.LexerStates.BAT_Default">
            \name Lexical states for SCLEX_BATCH 
        </member>
        <member name="F:WX.StyledText.LexerStates.MAKE_Default">
            \name Lexical states for SCLEX_MAKEFILE 
        </member>
        <member name="F:WX.StyledText.LexerStates.DIFF_Default">
            \name Lexical states for SCLEX_DIFF 
        </member>
        <member name="F:WX.StyledText.LexerStates.CONF_Default">
            \name Lexical states for SCLEX_CONF (Apache Configuration Files Lexer) 
        </member>
        <member name="F:WX.StyledText.LexerStates.AVE_Default">
            \name Lexical states for SCLEX_AVE, Avenue 
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_Default">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_WORD">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_IDENTIFIER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_NUMBER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_DELIMITER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_CHARACTER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_CHARACTEREOL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_STRING">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_STRINGEOL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_LABEL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_COMMENTLINE">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.ADA_ILLEGAL">
            <summary>Lexical states for SCLEX_ADA
            Refer to LexerId.ADA.</summary>
        </member>
        <member name="F:WX.StyledText.LexerStates.BAAN_Default">
            \name Lexical states for SCLEX_BAAN 
        </member>
        <member name="F:WX.StyledText.LexerStates.LISP_Default">
            \name Lexical states for SCLEX_LISP 
        </member>
        <member name="F:WX.StyledText.LexerStates.EIFFEL_Default">
            \name Lexical states for SCLEX_EIFFEL and SCLEX_EIFFELKW 
        </member>
        <member name="F:WX.StyledText.LexerStates.NNCRONTAB_Default">
            \name Lexical states for SCLEX_NNCRONTAB (nnCron crontab Lexer) 
        </member>
        <member name="F:WX.StyledText.LexerStates.MATLAB_Default">
            \name Lexical states for SCLEX_MATLAB 
        </member>
        <member name="F:WX.StyledText.LexerStates.SCRIPTOL_Default">
            \name  Lexical states for SCLEX_SCRIPTOL 
        </member>
        <member name="F:WX.StyledText.LexerStates.ASM_Default">
            \name Lexical states for SCLEX_ASM 
        </member>
        <member name="F:WX.StyledText.LexerStates.F_Default">
            \name Lexical states for SCLEX_FORTRAN 
        </member>
        <member name="F:WX.StyledText.LexerStates.CSS_Default">
            \name Lexical states for SCLEX_CSS 
        </member>
        <member name="F:WX.StyledText.LexerStates.POV_Default">
            \name Lexical states for SCLEX_POV 
        </member>
        <member name="T:WX.StyledText.CharsetIdentifier">
            <summary>Character set identifiers are used in StyleSetCharacterSet.
            The values are the same as the Windows *_CHARSET values.</summary>
        </member>
        <member name="F:WX.StyledText.TheFoldFlags.FOLDFLAG_BOX">
            <summary>Draws a box around a folded or fodable region.</summary>
        </member>
        <member name="T:WX.StyledText.FoldLevel">
            <summary>The fold level describes properties of a line referring to folding.
            Refer also to StyledTextCtrl.GetFoldLevel().</summary>
        </member>
        <member name="F:WX.StyledText.FoldLevel.HEADERFLAG">
            <summary>This flag is in the fold level iff the referring line starts a foldable region.</summary>
        </member>
        <member name="F:WX.StyledText.FoldLevel.CONTRACTED">
            <summary>This is in the fold flags if this line belongs to a foldable region.</summary>
        </member>
        <member name="F:WX.StyledText.FoldLevel.BASE">
            <summary>This is the base for the number describing the folding level.</summary>
        </member>
        <member name="F:WX.StyledText.FoldLevel.NUMBERMASK">
            <summary>This is the mask for the number describing the folding level.</summary>
        </member>
        <member name="F:WX.StyledText.FoldLevel.FLAGSMASK">
            <summary>This is the mask for the flags describing the folding level.</summary>
        </member>
        <member name="T:WX.StyledText.STCCursors">
            <summary>Available cursors to be used within the edit control.</summary>
        </member>
        <member name="T:WX.StyledText.WrapModes">
            <summary>Modes for wrapping lines if they are too long to fit into the edit control.</summary>
        </member>
        <member name="T:WX.StyledText.EdgeModes">
            <summary>Use this to define the policy for</summary>
        </member>
        <member name="T:WX.StyledText.VisiblePolicies">
            <summary> Constants for use with SetVisiblePolicy(), similar to SetCaretPolicy().</summary>
        </member>
        <member name="F:WX.StyledText.CaretPolicies.SLOP">
            <summary>Caret policy, used by SetXCaretPolicy and SetYCaretPolicy.
            If CARET_SLOP is set, we can define a slop value: caretSlop.
            This value defines an unwanted zone (UZ) where the caret is... unwanted.
            This zone is defined as a number of pixels near the vertical margins,
            and as a number of lines near the horizontal margins.
            By keeping the caret away from the edges, it is seen within its context,
            so it is likely that the identifier that the caret is on can be completely seen,
            and that the current line is seen with some of the lines following it which are
            often dependent on that line.</summary>
        </member>
        <member name="F:WX.StyledText.CaretPolicies.STRICT">
            <summary>If CARET_STRICT is set, the policy is enforced... strictly.
            The caret is centred on the display if slop is not set,
            and cannot go in the UZ if slop is set.</summary>
        </member>
        <member name="F:WX.StyledText.CaretPolicies.EVEN">
            <summary>If CARET_EVEN is not set, instead of having symmetrical UZs,
            the left and bottom UZs are extended up to right and top UZs respectively.
            This way, we favour the displaying of useful information: the begining of lines,
            where most code reside, and the lines after the caret, eg. the body of a function.</summary>
        </member>
        <member name="T:WX.StyledText.StyledTextCtrl">
            <summary>Text control particularly applicable for displaying programming languages.
            This is a text control with builtin lexicographic analysis (configured by StyledTextCtrl.Lexer).
            This analysis assigns styles to particular parts of the displayed text. 
            You may assign various directives for text formatting to these styles.
            </summary>
            <remarks>
            \image html stcsample.PNG "The STC Sample Program"
            
            Purpose:
            A wxWidgets implementation of Scintilla.  This class is the
                     one meant to be used directly by wx applications.  It does not
                     derive directly from the Scintilla classes, and in fact there
                     is no mention of Scintilla classes at all in this header.
                     This class delegates all method calls and events to the
                     Scintilla objects and so forth.  This allows the use of
                     Scintilla without polluting the namespace with all the
                     classes and itentifiers from Scintilla.
            </remarks>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_CP_UTF8">
            <summary>The SC_CP_UTF8 value can be used to enter Unicode mode.
                      * This is the same value as CP_UTF8 in Windows
                     *</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_CP_DBCS">
            <summary>The SC_CP_DBCS value can be used to indicate a DBCS mode for GTK+.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_PRINT_NORMAL">
            <summary>PrintColourMode - use same colours as screen.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_PRINT_INVERTLIGHT">
            <summary>PrintColourMode - invert the light value of each style for printing.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_PRINT_BLACKONWHITE">
            <summary>PrintColourMode - force black text on white background for printing.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_PRINT_COLOURONWHITE">
            <summary>PrintColourMode - text stays coloured, but all background is forced to be white for printing.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_PRINT_COLOURONWHITEDefaultBG">
            <summary>PrintColourMode - only the default-background is forced to be white for printing.</summary>
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_MOD_INSERTTEXT">
            \name Notifications
            Type of modification and the action which caused the modification.
            These are defined as a bit mask to make it easy to specify which notifications are wanted.
            One bit is set from each of SC_MOD_* and SC_PERFORMED_*.
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_KEY_DOWN">
            \name Symbolic key codes and modifier flags.
            ASCII and other printable characters below 256.
            Extended keys above 300.
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_CMD_REDO">
            \name Commands that can be bound to keystrokes. 
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_CMD_HOMEWRAP">
            \name These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
            except they behave differently when word-wrap is enabled:
            They go first to the start / end of the display line, like (Home|LineEnd)Display
            The difference is that, the cursor is already at the point, it goes on to the start
            or end of the document line, as appropriate for (Home|LineEnd|VCHome)Extend.
        </member>
        <member name="F:WX.StyledText.StyledTextCtrl.wxSTC_CMD_PARADOWN">
            \name Move caret between paragraphs (delimited by empty lines) 
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.PositionFromPoint(System.Drawing.Point)">
            <summary>Position from a position.
            This apparently does currently not work. However, this might be a problem of the origin
            of the coordinates. Mouse positions do not work.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.MarkerDefine(WX.StyledText.MarkNum,WX.StyledText.Mark)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.MarkerDefine(WX.StyledText.MarkNum,WX.StyledText.Mark,WX.Colour)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.
            \param foreground is the foreground colour to be used to draw the marker symbol
            \param background is the background colour to be used to draw the marker symbol</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.MarkerDefine(WX.StyledText.MarkNum,WX.StyledText.Mark,WX.Colour,WX.Colour)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.
            \param foreground is the foreground colour to be used to draw the marker symbol
            \param background is the background colour to be used to draw the marker symbol</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetMarginType(System.Int32,WX.StyledText.MarginType)">
            <summary>Set a margin to be either numeric or symbolic.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetMarginWidth(System.Int32,System.Int32)">
            <summary>Defines margin of the specified type in pixels.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetMarginMask(System.Int32,WX.StyledText.MarginMask)">
            <summary>Set a mask that determines which markers are displayed in a margin.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetMarginSensitive(System.Int32,System.Boolean)">
            <summary>Make a margin sensitive or insensitive to mouse clicks.
            Users of this control may define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetMarginSensitive(System.Int32)">
            <summary>Return <c>true</c> of the margin of the provided index is sensitive to mouse clicks.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompShow(System.Int32,System.String)">
            <summary>Display a auto-completion list.
            The lenEntered parameter indicates how many characters before
            the caret should be used to provide context.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompShow(System.Int32,WX.wxString)">
            <summary>Display a auto-completion list.
            The lenEntered parameter indicates how many characters before
            the caret should be used to provide context.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompCancel">
            <summary>Remove the auto-completion list from the screen.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompComplete">
            <summary>User has selected an item so remove the list and insert the selection.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompSelect(System.String)">
            <summary>Select the item in the auto-completion list that starts with a string.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.AutoCompSelect(WX.wxString)">
            <summary>Select the item in the auto-completion list that starts with a string.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.UserListShow(System.Int32,System.String)">
            <summary>Display a list of strings and send notification when user chooses one.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.UserListShow(System.Int32,WX.wxString)">
            <summary>Display a list of strings and send notification when user chooses one.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.CallTipShow(System.Int32,System.String)">
            <summary>Show a call tip containing a definition near position pos.
            Prerequisite: CallTipUseStyle().</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.CallTipShow(System.Int32,WX.wxString)">
            <summary>Show a call tip containing a definition near position pos.
            Prerequisite: CallTipUseStyle().</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.CallTipCancel">
            <summary>Remove the call tip from the screen.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.CallTipUseStyle(System.Int32)">
            <summary>Enable use of STYLE_CALLTIP and set call tip tab size in pixels.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetFoldLevel(System.Int32,System.Int32)">
            <summary>Sets the fold level of the designated line.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetFoldLevelFlags(System.Int32)">
            <summary>The flags in GetFoldLevel().</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetFoldLevelNumber(System.Int32)">
            <summary>Fold level number in GetFoldLevel().</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetFoldLevel(System.Int32)">
            <summary>Gets the fold level of the designated line.
             The result indicates whether this line starts a folded region or not.
             
             Refer to FoldLevel for the documentation of flags.
            </summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetFoldParent(System.Int32)">
            <summary>Returns the line that is the parent of <c>line</c> wrt folding.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetFoldExpanded(System.Int32,System.Boolean)">
            <summary>Contract or expand fold below <c>line</c> (<c>line</c> must denote header line).
            Use ToggleFold().</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetFoldExpanded(System.Int32)">
            <summary>Result indicates whether fold with header line <c>line</c> is expanded or contracted.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.ToggleFold(System.Int32)">
            <summary>Toggles fold at <c>line</c>.
            The GetFoldLevelFlags(line) must contain FoldLevel.HEADERFLAG.
            This will fold up if the fold is expanded. This will fold down otherwise.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetProperty(System.String,System.String)">
            <summary>Defines properties.</summary><remarks>
                     * Examples:
                     * \code
                            SetProperty("fold", "1");
                            SetProperty("fold.comment", "1");
                            SetProperty("fold.compact", "1");
            
                            SetProperty("fold.html", "1");
                            SetProperty("fold.htmlprep", "1");
                            SetProperty("fold.commentpy", "1");
                            SetProperty("fold.quotespy", "1");
                     \endcode
                     * </remarks>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetProperty(WX.wxString,WX.wxString)">
            <summary>Defines properties.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetKeyWords(WX.StyledText.Keywords,System.String[])">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetKeyWords(WX.StyledText.Keywords,System.String)">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords separated by a single blank character.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.SetKeyWords(WX.StyledText.Keywords,WX.wxString)">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords separated by a single blank character.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.StyleSetSpec(WX.StyledText.LexerStates,System.String)">
            <summary>Extract style settings from a spec-string which is composed of one or more of the following comma separated elements:
            \li bold                    turns on bold
            \li italic                  turns on italics
            \li fore:[name or #RRGGBB]  sets the foreground colour
            \li back:[name or #RRGGBB]  sets the background colour
            \li face:[facename]         sets the font face name to use
            \li size:[num]              sets the font size in points
            \li eol                     turns on eol filling
            \li underline               turns on underlining</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.StyleSetSpec(System.Int32,System.String)">
            <summary>Extract style settings from a spec-string which is composed of one or more of the following comma separated elements:
            \li bold                    turns on bold
            \li italic                  turns on italics
            \li fore:[name or #RRGGBB]  sets the foreground colour
            \li back:[name or #RRGGBB]  sets the background colour
            \li face:[facename]         sets the font face name to use
            \li size:[num]              sets the font size in points
            \li eol                     turns on eol filling
            \li underline               turns on underlining</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.LoadFile(System.String)">
            <summary>
            Loading a file into the editor.
            Please note that loading a file is treated as an editor action.
            Loading a file will be reflected by the Undo/Redo-buffer and 
            the control shall not be readonly when loading. This, you may wish
            to set <c>ReadOnly</c> to false before loading a file and
            call <c>EmptyUndoBuffer</c> after loading.
            </summary>
            <param name="filename">The name of the loaded file.</param>
            <returns></returns>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.LoadFile(WX.wxString)">
            <summary>
            Loading a file into the editor.
            Please note that loading a file is treated as an editor action.
            Loading a file will be reflected by the Undo/Redo-buffer and 
            the control shall not be readonly when loading. This, you may wish
            to set <c>ReadOnly</c> to false before loading a file and
            call <c>EmptyUndoBuffer</c> after loading.
            </summary>
            <param name="filename">The name of the loaded file.</param>
            <returns></returns>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.StatePrefixForLexer(WX.StyledText.LexerId)">
            <summary>This will return a prefix string defining all those values of STCStyle that describe valid states of <c>lexer</c>.
            Example: LexerId.CPP and LexerId.CPPNOCASE will return {"C_"}.
            The result may be <c>null</c> if this is not supported.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetLexerStateNameAtPos(System.Int32)">
            <summary>Returns the name of the lexer at the designated position.</summary>
        </member>
        <member name="M:WX.StyledText.StyledTextCtrl.GetLexerStateName(WX.StyledText.LexerStates,WX.StyledText.LexerId)">
            <summary>This returns a name string for the lexer state <c>state</c> that refers to <c>lexer</c>.
            Problem: Lexer state are named ambigiously among different lexers.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.ViewWhiteSpace">
            <summary>Defines how to view white spaces.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompActive">
            <summary>Is there an auto-completion list visible?</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompPosStart">
            <summary>Retrieve the position of the caret when the auto-completion list was displayed.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompStops">
            <summary>Define a set of character that when typed cancel the auto-completion list.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompSeparator">
            <summary>Gets or changes the separator character in the string setting up an auto-completion list.
            Default is space but can be changed if items contain space.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompCancelAtStart">
            <summary>Should the auto-completion list be cancelled if the user backspaces to a
            position before where the box was created.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompFillUps">
            <summary>Defines a set of characters that when typed will cause the autocompletion to
            choose the selected item.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompChooseSingle">
            <summary>Should a single item auto-completion list automatically choose the item.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompIgnoreCase">
            <summary>Retrieve whether a single item auto-completion list automatically choose the item.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompAutoHide">
            <summary>Set whether case is significant when performing auto-completion searches.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompDropRestOfWord">
            <summary>Retrieve whether or not autocompletion deletes any word characters
            after the inserted text upon completion.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.AutoCompTypeSeparator">
            <summary>Retrieve the auto-completion list type-separator character.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.UseTabs">
            <summary>Indentation will only use space characters if useTabs is false, otherwise
            it will use a combination of tabs and spaces.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.Modify">
            <summary>True if this contains unsafed changes.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.Overtype">
            <summary>Read or set overtype mode (in contrast to insert mode).</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.FoldFlags">
            <summary>Defines some flags for folding.
            Do not forget to define markers in order to configure a fine looking folding capability.</summary>
        </member>
        <member name="P:WX.StyledText.StyledTextCtrl.Lexer">
            <summary>Returns or defines the used lexer.</summary>
        </member>
        <member name="E:WX.StyledText.StyledTextCtrl.Change">
            <summary>This will be raised on any kind of change.
            Use Modify() in the event handler if you want to trigger actions only if the text has been changed.</summary>
        </member>
        <member name="T:WX.MenuIDs">
            <summary>
            Standard menu IDs. Some of these IDs define stock labels (and stock bitmaps in GTK2)
            if used with buttons. Note that some of the IDs listed above have also a stock accelerator
            and an help string associated.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Close" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.About" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.HelpContents" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Cut" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Copy" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Clear" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Find" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Delete" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Replace" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Ok" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Cancel" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Apply" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Forward" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Backward" ignoriert -->
        <member name="F:WX.MenuIDs.Add">
            <summary>ID with stock label "Add"</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Up" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Down" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "F:WX.MenuIDs.Bold" ignoriert -->
        <member name="T:WX.KeyCode">
            <summary>Designators for eys on the keyboard.</summary>
        </member>
        <member name="T:WX.ShowModalResult">
            <summary>This enumerates possible results of Dialog.ShowModal.</summary>
        </member>
        <member name="F:WX.ShowModalResult.Yes">
            <summary>YES button has been pressed.</summary>
        </member>
        <member name="F:WX.ShowModalResult.Ok">
            <summary>OK button has been pressed.</summary>
        </member>
        <member name="F:WX.ShowModalResult.No">
            <summary>NO button has been pressed.</summary>
        </member>
        <member name="F:WX.ShowModalResult.Cancel">
            <summary>CANCEL button has been pressed.</summary>
        </member>
        <member name="T:WX.WindowStyles">
            <summary>These are the flags that are used in instances of Window (and inheriting classes) to configure appearance and behaviour.
            Some enumeration instances apply to only some classes of windows. 
            The same enumeration value may be used for different enumeration instances.
            This means in general that the enumeration isntances (sharing the same value)
            shall be applied to different classes of windows.
            
            Note, that flags are named similar to their origin in  wxWidgets but they do
            not necessarily bear the same name. Reason: Better navigation with IntelliSence.
            Example: You may type WindowStyles.BOR to navigate through all styles referring to
            borders.</summary>
        </member>
        <member name="F:WX.WindowStyles.None">
            <summary>An empty style definition.
            This may be useful for some occasions as default argument.
            It is simply an enumeration instance for zero.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderDefault">
            <summary>Default border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderNone">
            <summary>No border.
            Overriding the default behaviour of the window. Applicable to all windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderStatic">
            <summary>Displays a border suitable for a static control.
            Applicable to all windows but effect only on machines using OS Windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderSimple">
            <summary>Displays a thin border around the window.
            Applicable to all windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderRaised">
            <summary>Displays a raised border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderSunken">
            <summary>Displays a sunken border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.BorderTheme">
            <summary>Starting with wxWidgets 2.8.5, you can specify the <c>BorderTheme</c> style to have  wxWidgets use a themed border.
             Using the default XP theme, this is a thin 1-pixel blue border, with an extra 1-pixel border in the window
             client background colour (usually white) to separate the client area's scrollbars from the border.
            
             If you don't specify a border style for a wxTextCtrl in rich edit mode,  wxWidgets now gives the control themed
             borders automatically, where previously they would take the Windows 95-style sunken border. Other native controls
             such as <c>wx.TextCtrl</c> in non-rich edit mode, and wxComboBox, already paint themed borders where appropriate.
             To use themed borders on other windows, such as <c>wx.Panel</c>, pass the <c>BorderTheme</c> style.
            
             Note that in  wxWidgets 2.9 and above, <c>BorderTheme</c> will be used on all platforms to indicate that there
             should definitely be a border, whose style is determined by  wxWidgets for the current platform.
              wxWidgets  2.9 and above will also be better at determining whether there should be a themed border.
             Because of the requirements of binary compatibility, this automatic border capability could not be put into
              wxWidgets 2.8 except for built-in, native controls. In 2.8, the border must be specified for custom controls
             and windows.
             </summary>
        </member>
        <member name="F:WX.WindowStyles.BorderMask">
            <summary>All bits defining the border of the window.</summary>
        </member>
        <member name="F:WX.WindowStyles.TabTraversal">
            <summary>Use this to enable tab traversal for non-dialog windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.NoFullRepaintOnResize">
            <summary>Now obsolete.
            On Windows, this style used to disable repainting the window completely
            when its size is changed. Since this behaviour is now the default,
            the style is now obsolete and no longer has an effect.</summary>
        </member>
        <member name="F:WX.WindowStyles.FullRepaintOnResize">
            <summary>Use this style to force a complete redraw of the window whenever it is resized instead of redrawing just the part of the window affected by resizing.
            Note that this was the behaviour by default before 2.5.1 release and
            that if you experience redraw problems with code which previously used
            to work you may want to try this.
            Currently this style applies on GTK+ 2 and Windows only, and full
            repainting is always done on other platforms.</summary>
        </member>
        <member name="F:WX.WindowStyles.WantsChars">
            <summary>Use this to indicate that the window wants to get all char/key events for all keys - even for keys like TAB or ENTER which are usually used for dialog navigation and which wouldn't be generated without this style.
            If you need to use this style in order to get the arrows or etc., but
            would still like to have normal keyboard navigation take place, you
            should create and send a NavigationKeyEvent in response to the key events for Tab and Shift-Tab.</summary>
        </member>
        <member name="F:WX.WindowStyles.VScroll">
            <summary>Use this style to enable a vertical scrollbar.</summary>
        </member>
        <member name="F:WX.WindowStyles.HScroll">
            <summary>Use this style to enable a horizontal scrollbar.</summary>
        </member>
        <member name="F:WX.WindowStyles.AlwaysShowSB">
            <summary>If a window has scrollbars, disable them instead of hiding them when they are not needed (i.e. when the size of the window is big enough to not require the scrollbars to navigate it).
            This style is currently only implemented for <c>wxMSW</c> and <c>wxUniversal</c>
            and does nothing on the other platforms.</summary>
        </member>
        <member name="F:WX.WindowStyles.ClipChildren">
            <summary>Use this style to eliminate flicker caused by the background being repainted, then children being painted over them.
            Windows only.</summary>
        </member>
        <member name="F:WX.WindowStyles.TransparentWin">
            <summary>The window is transparent, that is, it will not receive paint events.
            Windows only.</summary>
        </member>
        <member name="F:WX.WindowStyles.PopupWin">
            <summary>Set this flag to create a special popup window:
            it will be always shown on top of other windows, will capture the mouse
            and will be dismissed when the mouse is clicked outside of it or if it
            loses focus in any other way.</summary>
        </member>
        <member name="F:WX.WindowStyles.WinStyleMask">
            <summary>A mask which can be used to filter (out) all wxWindow-specific styles.</summary>
        </member>
        <member name="F:WX.WindowStyles.Caption">
            <summary>Puts a caption on the frame. 
            Applicable to instances of Frame.</summary>
        </member>
        <member name="F:WX.WindowStyles.FrameDefaultStyle">
            <summary>Comprises all those styles that apply to a frame by default.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgDefaultStyle">
            <summary>Comprises those styles that apply to dialogs by default.</summary>
        </member>
        <member name="F:WX.WindowStyles.Minimize">
            <summary>Display the frame iconized (minimized).
            Windows only. Applicable to top level windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.MinimizeBox">
            <summary>Displays a minimize box on the frame.
            Applicable to top level windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.CloseBox">
            <summary>Displays a close box on the frame.
            Applicable to top level windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.StayOnTop">
            <summary>Stay on top of all other windows.
            Applicable to top level windows. Refer also to FRAME_FLOAT_ON_PARENT.</summary>
        </member>
        <member name="F:WX.WindowStyles.Maximize">
            <summary>Displays the frame maximized.
            Windows only.</summary>
        </member>
        <member name="F:WX.WindowStyles.MaximizeBox">
            <summary>Displays a maximize box on the frame.</summary>
        </member>
        <member name="F:WX.WindowStyles.ResizeBorder">
            <summary>Displays a resizeable border around the window.</summary>
        </member>
        <member name="F:WX.WindowStyles.SystemMenu">
            <summary>Displays a system menu.</summary>
        </member>
        <member name="F:WX.WindowStyles.FrameNoTaskbar">
            <summary>Creates an otherwise normal frame but it does not appear in the taskbar under Windows or GTK+
            (note that it will minimize to the desktop window under Windows
            which may seem strange to the users and thus it might be better to
            use this style only without MinimizeBox style). In <c>wxGTK</c>, the
            flag is respected only if GTK+ is at least version 2.2 and the
            window manager supports <c>_NET_WM_STATE_SKIP_TASKBAR</c> hint. Has no
            effect under other platforms.</summary>
        </member>
        <member name="F:WX.WindowStyles.FrameToolWindow">
            <summary>Causes a frame with a small titlebar to be created;
            the frame does not appear in the taskbar under Windows or GTK+.</summary>
        </member>
        <member name="F:WX.WindowStyles.FrameFloatOnParent">
            <summary>The frame will always be on top of its parent (unlike StayOnTop).
            A frame created with this style must have a non-NULL parent.</summary>
        </member>
        <member name="F:WX.WindowStyles.FrameShaped">
            <summary>Windows with this style are allowed to have their shape changed with the SetShape method.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgNoParent">
            <summary>By default, a dialog created with a <c>null</c> parent window will be given the application's top level window as parent.
            Use this style to prevent this from happening and create an orphan
            dialog. This is not recommended for modal dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgYes">
            <summary>Show an YES button.
            This shall be used together either with DIALOG_NO or DlgCancel.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DlgOk">
            <summary>Show an OK button.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgNo">
            <summary>Show an NO button.
            This shall be used together either with DlgYes.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DlgCancel">
            <summary>Show an CANCEL button.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgYesNo">
            <summary>Show YES and NO button.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgYesDefault">
            <summary>Used with <c>DlgYes</c>, makes YES button the default - which is the default behaviour.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgNoDefault">
            <summary>Used with <c>DIALOG_NO</c>, makes NO button the default.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgCentre">
            <summary>Centre the message.
            Applicable to message dialog and certain standard dialogs.
            Not Windows.</summary>
        </member>
        <member name="F:WX.WindowStyles.DlgCenter">
            <summary>Refer to <c>DialogCentre</c>.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconExclamation">
            <summary>Shows an exclamation mark icon.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconHand">
            <summary>Shows an error icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconWarning">
            <summary>Shows an exclamation mark icon.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconError">
            <summary>Shows an error icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconQuestion">
            <summary>Shows a question mark icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconInformation">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconStop">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconAsterisk">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.IconMask">
            <summary>A bit mask for filtering those styles referring to icons.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlNoVScroll">
            <summary> For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlAutoScroll">
            <summary> For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlReadonly">
            <summary>The text will not be user-editable. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlMultiline">
            <summary>The text control allows multiple lines. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlProcessTab">
            <summary>The control will receive <c>wxEVT_CHAR</c> events for TAB pressed - normally, TAB is used for passing to the next control in a dialog instead.
            For the control created with this style, you can still use
            Ctrl-Enter to pass to the next control from the keyboard. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlLeft">
            <summary>The text in the control will be left-justified (default). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlCenter">
            <summary>The text in the control will be centered (currently <c>wxMSW</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlCentre">
            <summary>The text in the control will be centered (currently <c>wxMSW</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlRight">
            <summary>The text in the control will be right-justified (currently wxMSW and wxGTK2 only). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlRich">
            <summary>Use rich text control under Win32, this allows to have more than 64KB of text in the control even under Win9x.
            This style is ignored under other platforms. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlProcessEnter">
            <summary>The control will generate the event <c>wxEVT_COMMAND_TEXT_ENTER</c>
            (otherwise pressing Enter key is either processed internally by
            the control or used for navigation between dialog controls). 
            For instances of wx.TextCtrl, wx.ComboCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlPassword">
            <summary>The text will be echoed as asterisks. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlAutoUrl">
            <summary>Highlight the URLs and generate the TextUrlEvents when mouse events occur over them.
            This style is only supported for <c>TE_RICH</c> Win32 and multi-line
            <c>wxGTK2</c> text controls. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlNoHideSelection">
            <summary>Show selection even if not focussed.
            By default, the Windows text control doesn't show the selection
            when it doesn't have focus - use this style to force it to always
            show it. It doesn't do anything under other platforms. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlLineWrap">
            <summary>Tells a wx.TextCtrl to wrap lines that are too long to be displayed in the control.
            This is another name for the standard behaviour. Refer also to <c>TE_BESTWRAP</c>.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlDontWrap">
            <summary>Same as <c>HScroll</c> style: don't wrap at all, show horizontal scrollbar instead.
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlCharWrap">
            <summary>Wrap the lines too long to be shown entirely at any position (<c>wxUniv</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlWordWrap">
            <summary>Wrap the lines too long to be shown entirely at word boundaries (<c>wxUniv</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlBestWrap">
            <summary>Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlRich2">
            <summary>Use rich text control version 2.0 or 3.0 under Win32.
            This style is ignored under other platforms.
            Style flag for instances of wx.TextCtrl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TextCtrlDialogStyle">
            <summary>Default style bits for instances of wx.TextEntryDialog.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.HtmlWinScrollbarNever">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.HtmlWinScrollbarAuto">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.HtmlWinNoSelection">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashCentreOnParent">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashCentreOnScreen">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashNoCentre">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashTimeout">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashNoTimeout">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplashDefault">
            <summary>The bits defining the default style for wx.SplashScreen.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxSort">
            <summary>Style for wx.ListBox.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxSingle">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxMultiple">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxExtended">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxOwnerDraw">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxNeedSB">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxAlwaysSB">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxHScroll">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListBoxIntHeight">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlVRules">
            <summary>Draws light vertical rules between columns in report mode.  
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlHRules">
            <summary>Draws light horizontal rules between rows in report mode. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlIcon">
            <summary>Large icon view, with optional labels. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlSmallIcon">
            <summary>Small icon view, with optional labels. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlList">
            <summary>Multicolumn list view, with optional small icons.
            Columns are computed automatically, i.e. you don't set columns as in wx.WindowStyles.ListCtrlReport.
            In other words, the list wraps, unlike a wx.ListBox.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlReport">
            <summary>Single or multicolumn report view, with optional header. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlAlignTop">
            <summary>Icons align to the top. Win32 default, Win32 only. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlAlignLeft">
            <summary>Icons align to the left. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlAutoArrange">
            <summary>Icons arrange themselves. Win32 only.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlVirtual">
            <summary>The application provides items text on demand.
            May only be used with wx.WindowsStyles.ListCtrlReport. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlEditLabels">
            <summary>Labels are editable: the application will be notified when editing starts. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlNoHeader">
            <summary>No header in report mode. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlNoSortHeader">
            <summary> Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlSingleSel">
            <summary>Single selection (default is multiple). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlSortAscending">
            <summary>Sort in ascending order (must still supply a comparison callback in wx.ListCtrl.SortItems()). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlSortDescending">
            <summary>Sort in descending order (must still supply a comparison callback in wx.ListCtrl.SortItems). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlMaskType">
            <summary>Mask of style bits defining the kind of presentation in instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlMaskAlign">
            <summary>Mask of style bits referring to the alignment in instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ListCtrlMaskSort">
            <summary>Mask of styles referring to sorting instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ChoiceDlgStyle">
            <summary>Default style bits for instances of wx.SingleChoiceDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.MdiFrameDefaultStyle">
            <summary>Default style bits for instances of wx.MDIParentFrame.</summary>
        </member>
        <member name="F:WX.WindowStyles.OrientHorizontal">
            <summary> Style for wx.ToolBar, wx.ScrollBar, wx.Slider, wx.RadioBox, wx.Gauge wx.SpinCtrl and wx.SpinButton</summary>
        </member>
        <member name="F:WX.WindowStyles.OrientVertical">
            <summary>Style for wx.ToolBar, wx.ScrollBar, wx.Slider, wx.RadioBox, wx.Gauge wx.SpinCtrl and wx.SpinButton</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBar3DButtons">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarFlat">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarDockable">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarNoIcons">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarText">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarNoDivider">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.ToolBarNoALIGN">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.SashWinNoBorder">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SashWinBorder">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SashWin3DSash">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SashWin3DBorder">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SashWin3D">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderNotifyDrag">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderTicks">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderAutoTicks">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderLabels">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderLeft">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderTop">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderRight">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderBottom">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderBoth">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.SliderSelRange">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioCtrlLeftToRight">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioCtrlTopToBottom">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioCtrlSpecifyCols">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioCtrlSpecifyRows">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:WX.WindowStyles.SpinCtrlArrowKeys">
            <summary>The user can use arrow keys to change the value. 
            Style for wx.SpinCtrl and wx.SpinButton.</summary>
        </member>
        <member name="F:WX.WindowStyles.SpinCtrlWrap">
            <summary>The value wraps at the minimum and maximum. 
            Style for wx.SpinCtrl and wx.SpinButton.</summary>
        </member>
        <member name="F:WX.WindowStyles.Splitter3DBorder">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for borders.</summary>
        </member>
        <member name="F:WX.WindowStyles.SplitterLiveUpdate">
            <summary>A style for the wx.SplitterWindow.</summary>
        </member>
        <member name="F:WX.WindowStyles.Splitter3D">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for borders and sash.</summary>
        </member>
        <member name="F:WX.WindowStyles.Splitter3DSash">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for the sash.
            <c>Splitter3D</c> combines this with  <c>SP_3BORDER</c> to turn on both 3D effects.</summary>
        </member>
        <member name="F:WX.WindowStyles.GaugeProgressBar">
            <summary> Style for wx.Gauge.</summary>
        </member>
        <member name="F:WX.WindowStyles.GaugeSmooth">
            <summary> Style for wx.Gauge.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalSundayFirst">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalMondayFirst">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalShowHolidays">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalNoYearChange">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalNoMonthChange">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalSequentialMonthSelection">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.CalShowSurroundingWeeks">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgCanAbort">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgAppModal">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgAutoHide">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgElapsedTime">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgEstimatedTime">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.ProgressDlgRemainingTime">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioButtonGroup">
            <summary> Style flag for wx.RadioButton.</summary>
        </member>
        <member name="F:WX.WindowStyles.RadioButtonSingle">
            <summary> Style flag for wx.RadioButton.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookFixedWidth">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookTop">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookLeft">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookRight">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookBottom">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.NotebookMultiline">
            <summary> Style flag for wx.Notebook.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlNoButtons">
            <summary>For convenience to document that no buttons are to be drawn. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlHasButtons">
            <summary>Use this style to show + and - buttons to the left of parent items. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlTwistButtons">
            <summary> Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlNoLines">
            <summary>Use this style to hide vertical level connectors. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlLinesAtRoot">
            <summary>Use this style to show lines between root nodes.
            Only applicable if <c>TreeCtrlHideRoot</c> is set and <c>TreeCtrlNoLines</c> is not set. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlMacButtons">
            <summary> Deprecated style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlAquaButtons">
            <summary> Deprecated style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlSingle">
            <summary> Style for wx.TreeCtrl.
            This defines single selection and is standard behaviour.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlMultiple">
            <summary>Use this style to allow a range of items to be selected.
            If a second range is selected, the current range, if any, is deselected. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlExtended">
            <summary>Use this style to allow disjoint items to be selected.
            (Only partially implemented; may not work in all cases.) 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlFullRowHighlight">
            <summary>Use this style to have the background colour and the selection highlight extend over the entire horizontal row of the tree control window.
            (This flag is ignored under Windows unless you specify <c>TreeCtrlNoLines</c> as well.) 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlEditLabels">
            <summary>Use this style if you wish the user to be able to edit labels in the tree control. 
             Style for wx.TreeCtrl.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlRowLines">
            <summary>Use this style to draw a contrasting border between displayed rows. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlHideRoot">
            <summary>Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:WX.WindowStyles.TreeCtrlHasVariableRowHeight">
            <summary>Use this style to cause row heights to be just big enough to fit the content.
            If not set, all rows use the largest row height.
            Style for wx.TreeCtrl. The default is that this flag is unset. Generic only.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditPointSize">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for point size.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditFontFamily">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font family.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditFontWeight">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font weight.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditFontStyle">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font style.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditFontColour">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for text colour.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontCtrlEditAll">
            <summary>Style for wx.FontCtrl.
            Turns on all edit fields.</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgOpen">
            <summary>This is a dialog requesting a file to be opened.
            Style for wx.FileDialog and wx.FileSelector</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgSave">
            <summary>This is a save dialog. 
            Style for wx.FileDialog and wx.FileSelector</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgOverwritePrompt">
            <summary>For save dialog only: prompt for a confirmation if a file will be overwritten. 
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgHideReadonly">
            <summary>Do not display the checkbox to toggle display of read-only files.
            Deprecated in 2.6; the checkbox is never shown.
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgFileMustExist">
            <summary>The user may only select files that actually exist. 
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgMultiple">
            <summary>For open dialog only: allows selecting multiple files. 
            Style for wx.FileDialog and wx.FileSelector.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgPreview">
            <summary>
            Show the preview of the selected files (currently only supported by wxGTK using GTK+ 2.4 or later). 
            Style for wx.FileDialog and wx.FileSelector.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.FileDlgChangeDir">
            <summary>Two different meanings in wx.FileDialog and wx.FileSeletor.
            <list type="table">
            <item><term>wx.FileDialog</term><description> Change the current working directory to the directory where the file(s) chosen by the user are.</description></item> 
            <item><term>wx.FileSelector</term><description> Select a directory rather than a file.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:WX.WindowStyles.FindReplReplaceDialog">
            <summary>Inititializes replace dialog (otherwise find dialog).
            Style flag for wx.FindReplaceDialog.</summary>
        </member>
        <member name="F:WX.WindowStyles.FindReplNoUpDown">
            <summary>Don't allow changing the search direction.
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for changing search direction will be disabled.</summary>
        </member>
        <member name="F:WX.WindowStyles.FindReplNoMatchCase">
            <summary>Don't allow case sensitive searching.
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for changing relevance of letter case will be disabled.</summary>
        </member>
        <member name="F:WX.WindowStyles.FindReplNoWholeWord">
            <summary>don't allow whole word searching 
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for defining search for whole words only will be disabled.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboBoxSimple">
            <summary>Style for wx.Choice, wx.ComboBox etc.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboBoxSort">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Sorts the entries in the list alphabetically.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboBoxReadonly">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Text will not be editable.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboBoxDropDown">
            <summary>Style for wx.Choice, wx.ComboBox etc.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlReadonly">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Text will not be editable.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlSort">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Sorts the entries in the list alphabetically.</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlProcessEnter">
            <summary>
            The control will generate the event EvtCommandTextEnter()
            (otherwise pressing Enter key is either processed internally by the control or
            used for navigation between dialog controls). Windows only.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlButtonOutsideBorder">
            <summary>Style for wx.ComboCtrl: Button is preferred outside the border (GTK style).</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlPopupOnMouseUp">
            <summary>Style for wx.ComboCtrl: Show popup on mouse up instead of mouse down (which is the Windows style)</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlNoTextAutoSelect">
            <summary>Style for wx.ComboCtrl: All text is not automatically selected on click</summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlSpecialDClick">
            <summary>
            Style for wx.ComboCtrl: Double-clicking triggers a call to popup's OnComboDoubleClick.
            Actual behaviour is defined by a derived class. For instance, <c>wxOwnerDrawnComboBox</c> will cycle
            an item. This style only applies if ComboCtrlReadonly is used as well. 
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ComboCtrlStdButton">
            <summary>
            Style for wx.ComboCtrl: Drop button will behave more like a standard push button.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.StaticTextNoAutoResize">
            <summary>Style flag for static text and wx.StatusBar. Static text fields also use alignment flags.</summary>
        </member>
        <member name="F:WX.WindowStyles.StatusBarNoAutoResize">
            <summary>Style flag for static text and wx.StatusBar. Static text fields also use alignment flags.</summary>
        </member>
        <member name="F:WX.WindowStyles.StatusBarSizeGrip">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.StatusBarNormal">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.StatusBarFlat">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.StatusBarRaised">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:WX.WindowStyles.AlignLeft">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:WX.WindowStyles.AlignRight">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:WX.WindowStyles.AlignCentre">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:WX.WindowStyles.AlignCenter">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonLeft">
            <summary>Style flag for wx.Button and wx.BitmapButton.
            Left-justifies the bitmap label. WIN and GTK with wx.Button only.</summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonTop">
            <summary>Style flag for wx.Button and wx.BitmapButton.
            Aligns the bitmap label to the top of the button. WIN and GTK with wx.Button only. </summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonRight">
            <summary>Style flag for wx.Button and wx.BitmapButton.
            Right-justifies the bitmap label. WIN and GTK with wx.Button only.</summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonBottom">
            <summary>Style flag for wx.Button and wx.BitmapButton.
            Aligns the bitmap label to the bottom of the button. WIN and GTK with wx.Button only.</summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonExactFit">
            <summary>Style flag for wx.Button (not wx.BitmapButton).
            Creates the button as small as possible instead of making it of the standard size (which is the default behaviour ). 
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonNoBorder">
            <summary>
            Creates a flat button. Windows and GTK+ only.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ButtonAutoDraw">
            <summary>
            Style flag for instances of wx.BitmapButton.
            If this is specified, the button will be drawn automatically using the label bitmap only, providing a 3D-look border. If this style is not specified, the button will be drawn without borders and using all provided bitmaps. WIN32 only.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridSelectCells">
            <summary>This defines the <c>wx.Grid.SelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:WX.WindowStyles.GridSelectRows">
            <summary>This defines the <c>wx.Grid.SelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:WX.WindowStyles.GridSelectColumns">
            <summary>This defines the <c>wx.Grid.SelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:WX.WindowStyles.GridExpandColumns">
            <summary>
            Style for <c>wx.Grid</c> and <c>wx.ExtendedGrid</c>: Always resize columns in such a way that the full client size
            of the control gets filled. If the grid gets resized, the column width will grow or decrease
            according to the proportion of its width to the sum of the widths of all columns.
            You may use <c>wx.Grid.AutoSizeColumns</c> to set the columns widths according to the content.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridMultiselect">
            <summary>
            Allows multi-selection in ExtendedGrid. The effect depends on the selection mode as defined by the
            styles GRID_SELECT_CELLS, GridSelectRows, or GRID_SELECT_COLUMNS.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridReadonly">
            <summary>
            For the ExtendedGrid only: Tell the grid that it shall not open editors to change data.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridHideRowLabels">
            <summary>
            If specified, class wx.ExtendedGrid will hide row labels. The default is to present row labels.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridHideColumnLabels">
            <summary>
            If specified, class wx.ExtendedGrid will hide column labels. The default is to present column labels.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GridFixedLabels">
            <summary>
            Tells instances of class wx.ExtendedGrid to present row and column labels (as far as not hidden)
            in fixed position. The labels will always be visible without regarding scroll positions.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.GenericFormReadonly">
            <summary>Specifies that a generic form will not be user-editable. 
            wx.GenericForm.GenericFormPanel.</summary>
        </member>
        <member name="F:WX.WindowStyles.DatePickerDefault">
            <summary>wx.DatePickerCtrl style.
            Default style on this platform, either <c>DatePickerSpin</c> or <c>DatePickerDropDown</c>.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DatePickerSpin">
            <summary>wx.DatePickerCtrl style.
            A spin control-like date picker (not supported in generic version)
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DatePickerDropDown">
            <summary>wx.DatePickerCtrl style.
            A combobox-like date picker (not supported in mac version)
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DatePickerShowCentury">
            <summary>wx.DatePickerCtrl style.
             Always show century in the default date display (otherwise it depends on
            the system date format which may include the century or not)
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DatePickerAllowNone">
            <summary>wx.DatePickerCtrl style.
             Allow not having any valid date in the control (by default it always has
            some date, today initially if no valid date specified in ctor)
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ColourPickerDefaultStyle">
            <summary>wx.ColourPickerCtrl style.
            The default style: 0.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ColourPickerUseTextCtrl">
            <summary>wx.ColourPickerCtrl style.
            Creates a text control to the left of the picker button which is completely managed by the wx.ColourPickerCtrl
            and which can be used by the user to specify a colour (see <c>SetColour</c>).
            The text control is automatically synchronized with button's value.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ColourPickerShowLabel">
            <summary>wx.ColourPickerCtrl style.
            Shows the colour in HTML form (AABBCC) as colour button label (instead of no label at all).
            </summary>
        </member>
        <member name="F:WX.WindowStyles.FontPickerFontDescAsLabel">
            <summary>wx.FontPickerCtrl style.
            Keeps the label of the button updated with the fontface name and font size.
            E.g. choosing "Times New Roman bold, italic with size 10" from the fontdialog,
            updates the button label (overwriting any previous label)
            with the "Times New Roman, 10" text (only fontface + fontsize is displayed
            to avoid extralong labels).
            </summary>
        </member>
        <member name="F:WX.WindowStyles.FontPickerUseFontForLabel">
            <summary>wx.FontPickerCtrl style.
            Uses the currently selected font to draw the label of the button.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontPickerUseTextCtrl">
            <summary>wx.FontPickerCtrl style.
            Creates a text control to the left of the picker button which is completely managed by the wx.FontPickerCtrl
            and which can be used by the user to specify a font.
            The text control is automatically synchronized with button's value.</summary>
        </member>
        <member name="F:WX.WindowStyles.FontPickerDefaultStyle">
            <summary>Default style for wx.FontPickerCtrl.
            Currently <c>FontPickerUseFontForLabel|FontPickerFontDescAsLabel</c>, i.e. if <c>FontPickerUseTextCtrl</c> is active,
            then use a textual description of the font as label and display it in the selected font.</summary>
        </member>
        <member name="F:WX.WindowStyles.DirDlgDefaultStyle">
            <summary>
            Equivalent to a combination of DialogDefaultStyle and ResizeBorder (the last one is not used under wxWinCE).
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DirDlgDirMustExist">
            <summary>
            The dialog will allow the user to choose only an existing folder. When this style is not given, a "Create new directory"
            button is added to the dialog (on Windows) or some other way is provided to the user to type the name of a new folder.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.DirDlgChangeDir">
            <summary>
            Change the current working directory to the directory chosen by the user.
            </summary>
        </member>
        <member name="F:WX.WindowStyles.Chk2State">
            <summary>
            Create a 2-state checkbox. This is the default.  
            </summary>
        </member>
        <member name="F:WX.WindowStyles.Chk3State">
            <summary>
              Create a 3-state checkbox. Not implemented in wxMGL, wxOS2 and wxGTK built against GTK+ 1.2.  
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ChkAllow3rdStateForUser">
            <summary>
            By default a user can't set a 3-state checkbox to the third state. It can only be done from code. Using this flags allows the user to set the checkbox to the third state by clicking.  
            </summary>
        </member>
        <member name="F:WX.WindowStyles.ChkAlignRight">
            <summary>
              Makes the text appear on the left of the checkbox.  
            </summary>
        </member>
        <member name="T:WX.Direction">
            <summary>Represent a direction.
            Used to specify dynamic layouts.</summary>
        </member>
        <member name="T:WX.FillRule">
            <summary>Used to define how polygons will be filled.
            cf. wx.DC.</summary>
        </member>
        <member name="T:WX.DCBackgroundMode">
            <summary>Used to define the background mode in wx.DC.</summary>
        </member>
        <member name="T:WX.Logic">
            <summary>Operations to merge pixels for instance on blitting an image onto another.</summary>
        </member>
        <member name="F:WX.Logic.Clear">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            0
            </summary>
        </member>
        <member name="F:WX.Logic.RopBlack">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            0
            </summary>
        </member>
        <member name="F:WX.Logic.BlitBlackness">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            0
            </summary>
        </member>
        <member name="F:WX.Logic.Xor">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopXorPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.BlitSrcInvert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.Invert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            NOT dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopNot">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            NOT dst
            </summary>
        </member>
        <member name="F:WX.Logic.BlitDstInvert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            NOT dst
            </summary>
        </member>
        <member name="F:WX.Logic.OrReverse">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.RopMergePenNot">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Blit00dd0228">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Reverse">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.RopMaskPenNot">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.BlitSrcErase">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Copy">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src
            </summary>
        </member>
        <member name="F:WX.Logic.RopCopyPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src
            </summary>
        </member>
        <member name="F:WX.Logic.BlitSrcCopy">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src
            </summary>
        </member>
        <member name="F:WX.Logic.And">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopMaskPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.BlitSrcAnd">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.AndInvert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopMaskNotPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.Blit00220326">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND dst
            </summary>
        </member>
        <member name="F:WX.Logic.NoOp">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopNop">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            dst
            </summary>
        </member>
        <member name="F:WX.Logic.Blit00AA0029">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            dst
            </summary>
        </member>
        <member name="F:WX.Logic.NOr">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.RopNotMergePen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.BlitNotSrcErase">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) AND (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Equiv">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopNotXOrPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.Blit00990066">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) XOR dst
            </summary>
        </member>
        <member name="F:WX.Logic.SrcInvert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src)
            </summary>
        </member>
        <member name="F:WX.Logic.RopNotCopyPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src)
            </summary>
        </member>
        <member name="F:WX.Logic.BlitNotSrcCopy">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src)
            </summary>
        </member>
        <member name="F:WX.Logic.OrInvert">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopMergeNotPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.BlitMergePaint">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.NAnd">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.RopNotMaskPen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Blit007700E6">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            (NOT src) OR (NOT dst)
            </summary>
        </member>
        <member name="F:WX.Logic.Or">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.RopMergePen">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.BlitSrcPaint">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            src OR dst
            </summary>
        </member>
        <member name="F:WX.Logic.Set">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            1
            </summary>
        </member>
        <member name="F:WX.Logic.RopWhite">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            1
            </summary>
        </member>
        <member name="F:WX.Logic.BlitWhiteness">
            <summary>
            Bit operation on pixels ("src" for new pixel to set and "dst" for the existing pixel in the DC):
            1
            </summary>
        </member>
        <member name="T:WX.Orientation">
            <summary>Represents an orientation (e.g. of a sizer).
            </summary>
        </member>
        <member name="F:WX.Orientation.Vertical">
            <summary>
            Vertical orientation.
            </summary>
        </member>
        <member name="F:WX.Orientation.Horizontal">
            <summary>
            Horizontal orientation.
            </summary>
        </member>
        <member name="F:WX.Orientation.Both">
            <summary>
            Both orientations, horizontal and vertical.
            </summary>
        </member>
        <member name="T:WX.Alignment">
            <summary>Alignments.
            for instance in instances of wx.Sizer.
            </summary>
        </member>
        <member name="F:WX.Alignment.Not">
            <summary>
            The zero flag. Useful to find out whether an non-default flag is undefined.
            But keep in mind, that the default alignments are not represented by a particular
            flag but by the absence of non-default alignment flags.
            </summary>
        </member>
        <member name="F:WX.Alignment.Left">
            <summary>
            Horizontal alignment is left justitified. This is the default and, thus, this flag equals
            <c>wxALIGN_NOT</c>.
            </summary>
        </member>
        <member name="F:WX.Alignment.Top">
            <summary>
            Vertical alignment is top justitified. This is the default and, thus, this flag equals
            <c>wxALIGN_NOT</c>.
            </summary>
        </member>
        <member name="F:WX.Alignment.Center">
            <summary>
            Horizontal as well as vertical alignment: Put the output in the centre.
            </summary>
        </member>
        <member name="F:WX.Alignment.Mask">
            <summary>
            The mask comprising all alignment flags.
            </summary>
        </member>
        <member name="F:WX.Alignment.Centre">
            <summary>
            Horizontal as well as vertical alignment: Put the output in the centre.
            </summary>
        </member>
        <member name="T:WX.SizerFlag">
            <summary>Flags from <c>wx.Stretch</c>, <c>wx.Direction</c> and <c>wx.Alignment</c>.
            This will be used in instances of wx.Sizer when adding new windows.
            </summary>
        </member>
        <member name="F:WX.SizerFlag.None">
            <summary>No flag at all.
            If unique, specifies default behaviour.</summary>
        </member>
        <member name="F:WX.SizerFlag.Left">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.Right">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.Up">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.Down">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.Top">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.Bottom">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.North">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.South">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.West">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.East">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.All">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:WX.SizerFlag.StretchNot">
            <summary>This is a flag on stretching.
            Refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.Shrink">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.Grow">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.Expand">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.Shaped">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.FixedMinSize">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.Tile">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:WX.SizerFlag.AdjustMinSize">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.
            changed in wxWidgets 2.5.2, see discussion on wx-dev</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignNot">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignCenterHorizontal">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignLeft">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignTop">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignRight">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignBottom">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignCenterVertical">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignCenter">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.AlignMask">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.CentreVertical">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.CentreHorizontal">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:WX.SizerFlag.Centre">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="T:WX.MouseButton">
            <summary>Enumeration of mouse buttons.</summary>
        </member>
        <member name="F:WX.UpdateUIMode.ProcessAll">
            <summary>
            Send UI update events to all windows
            </summary>
        </member>
        <member name="F:WX.UpdateUIMode.ProcessSpecified">
            <summary> Send UI update events to windows that have
            the wxWS_EX_PROCESS_UI_UPDATES flag specified </summary>
        </member>
        <member name="T:WX.Clipboard">
             <summary>
             A class for manipulating the clipboard.
             Note that this is not compatible with the clipboard class from wxWidgets
             1.xx, which has the same name but a different implementation.
            
             To use the clipboard, you call member functions of the global <c>TheClipboard</c> object.
             
             Cf. \ref drag-and-drop.
             
             Call wx.Clipboard.Open to get ownership of the clipboard. If this operation returns true, you now own the clipboard.
             Call wx.Clipboard.SetData to put data on the clipboard, or wx.Clipboard.GetData to retrieve data from the clipboard.
             Call wx.Clipboard.Close to close the clipboard and relinquish ownership.
             You should keep the clipboard open only momentarily.
             </summary>
        </member>
        <member name="M:WX.Clipboard.#ctor">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:WX.Clipboard.Open">
             <summary>
             Call this function to open the clipboard before calling wx.Clipboard.SetData and wx.Clipboard.GetData.
            
             Call wx.Clipboard.Close when you have finished with the clipboard.
             You should keep the clipboard open for only a very short time.
            
             
             </summary>
             <returns>Returns true on success. This should be tested (as in the sample shown above).</returns>
        </member>
        <member name="M:WX.Clipboard.Close">
            <summary>
            Call this function to close the clipboard, having opened it with wx.Clipboard.Open.
            </summary>
        </member>
        <member name="M:WX.Clipboard.IsOpened">
            <summary>
            Returns true if the clipboard has been opened.
            </summary>
            <returns></returns>
        </member>
        <member name="M:WX.Clipboard.AddData(WX.DataObject)">
             <summary>
             Call this function to add the data object to the clipboard.
             You may call this function repeatedly after having cleared the clipboard using wx.Clipboard.Clear.
            
             After this function has been called, the clipboard owns the data, so do not delete the data explicitly.
             </summary>
             <param name="data">The data to be added</param>
             <returns></returns>
        </member>
        <member name="M:WX.Clipboard.SetData(WX.DataObject)">
             <summary>
             Call this function to set the data object to the clipboard.
             This function will clear all previous contents in the clipboard, so calling it several times does not make any sense.
            
             After this function has been called, the clipboard owns the data, so do not delete the data explicitly.
             </summary>
             <param name="data">The data that will be set.</param>
             <returns></returns>
        </member>
        <member name="M:WX.Clipboard.GetData(WX.DataObject)">
            <summary>
            Call this function to fill data with <c>data</c> on the clipboard, if available in the required format.
            Returns true on success.
            </summary>
            <param name="data">This data object will be loaded with the data from the clipboard.</param>
            <returns></returns>
        </member>
        <member name="M:WX.Clipboard.IsSupported(WX.DataFormat)">
            <summary>
            Returns true if there is data which matches the data format of the given data object currently available
            on the clipboard.
            </summary>
            <param name="format">The requested format</param>
            <returns></returns>
        </member>
        <member name="M:WX.Clipboard.Clear">
            <summary>
            Clears the global clipboard object and the system's clipboard if possible.
            </summary>
        </member>
        <member name="M:WX.Clipboard.Flush">
            <summary>
            Flushes the clipboard: this means that the data which is currently on clipboard will 
            stay available even after the application exits (possibly eating memory), 
            otherwise the clipboard will be emptied on exit.
            </summary>
            <returns>Returns false if the operation is unsuccessful for any reason.</returns>
        </member>
        <member name="M:WX.Clipboard.UsePrimarySelection(System.Boolean)">
            <summary>
            On platforms supporting it (currently only GTK), selects the so called PRIMARY SELECTION as the clipboard as opposed to the normal clipboard, if primary is true.
            </summary>
            <param name="primary">True iff the so-called PRIMARY SELECTION shall be used if available.</param>
        </member>
        <member name="P:WX.Clipboard.TheClipboard">
            <summary>
            The static default instance of this class.
            </summary>
        </member>
    </members>
</doc>
